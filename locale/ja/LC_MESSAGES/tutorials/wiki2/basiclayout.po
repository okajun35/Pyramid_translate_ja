# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Pyramid Web Framework 1.9.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-02 00:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../tutorials/wiki2/basiclayout.rst:5
msgid "Basic Layout"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:7
msgid ""
"The starter files generated by the ``alchemy`` cookiecutter are very "
"basic, but they provide a good orientation for the high-level patterns "
"common to most :term:`URL dispatch`-based :app:`Pyramid` projects."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:13
msgid "Application configuration with ``__init__.py``"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:15
msgid ""
"A directory on disk can be turned into a Python :term:`package` by "
"containing an ``__init__.py`` file.  Even if empty, this marks a "
"directory as a Python package.  We use ``__init__.py`` both as a marker, "
"indicating the directory in which it's contained is a package, and to "
"contain application configuration code."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:21
msgid "Open ``tutorial/__init__.py``.  It should already contain the following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:27
msgid ""
"Let's go over this piece-by-piece. First we need some imports to support "
"later code:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:35
msgid ""
"``__init__.py`` defines a function named ``main``.  Here is the entirety "
"of the ``main`` function we've defined in our ``__init__.py``:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:43
msgid ""
"When you invoke the ``pserve development.ini`` command, the ``main`` "
"function above is executed.  It accepts some settings and returns a "
":term:`WSGI` application.  (See :ref:`startup_chapter` for more about "
"``pserve``.)"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:47
msgid "Next in ``main``, construct a :term:`Configurator` object:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:54
msgid ""
"``settings`` is passed to the ``Configurator`` as a keyword argument with"
" the dictionary values passed as the ``**settings`` argument. This will "
"be a dictionary of settings parsed from the ``.ini`` file, which contains"
" deployment-related values, such as ``pyramid.reload_templates``, "
"``sqlalchemy.url``, and so on."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:60
msgid ""
"Next include :term:`Jinja2` templating bindings so that we can use "
"renderers with the ``.jinja2`` extension within our project."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:68
msgid ""
"Next include the the package ``models`` using a dotted Python path. The "
"exact setup of the models will be covered later."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:76
msgid ""
"Next include the ``routes`` module using a dotted Python path. This "
"module will be explained in the next section."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:86
msgid ""
"Pyramid's :meth:`pyramid.config.Configurator.include` method is the "
"primary mechanism for extending the configurator and breaking your code "
"into feature-focused modules."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:90
msgid ""
"``main`` next calls the ``scan`` method of the configurator "
"(:meth:`pyramid.config.Configurator.scan`), which will recursively scan "
"our ``tutorial`` package, looking for ``@view_config`` and other special "
"decorators. When it finds a ``@view_config`` decorator, a view "
"configuration will be registered, allowing one of our application URLs to"
" be mapped to some code."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:102
msgid ""
"Finally ``main`` is finished configuring things, so it uses the "
":meth:`pyramid.config.Configurator.make_wsgi_app` method to return a "
":term:`WSGI` application:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:113
msgid "Route declarations"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:115
msgid ""
"Open the ``tutorial/routes.py`` file. It should already contain the "
"following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:121
msgid ""
"On line 2, we call :meth:`pyramid.config.Configurator.add_static_view` "
"with three arguments: ``static`` (the name), ``static`` (the path), and "
"``cache_max_age`` (a keyword argument)."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:125
msgid ""
"This registers a static resource view which will match any URL that "
"starts with the prefix ``/static`` (by virtue of the first argument to "
"``add_static_view``). This will serve up static resources for us from "
"within the ``static`` directory of our ``tutorial`` package, in this case"
" via ``http://localhost:6543/static/`` and below (by virtue of the second"
" argument to ``add_static_view``).  With this declaration, we're saying "
"that any URL that starts with ``/static`` should go to the static view; "
"any remainder of its path (e.g., the ``/foo`` in ``/static/foo``) will be"
" used to compose a path to a static file resource, such as a CSS file."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:135
msgid ""
"On line 3, the module registers a :term:`route configuration` via the "
":meth:`pyramid.config.Configurator.add_route` method that will be used "
"when the URL is ``/``. Since this route has a ``pattern`` equaling ``/``,"
" it is the route that will be matched when the URL ``/`` is visited, "
"e.g., ``http://localhost:6543/``."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:143
msgid "View declarations via the ``views`` package"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:145
msgid ""
"The main function of a web framework is mapping each URL pattern to code "
"(a :term:`view callable`) that is executed when the requested URL matches"
" the corresponding :term:`route`. Our application uses the "
":meth:`pyramid.view.view_config` decorator to perform this mapping."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:150
msgid ""
"Open ``tutorial/views/default.py`` in the ``views`` package.  It should "
"already contain the following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:157
msgid ""
"The important part here is that the ``@view_config`` decorator associates"
" the function it decorates (``my_view``) with a :term:`view "
"configuration`, consisting of:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:161
msgid "a ``route_name`` (``home``)"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:162
msgid ""
"a ``renderer``, which is a template from the ``templates`` subdirectory "
"of the package."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:165
msgid ""
"When the pattern associated with the ``home`` view is matched during a "
"request, ``my_view()`` will be executed.  ``my_view()`` returns a "
"dictionary; the renderer will use the ``templates/mytemplate.jinja2`` "
"template to create a response based on the values in the dictionary."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:170
msgid ""
"Note that ``my_view()`` accepts a single argument named ``request``.  "
"This is the standard call signature for a Pyramid :term:`view callable`."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:173
msgid ""
"Remember in our ``__init__.py`` when we executed the "
":meth:`pyramid.config.Configurator.scan` method ``config.scan()``? The "
"purpose of calling the scan method was to find and process this "
"``@view_config`` decorator in order to create a view configuration within"
" our application. Without being processed by ``scan``, the decorator "
"effectively does nothing. ``@view_config`` is inert without being "
"detected via a :term:`scan`."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:180
msgid ""
"The sample ``my_view()`` created by the cookiecutter uses a ``try:`` and "
"``except:`` clause to detect if there is a problem accessing the project "
"database and provide an alternate error response.  That response will "
"include the text shown at the end of the file, which will be displayed in"
" the browser to inform the user about possible actions to take to solve "
"the problem."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:188
msgid "Content models with the ``models`` package"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:190
msgid ""
"In an SQLAlchemy-based application, a *model* object is an object "
"composed by querying the SQL database. The ``models`` package is where "
"the ``alchemy`` cookiecutter put the classes that implement our models."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:194
msgid ""
"First, open ``tutorial/models/meta.py``, which should already contain the"
" following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:201
msgid ""
"``meta.py`` contains imports and support code for defining the models. We"
" create a dictionary ``NAMING_CONVENTION`` as well for consistent naming "
"of support objects like indices and constraints."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:210
msgid ""
"Next we create a ``metadata`` object from the class "
":class:`sqlalchemy.schema.MetaData`, using ``NAMING_CONVENTION`` as the "
"value for the ``naming_convention`` argument."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:214
msgid ""
"A ``MetaData`` object represents the table and other schema definitions "
"for a single database. We also need to create a declarative ``Base`` "
"object to use as a base class for our models. Our models will inherit "
"from this ``Base``, which will attach the tables to the ``metadata`` we "
"created, and define our application's database schema."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:225
msgid ""
"Next open ``tutorial/models/mymodel.py``, which should already contain "
"the following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:232
msgid ""
"Notice we've defined the ``models`` as a package to make it "
"straightforward for defining models in separate modules. To give a simple"
" example of a model class, we have defined one named ``MyModel`` in "
"``mymodel.py``:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:241
msgid ""
"Our example model does not require an ``__init__`` method because "
"SQLAlchemy supplies for us a default constructor, if one is not already "
"present, which accepts keyword arguments of the same name as that of the "
"mapped attributes."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:245
msgid "Example usage of MyModel:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:251
msgid ""
"The ``MyModel`` class has a ``__tablename__`` attribute.  This informs "
"SQLAlchemy which table to use to store the data representing instances of"
" this class."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:255
msgid ""
"Finally, open ``tutorial/models/__init__.py``, which should already "
"contain the following:"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:262
msgid ""
"Our ``models/__init__.py`` module defines the primary API we will use for"
" configuring the database connections within our application, and it "
"contains several functions we will cover below."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:266
msgid ""
"As we mentioned above, the purpose of the ``models.meta.metadata`` object"
" is to describe the schema of the database. This is done by defining "
"models that inherit from the ``Base`` object attached to that "
"``metadata`` object. In Python, code is only executed if it is imported, "
"and so to attach the ``models`` table defined in ``mymodel.py`` to the "
"``metadata``, we must import it. If we skip this step, then later, when "
"we run :meth:`sqlalchemy.schema.MetaData.create_all`, the table will not "
"be created because the ``metadata`` object does not know about it!"
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:275
msgid ""
"Another important reason to import all of the models is that, when "
"defining relationships between models, they must all exist in order for "
"SQLAlchemy to find and build those internal mappings. This is why, after "
"importing all the models, we explicitly execute the function "
":func:`sqlalchemy.orm.configure_mappers`, once we are sure all the models"
" have been defined and before we start creating connections."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:282
msgid ""
"Next we define several functions for connecting to our database. The "
"first and lowest level is the ``get_engine`` function. This creates an "
":term:`SQLAlchemy` database engine using "
":func:`sqlalchemy.engine_from_config` from the ``sqlalchemy.``-prefixed "
"settings in the ``development.ini`` file's ``[app:main]`` section. This "
"setting is a URI (something like ``sqlite://``)."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:293
msgid ""
"The function ``get_session_factory`` accepts an :term:`SQLAlchemy` "
"database engine, and creates a ``session_factory`` from the "
":term:`SQLAlchemy` class :class:`sqlalchemy.orm.session.sessionmaker`. "
"This ``session_factory`` is then used for creating sessions bound to the "
"database engine."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:303
msgid ""
"The function ``get_tm_session`` registers a database session with a "
"transaction manager, and returns a ``dbsession`` object. With the "
"transaction manager, our application will automatically issue a "
"transaction commit after every request, unless an exception is raised, in"
" which case the transaction will be aborted."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:313
msgid ""
"Finally, we define an ``includeme`` function, which is a hook for use "
"with :meth:`pyramid.config.Configurator.include` to activate code in a "
"Pyramid application add-on. It is the code that is executed above when we"
" ran ``config.include('.models')`` in our application's ``main`` "
"function. This function will take the settings from the application, "
"create an engine, and define a ``request.dbsession`` property, which we "
"can use to do work on behalf of an incoming request to our application."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:326
msgid ""
"That's about all there is to it regarding models, views, and "
"initialization code in our stock application."
msgstr ""

#: ../../tutorials/wiki2/basiclayout.rst:329
msgid ""
"The ``Index`` import and the ``Index`` object creation in ``mymodel.py`` "
"is not required for this tutorial, and will be removed in the next step."
msgstr ""


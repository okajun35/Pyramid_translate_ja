
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyramid.util &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="copyright" title="著作権" href="../../copyright.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../../index.html">
      		<img class="logo" src="../../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
    	<li><a href="../../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">モジュールコード</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>pyramid.util のソースコード</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># py2.7.7+ and py3.3+ have native comparison support</span>
    <span class="kn">from</span> <span class="nn">hmac</span> <span class="k">import</span> <span class="n">compare_digest</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">compare_digest</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="k">import</span> <span class="n">implementer</span>

<span class="kn">from</span> <span class="nn">pyramid.exceptions</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ConfigurationError</span><span class="p">,</span>
    <span class="n">CyclicDependencyError</span><span class="p">,</span>
    <span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyramid.compat</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">getargspec</span><span class="p">,</span>
    <span class="n">im_func</span><span class="p">,</span>
    <span class="n">is_nonstr_iter</span><span class="p">,</span>
    <span class="n">integer_types</span><span class="p">,</span>
    <span class="n">string_types</span><span class="p">,</span>
    <span class="n">text_</span><span class="p">,</span>
    <span class="n">PY2</span><span class="p">,</span>
    <span class="n">native_</span>
    <span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="k">import</span> <span class="n">IActionInfo</span>
<span class="kn">from</span> <span class="nn">pyramid.path</span> <span class="k">import</span> <span class="n">DottedNameResolver</span> <span class="k">as</span> <span class="n">_DottedNameResolver</span>

<span class="n">_marker</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">DottedNameResolver</span><span class="p">(</span><span class="n">_DottedNameResolver</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># default to package = None for bw compat</span>
        <span class="n">_DottedNameResolver</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_string_or_iterable</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">as_sorted_tuple</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">class</span> <span class="nc">InstancePropertyHelper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A helper object for assigning properties and descriptors to instances.</span>
<span class="sd">    It is not normally possible to do this because descriptors must be</span>
<span class="sd">    defined on the class itself.</span>

<span class="sd">    This class is optimized for adding multiple properties at once to an</span>
<span class="sd">    instance. This is done by calling :meth:`.add_property` once</span>
<span class="sd">    per-property and then invoking :meth:`.apply` on target objects.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert a callable into one suitable for adding to the</span>
<span class="sd">        instance. This will return a 2-tuple containing the computed</span>
<span class="sd">        (name, property) pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_property</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_property</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">callable</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must specify &quot;name&quot; for a property&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reify</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot reify a property&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">this</span><span class="p">:</span> <span class="n">callable</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
            <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">get_callable_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">fn</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">callable</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">callable</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">callable</span>
        <span class="k">if</span> <span class="n">reify</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pyramid.decorator</span> <span class="c1"># avoid circular import</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">pyramid</span><span class="o">.</span><span class="n">decorator</span><span class="o">.</span><span class="n">reify</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_property</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">apply_properties</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accept a list or dict of ``properties`` generated from</span>
<span class="sd">        :meth:`.make_property` and apply them to a ``target`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="n">newcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="n">attrs</span><span class="p">)</span>
            <span class="c1"># We assign __provides__ and __implemented__ below to prevent a</span>
            <span class="c1"># memory leak that results from from the usage of this instance&#39;s</span>
            <span class="c1"># eventual use in an adapter lookup.  Adapter lookup results in</span>
            <span class="c1"># ``zope.interface.implementedBy`` being called with the</span>
            <span class="c1"># newly-created class as an argument.  Because the newly-created</span>
            <span class="c1"># class has no interface specification data of its own, lookup</span>
            <span class="c1"># causes new ClassProvides and Implements instances related to our</span>
            <span class="c1"># just-generated class to be created and set into the newly-created</span>
            <span class="c1"># class&#39; __dict__.  We don&#39;t want these instances to be created; we</span>
            <span class="c1"># want this new class to behave exactly like it is the parent class</span>
            <span class="c1"># instead.  See GitHub issues #1212, #1529 and #1568 for more</span>
            <span class="c1"># information.</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;__implemented__&#39;</span><span class="p">,</span> <span class="s1">&#39;__provides__&#39;</span><span class="p">):</span>
                <span class="c1"># we assign these attributes conditionally to make it possible</span>
                <span class="c1"># to test this class in isolation without having any interfaces</span>
                <span class="c1"># attached to it</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_marker</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">newcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">target</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">newcls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_property</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper method to apply a single property to an instance.&quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_property</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="n">reify</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">apply_properties</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">[</span><span class="n">prop</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">add_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new property configuration.</span>

<span class="sd">        This should be used in combination with :meth:`.apply` as a</span>
<span class="sd">        more efficient version of :meth:`.set_property`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_property</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="n">reify</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply all configured properties to the ``target`` instance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_properties</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">InstancePropertyMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Mixin that will allow an instance to add properties at</span>
<span class="sd">    run-time as if they had been defined via @property or @reify</span>
<span class="sd">    on the class itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a callable or a property descriptor to the instance.</span>

<span class="sd">        Properties, unlike attributes, are lazily evaluated by executing</span>
<span class="sd">        an underlying callable when accessed. They can be useful for</span>
<span class="sd">        adding features to an object without any cost if those features</span>
<span class="sd">        go unused.</span>

<span class="sd">        A property may also be reified via the</span>
<span class="sd">        :class:`pyramid.decorator.reify` decorator by setting</span>
<span class="sd">        ``reify=True``, allowing the result of the evaluation to be</span>
<span class="sd">        cached. Using this method, the value of the property is only</span>
<span class="sd">        computed once for the lifetime of the object.</span>

<span class="sd">        ``callable`` can either be a callable that accepts the instance</span>
<span class="sd">        as its single positional parameter, or it can be a property</span>
<span class="sd">        descriptor.</span>

<span class="sd">        If the ``callable`` is a property descriptor, the ``name``</span>
<span class="sd">        parameter must be supplied or a ``ValueError`` will be raised.</span>
<span class="sd">        Also note that a property descriptor cannot be reified, so</span>
<span class="sd">        ``reify`` must be ``False``.</span>

<span class="sd">        If ``name`` is None, the name of the property will be computed</span>
<span class="sd">        from the name of the ``callable``.</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">           :linenos:</span>

<span class="sd">           class Foo(InstancePropertyMixin):</span>
<span class="sd">               _x = 1</span>

<span class="sd">           def _get_x(self):</span>
<span class="sd">               return _x</span>

<span class="sd">           def _set_x(self, value):</span>
<span class="sd">               self._x = value</span>

<span class="sd">           foo = Foo()</span>
<span class="sd">           foo.set_property(property(_get_x, _set_x), name=&#39;x&#39;)</span>
<span class="sd">           foo.set_property(_get_x, name=&#39;y&#39;, reify=True)</span>

<span class="sd">           &gt;&gt;&gt; foo.x</span>
<span class="sd">           1</span>
<span class="sd">           &gt;&gt;&gt; foo.y</span>
<span class="sd">           1</span>
<span class="sd">           &gt;&gt;&gt; foo.x = 5</span>
<span class="sd">           &gt;&gt;&gt; foo.x</span>
<span class="sd">           5</span>
<span class="sd">           &gt;&gt;&gt; foo.y # notice y keeps the original value</span>
<span class="sd">           1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">InstancePropertyHelper</span><span class="o">.</span><span class="n">set_property</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="n">reify</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WeakOrderedSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Maintain a set of items.</span>

<span class="sd">    Each item is stored as a weakref to avoid extending their lifetime.</span>

<span class="sd">    The values may be iterated over or the last item added may be</span>
<span class="sd">    accessed via the ``last`` property.</span>

<span class="sd">    If items are added more than once, the most recent addition will</span>
<span class="sd">    be remembered in the order:</span>

<span class="sd">        order = WeakOrderedSet()</span>
<span class="sd">        order.add(&#39;1&#39;)</span>
<span class="sd">        order.add(&#39;2&#39;)</span>
<span class="sd">        order.add(&#39;1&#39;)</span>

<span class="sd">        list(order) == [&#39;2&#39;, &#39;1&#39;]</span>
<span class="sd">        order.last == &#39;1&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add an item to the set.&quot;&quot;&quot;</span>
        <span class="n">oid</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_by_id</span><span class="p">(</span><span class="n">oid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove an item from the set.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">oid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove an item from the set.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_by_id</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Clear all objects from the set.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">oid</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">oid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">oid</span><span class="p">]()</span> <span class="k">for</span> <span class="n">oid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">oid</span><span class="p">]()</span>

<span class="k">def</span> <span class="nf">strings_differ</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">,</span> <span class="n">compare_digest</span><span class="o">=</span><span class="n">compare_digest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check whether two strings differ while avoiding timing attacks.</span>

<span class="sd">    This function returns True if the given strings differ and False</span>
<span class="sd">    if they are equal.  It&#39;s careful not to leak information about *where*</span>
<span class="sd">    they differ as a result of its running time, which can be very important</span>
<span class="sd">    to avoid certain timing-related crypto attacks:</span>

<span class="sd">        http://seb.dbzteam.org/crypto/python-oauth-timing-hmac.pdf</span>

<span class="sd">    .. versionchanged:: 1.6</span>
<span class="sd">       Support :func:`hmac.compare_digest` if it is available (Python 2.7.7+</span>
<span class="sd">       and Python 3.3+).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_eq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">string2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">len_eq</span><span class="p">:</span>
        <span class="n">invalid_bits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">string1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">invalid_bits</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">string2</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">string2</span>

    <span class="k">if</span> <span class="n">compare_digest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">invalid_bits</span> <span class="o">+=</span> <span class="ow">not</span> <span class="n">compare_digest</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
            <span class="n">invalid_bits</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">invalid_bits</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">object_description</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Produce a human-consumable text description of ``object``,</span>
<span class="sd">    usually involving a Python dotted name. For example:</span>

<span class="sd">    &gt;&gt;&gt; object_description(None)</span>
<span class="sd">    u&#39;None&#39;</span>
<span class="sd">    &gt;&gt;&gt; from xml.dom import minidom</span>
<span class="sd">    &gt;&gt;&gt; object_description(minidom)</span>
<span class="sd">    u&#39;module xml.dom.minidom&#39;</span>
<span class="sd">    &gt;&gt;&gt; object_description(minidom.Attr)</span>
<span class="sd">    u&#39;class xml.dom.minidom.Attr&#39;</span>
<span class="sd">    &gt;&gt;&gt; object_description(minidom.Attr.appendChild)</span>
<span class="sd">    u&#39;method appendChild of class xml.dom.minidom.Attr&#39;</span>

<span class="sd">    If this method cannot identify the type of the object, a generic</span>
<span class="sd">    description ala ``object &lt;object.__name__&gt;`` will be returned.</span>

<span class="sd">    If the object passed is already a string, it is simply returned.  If it</span>
<span class="sd">    is a boolean, an integer, a list, a tuple, a set, or ``None``, a</span>
<span class="sd">    (possibly shortened) string representation is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;object </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
    <span class="n">modulename</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismodule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;module </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">modulename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">oself</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__self__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oself</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
            <span class="n">oself</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;im_self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;method </span><span class="si">%s</span><span class="s1"> of class </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">modulename</span><span class="p">,</span>
                      <span class="n">oself</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">dottedname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">modulename</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;class </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dottedname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">dottedname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">modulename</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;function </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dottedname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text_</span><span class="p">(</span><span class="s1">&#39;object </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">shortrepr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">closer</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; ... </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">closer</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="k">class</span> <span class="nc">Sentinel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">repr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repr</span> <span class="o">=</span> <span class="nb">repr</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">repr</span>

<span class="n">FIRST</span> <span class="o">=</span> <span class="n">Sentinel</span><span class="p">(</span><span class="s1">&#39;FIRST&#39;</span><span class="p">)</span>
<span class="n">LAST</span> <span class="o">=</span> <span class="n">Sentinel</span><span class="p">(</span><span class="s1">&#39;LAST&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TopologicalSorter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A utility class which can be used to perform topological sorts against</span>
<span class="sd">    tuple-like data.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">default_before</span><span class="o">=</span><span class="n">LAST</span><span class="p">,</span>
        <span class="n">default_after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">first</span><span class="o">=</span><span class="n">FIRST</span><span class="p">,</span>
        <span class="n">last</span><span class="o">=</span><span class="n">LAST</span><span class="p">,</span>
        <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_before</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_after</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name2before</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name2after</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name2val</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_before</span> <span class="o">=</span> <span class="n">default_before</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_after</span> <span class="o">=</span> <span class="n">default_after</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2val</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a node from the sort input &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2val</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2after</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">after</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_after</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">after</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2before</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_before</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">before</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
                
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a node to the sort input.  The ``name`` should be a string or</span>
<span class="sd">        any other hashable object, the ``val`` should be the sortable (doesn&#39;t</span>
<span class="sd">        need to be hashable).  ``after`` and ``before`` represents the name of</span>
<span class="sd">        one of the other sortables (or a sequence of such named) or one of the</span>
<span class="sd">        special sentinel values :attr:`pyramid.util.FIRST`` or</span>
<span class="sd">        :attr:`pyramid.util.LAST` representing the first or last positions</span>
<span class="sd">        respectively.  ``FIRST`` and ``LAST`` can also be part of a sequence</span>
<span class="sd">        passed as ``before`` or ``after``.  A sortable should not be added</span>
<span class="sd">        after LAST or before FIRST.  An example::</span>

<span class="sd">           sorter = TopologicalSorter()</span>
<span class="sd">           sorter.add(&#39;a&#39;, {&#39;a&#39;:1}, before=LAST, after=&#39;b&#39;)</span>
<span class="sd">           sorter.add(&#39;b&#39;, {&#39;b&#39;:2}, before=LAST, after=&#39;c&#39;)</span>
<span class="sd">           sorter.add(&#39;c&#39;, {&#39;c&#39;:3})</span>

<span class="sd">           sorter.sorted() # will be {&#39;c&#39;:3}, {&#39;b&#39;:2}, {&#39;a&#39;:1}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name2val</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_before</span>
            <span class="n">after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_after</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">after</span><span class="p">):</span>
                <span class="n">after</span> <span class="o">=</span> <span class="p">(</span><span class="n">after</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name2after</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">after</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">after</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_after</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">before</span><span class="p">):</span>
                <span class="n">before</span> <span class="o">=</span> <span class="p">(</span><span class="n">before</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name2before</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">before</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">before</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_before</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the sort input values in topologically sorted order&quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span><span class="p">)]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span><span class="p">]</span>
        <span class="n">names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># 0 = number of arcs coming into this node</span>

        <span class="k">def</span> <span class="nf">add_arc</span><span class="p">(</span><span class="n">fromnode</span><span class="p">,</span> <span class="n">tonode</span><span class="p">):</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">fromnode</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tonode</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">tonode</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">tonode</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tonode</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">add_node</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">has_before</span><span class="p">,</span> <span class="n">has_after</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">names</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span> <span class="c1"># deal with missing dependencies</span>
                <span class="n">add_arc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">has_before</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">has_after</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_before</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">has_before</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span>
                <span class="s1">&#39;Unsatisfied before dependencies: </span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_before</span> <span class="o">-</span> <span class="n">has_before</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">req_after</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">has_after</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span>
                <span class="s1">&#39;Unsatisfied after dependencies: </span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req_after</span> <span class="o">-</span> <span class="n">has_after</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="n">sorted_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">roots</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">roots</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sorted_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">arcs</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">arcs</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">child</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arcs</span> 
                <span class="k">if</span> <span class="n">arcs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">roots</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">graph</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">graph</span><span class="p">:</span>
            <span class="c1"># loop in input</span>
            <span class="n">cycledeps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">cycledeps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">raise</span> <span class="n">CyclicDependencyError</span><span class="p">(</span><span class="n">cycledeps</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sorted_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name2val</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">viewdefaults</span><span class="p">(</span><span class="n">wrapped</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Decorator for add_view-like methods which takes into account</span>
<span class="sd">    __view_defaults__ attached to view it is passed.  Not a documented API but</span>
<span class="sd">    used by some external systems.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">arg</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;view&#39;</span><span class="p">)</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_dotted</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">view</span><span class="p">):</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="s1">&#39;__view_defaults__&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;_backframes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;_backframes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># for action_method</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IActionInfo</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ActionInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">srclines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;    </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">srclines</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;Line </span><span class="si">%s</span><span class="s1"> of file </span><span class="si">%s</span><span class="s1">:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">action_method</span><span class="p">(</span><span class="n">wrapped</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrapper to provide the right conflict info report data when a method</span>
<span class="sd">    that calls Configurator.action calls another that does the same.  Not a</span>
<span class="sd">    documented API but used by some external systems.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ainfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ainfo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># backframes for outer decorators to actionmethods</span>
        <span class="n">backframes</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_backframes&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">is_nonstr_iter</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># _info permitted as extract_stack tuple</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">ActionInfo</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

                <span class="c1"># Work around a Python 3.5 issue whereby it would insert an</span>
                <span class="c1"># extra stack frame. This should no longer be necessary in</span>
                <span class="c1"># Python 3.5.1</span>
                <span class="n">last_frame</span> <span class="o">=</span> <span class="n">ActionInfo</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">last_frame</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="s1">&#39;extract_stack&#39;</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">info</span> <span class="o">=</span> <span class="n">ActionInfo</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="n">backframes</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="c1"># pragma: no cover</span>
                <span class="n">info</span> <span class="o">=</span> <span class="n">ActionInfo</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ainfo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ainfo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
        <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__docobj__</span> <span class="o">=</span> <span class="n">wrapped</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">get_callable_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verifies that the ``name`` is ascii and will raise a ``ConfigurationError``</span>
<span class="sd">    if it is not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">native_</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeEncodeError</span><span class="p">,</span> <span class="ne">UnicodeDecodeError</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;`name=&quot;</span><span class="si">%s</span><span class="s1">&quot;` is invalid. `name` must be ascii because it is &#39;</span>
            <span class="s1">&#39;used on __name__ of the method&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">hide_attrs</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Temporarily delete object attrs and restore afterward.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj_vals</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">saved_vals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="n">saved_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_marker</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">saved_val</span> <span class="o">=</span> <span class="n">saved_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">saved_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_marker</span><span class="p">:</span>
                <span class="n">obj_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">saved_val</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">obj_vals</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">obj_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">is_same_domain</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return ``True`` if the host is either an exact match or a match</span>
<span class="sd">    to the wildcard pattern.</span>
<span class="sd">    Any pattern beginning with a period matches a domain and all of its</span>
<span class="sd">    subdomains. (e.g. ``.example.com`` matches ``example.com`` and</span>
<span class="sd">    ``foo.example.com``). Anything else is an exact string match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span> <span class="ow">and</span>
            <span class="p">(</span><span class="n">host</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="ow">or</span> <span class="n">host</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">or</span>
            <span class="n">pattern</span> <span class="o">==</span> <span class="n">host</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">takes_one_arg</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ismethod</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;__call__&#39;</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isroutine</span><span class="p">(</span><span class="n">callee</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">callee</span>
    <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">callee</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">callee</span><span class="o">.</span><span class="fm">__init__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">ismethod</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">argspec</span> <span class="o">=</span> <span class="n">getargspec</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">im_func</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ismethod</span><span class="p">:</span>
        <span class="c1"># it&#39;s an instance method (or unbound method on py2)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">argname</span><span class="p">:</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">argname</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
    	<li><a href="../../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >モジュールコード</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 11月 07, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 で生成しました。
    </div>
  </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>(機械翻訳) URLディスパッチ &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="ビュー(Views)" href="views.html" />
    <link rel="prev" title="リクエスト処理(Request Processing)" href="router.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="views.html" title="ビュー(Views)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="router.html" title="リクエスト処理(Request Processing)"
             accesskey="P">前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="url-dispatch">
<span id="urldispatch-chapter"></span><span id="index-0"></span><h1>(機械翻訳) URLディスパッチ<a class="headerlink" href="#url-dispatch" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>：term： <cite>URL dispatch`は、簡単なパターンマッチング言語を使ってURLを：term：</cite> view`コードにマップする簡単な方法を提供します。パターンの順序付けられたセットが1つずつチェックされます。パターンの1つが要求に関連するパス情報と一致する場合、特定の：term： <cite>view callable`が呼び出されます。ビュー呼び出し可能とは、アプリケーションで定義された：term： `request`を受け取り、：term：</cite> response`オブジェクトを返すコードの特定のビットです。</p>
<div class="section" id="high-level-operational-overview">
<h2>高度な運用概要<a class="headerlink" href="#high-level-operational-overview" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>アプリケーションにルートコンフィグレーションがある場合、：app： <cite>Pyramid</cite>：term：` Router`は、<a href="#id1"><span class="problematic" id="id2">*</span></a>ルートマップ*に存在するURLマッチングパターンの順序付けられたセットに対してすべての着信要求をチェックします。</p>
<p>ルートパターンが：term： <cite>request`の情報と一致する場合、：app：</cite> Pyramid`は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view lookup`プロセスを呼び出して、一致するビューを探します。</p>
<p>ルートマップのルートパターンが、アプリケーション内で提供された：term： <cite>request`の情報と一致しない場合、：app：</cite> Pyramid`は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>traversal`を使用してフェイルオーバし、リソースの場所とビューの参照を実行します。</p>
</div>
<div class="section" id="route-configuration">
<span id="index-1"></span><h2>ルート設定<a class="headerlink" href="#route-configuration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：term： <cite>ルート設定`は、新しい：term： `ルート`をアプリケーションに追加する行為です。ルートには* name *があり、URL生成に使用される識別子として機能します。開発者はこの名前を使用して、ビュー設定をルートに関連付けることもできます。ルートには、URLの `</cite> PATH_INFO`部分（スキームとポートに続く部分、例えば `` / foo / bar``のURL http：//にある部分と一致する*パターン* / localhost：8080 / foo / bar``）。オプションで、 `` factory``と `` term： `` `` `` `` `` <cite>述語</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>の属性を持っています。</p>
<div class="section" id="configuring-a-route-to-match-a-view">
<span id="config-add-route"></span><span id="index-2"></span><h3>ビューと一致するようにルートを設定する<a class="headerlink" href="#configuring-a-route-to-match-a-view" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.config.Configurator.add_route`メソッドは：term：<a href="#id3"><span class="problematic" id="id4">`</span></a>アプリケーションレジストリ <a href="#id5"><span class="problematic" id="id6">`</span></a>に単一の：term：<a href="#id7"><span class="problematic" id="id8">`</span></a>ルート設定 &amp;#39;を追加します。ここに例があります：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># &quot;config&quot; below is presumed to be an instance of the</span>
<span class="c1"># pyramid.config.Configurator class; &quot;myview&quot; is assumed</span>
<span class="c1"># to be a &quot;view callable&quot; function</span>
<span class="kn">from</span> <span class="nn">views</span> <span class="kn">import</span> <span class="n">myview</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;myroute&#39;</span><span class="p">,</span> <span class="s1">&#39;/prefix/{one}/{two}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">myview</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;myroute&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>：meth： <cite>〜pyramid.config.Configurator.add_view`を経由して設定に追加されたa：term：</cite> view callable`は、 `` route_name``述部を介してルートに関連付けられ、そのビューは常に見つかるでしょうリクエスト中に関連するルートパターンが一致したときに呼び出されます。</p>
<p>より一般的には、プロジェクトの&amp;quot;setup &amp;quot;コードで `` add_view``文を使用しません。あなたは代わりに `` add_route``ステートメントを使い、：term： <cite>scan`を使ってview呼び出し可能なものをルートに関連づけます。たとえば、これがプロジェクトの `</cite> __init __。py``の一部である場合：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;myroute&#39;</span><span class="p">,</span> <span class="s1">&#39;/prefix/{one}/{two}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="s1">&#39;mypackage&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>この設定コードでは、meth： <cite>〜pyramid.config.Configurator.add_view`を呼び出さないことに注意してください。しかし、上の：term： `scan`を実行する</cite> <cite>config.scan（ &amp;#39;mypackage&amp;#39;）</cite> <cite>は：class：</cite> pyramid.view.view_config `` mypackage`` Pythonパッケージの <a href="#id1"><span class="problematic" id="id2">``</span></a>デコレータ <a href="#id3"><span class="problematic" id="id4">``</span></a>たとえば、あなたのパッケージに `` views.py``がある場合、スキャンはその設定デコレータのどれかを拾うので、 `` myroute``を `` route_name``パラメータとして参照するものを追加できます：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;myroute&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>上記の `` add_route``と `` scan``の組み合わせは、 `` add_route``と `` add_view``の前の組み合わせを使うのと全く同じです。</p>
</div>
<div class="section" id="route-pattern-syntax">
<span id="index-3"></span><span id="id1"></span><h3>ルートパターンの構文<a class="headerlink" href="#route-pattern-syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The syntax of the pattern matching language used by <span>Pyramid</span> URL dispatch
in the <em>pattern</em> argument is straightforward.  It is close to that of the
<a class="reference internal" href="../glossary.html#term-routes"><span class="xref std std-term">Routes</span></a> system used by <a class="reference internal" href="../glossary.html#term-pylons"><span class="xref std std-term">Pylons</span></a>.</p>
<p>ルート設定で使用される*パターン*は、スラッシュ文字で始まることがあります。パターンがスラッシュ文字で始まらない場合は、暗黙のスラッシュが一致する時刻にその前に追加されます。たとえば、次のパターンは同等です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{foo}/bar/baz
</pre></div>
</div>
<p>そして：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/{foo}/bar/baz
</pre></div>
</div>
<p>パターンが有効なURLである場合、それは着信要求と照合されません。代わりに、外部URLを生成するのに便利です。参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>外部ルート&lt;external_route_narr&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>を参照してください。</p>
<p>パターンセグメント（パターン内の `` / <code class="docutils literal notranslate"><span class="pre">文字間の個々の項目）はリテラル文字列（例えば</span> <span class="pre">``</span> <span class="pre">foo</span></code>）*か代替マーカ（例えば `` {foo} <a href="#id1"><span class="problematic" id="id2">``</span></a>）、または両方の特定の組み合わせです。置換マーカーの前に `` / <a href="#id3"><span class="problematic" id="id4">``</span></a>文字を付ける必要はありません。</p>
<p>置換マーカーは、 `` {name} <code class="docutils literal notranslate"><span class="pre">の形式になっています。これは、次のスラッシュ文字までの任意の文字を受け入れ、これを</span> <span class="pre">``</span> <span class="pre">name</span></code>：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>matchdict`の値として使用することを意味します。</p>
<p>パターン内の置換マーカーは、大文字または小文字のASCII文字またはアンダースコアで始まり、大文字または小文字のASCII文字、アンダースコア、および数字のみで構成する必要があります。たとえば、 `` a``、 `` a_b``、 <cite>_b`</cite>、` <cite>b9``はすべて有効な置換マーカー名ですが、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>0a``はそうではありません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2 で変更: </span>ピラミッド1.2までは、置換マーカーはアンダースコアで開始できませんでした。以前のバージョンでは、置換マーカーが大文字または小文字で始まる必要がありました。</p>
</div>
<p>matchdictは、ルーティングパターンに基づいてURLから抽出された動的部分を表す辞書です。これは `` request.matchdict``として利用できます。たとえば、次のパターンは、リテラルセグメント（ `` foo``）と置換マーカー（ `` baz``、 `` bar``）を定義します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{baz}/{bar}
</pre></div>
</div>
<p>上記のパターンはこれらのURLと一致し、次のmatchdictsを生成します：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/1/2        -&gt; {&#39;baz&#39;:u&#39;1&#39;, &#39;bar&#39;:u&#39;2&#39;}
foo/abc/def    -&gt; {&#39;baz&#39;:u&#39;abc&#39;, &#39;bar&#39;:u&#39;def&#39;}
</pre></div>
</div>
<p>ただし、以下のパターンとは一致しません。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/1/2/        -&gt; No match (trailing slash)
bar/abc/def     -&gt; First segment literal mismatch
</pre></div>
</div>
<p>セグメント内のセグメント置換マーカーの一致は、パターン内のセグメント内の最初の非英数字文字までにのみ行われます。たとえば、このルートパターンが使用された場合は、次のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{name}.html
</pre></div>
</div>
<p>リテラルパス `` / foo / biz.html``は上記のルートパターンと一致し、一致結果は `` {&amp;#39;name&amp;#39;：u&amp;#39;biz &amp;#39;} <code class="docutils literal notranslate"><span class="pre">になります。しかし、リテラルパス</span> <span class="pre">``</span> <span class="pre">/</span> <span class="pre">foo</span> <span class="pre">/</span> <span class="pre">biz``は</span> <span class="pre">``</span> <span class="pre">{name}</span> <span class="pre">.html``で表されるセグメントの最後にリテラル</span> <span class="pre">``</span> <span class="pre">.html``を含んでいないので一致しません</span></code> biz.html`ではなく `` biz``を含みます）。</p>
<p>両方のセグメントをキャプチャするには、2つの置換マーカーを使用できます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{name}.{ext}
</pre></div>
</div>
<p>リテラルパス `` / foo / biz.html``は上記のルートパターンと一致し、 `` {&amp;#39;name&amp;#39;： &amp;#39;biz&amp;#39;、 &amp;#39;ext&amp;#39;： &amp;#39;html&amp;#39;} <a href="#id1"><span class="problematic" id="id2">``</span></a>となります。これは、2つの置換マーカー `` {name} <a href="#id3"><span class="problematic" id="id4">``</span></a>と `` {ext} <a href="#id5"><span class="problematic" id="id6">``</span></a>の間に `` .``（ピリオド）のリテラル部分があるために発生します。</p>
<p>置換マーカは、パスセグメントがマーカと一致するかどうかを判断するために使用される正規表現をオプションで指定できます。置換マーカーが正規表現で定義されている特定の文字セットのみと一致するように指定するには、若干拡張された置換マーカー構文を使用する必要があります。中カッコ内では、置換マーカー名の後にコロンを続け、その後すぐに正規表現を続けなければなりません。置換マーカー `` [^ /] + <a href="#id1"><span class="problematic" id="id2">``</span></a>に関連付けられた*デフォルトの正規表現は、スラッシュではない1つ以上の文字と一致します。例えば、フードの下では、置換マーカー `` {foo} <a href="#id3"><span class="problematic" id="id4">``</span></a>は `` {foo：[^ /] +} <a href="#id5"><span class="problematic" id="id6">``</span></a>と綴ることができます。これを任意の正規表現に変更して、 `` {foo：d +} <a href="#id7"><span class="problematic" id="id8">``</span></a>のような任意の文字列を数字だけにマッチさせることができます。</p>
<p>2つの置換マーカー、例えば `` / {foo} {bar} <a href="#id1"><span class="problematic" id="id2">``</span></a>のようなリテラル文字を使用することはできません。しかし、これは、カスタム正規表現を指定せずに無意味なパターンになり、各マーカーがキャプチャするものを制限します。</p>
<p>セグメントには、セグメント置換マーカーを一致させるための文字が少なくとも1つ含まれている必要があります。たとえば、URL &amp;quot;/ abc /` <a href="#id1"><span class="problematic" id="id2">`</span></a>の場合、次のようになります。</p>
<ul class="simple">
<li>`` / abc / {foo} <a href="#id1"><span class="problematic" id="id2">``</span></a>は一致しません。</li>
<li>`` / {foo} / <a href="#id1"><span class="problematic" id="id2">``</span></a>が一致します。</li>
</ul>
<p>マッチしたパスセグメントを表す値は、URLで引用されず、マッチディック内でUTF-8からUnicodeにデコードされることに注意してください。例えば、次のようなパターンです：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{bar}
</pre></div>
</div>
<p>次のURLと一致する場合：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>http://example.com/foo/La%20Pe%C3%B1a
</pre></div>
</div>
<p>matchdictは以下のようになります（値はURLデコード/ UTF-8デコードされます）。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{&#39;bar&#39;:u&#39;La Pe\xf1a&#39;}
</pre></div>
</div>
<p>パスセグメントのリテラル文字列は、Pyramidに提供される `` PATH_INFO``の*デコードされた*値を表す必要があります。パターンでUTF-8としてエンコードされたリテラルを表すURLエンコードされた値またはバイトを使用したくない。例えば、これよりもむしろ：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/Foo%20Bar/{baz}
</pre></div>
</div>
<p>次のようなものを使いたいでしょう：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/Foo Bar/{baz}
</pre></div>
</div>
<p>リテラルに&amp;quot;高位&amp;quot;文字を含むパターンの場合、URLエンコードまたはUTF-8エンコードの値とは対照的に、Unicode値をパターンとして使用することをお勧めします。たとえば、次のようなバイトテストパターンを使用したくなるかもしれません：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/La Pe\xc3\xb1a/{x}
</pre></div>
</div>
<p>しかし、起動時にエラーが発生するか、正しく一致しません。バイナリのエスケープ文字ではなく、パターンとしてUnicode値を使用したいと思うでしょう。 <a href="#id1"><span class="problematic" id="id2">`</span></a>Pythonのソースファイルのエンコーディングを使って、高次のUnicode値をパターンとして使うことができます&lt;<a class="reference external" href="https://www.python.org/dev/peps/pep-0263/">https://www.python.org/dev/peps/pep-0263/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_ソースにUnicodeパターンの&amp;quot;実&amp;quot;文字を追加します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/La Peña/{x}
</pre></div>
</div>
<p>または、ソースファイルのエンコードを無視して、パターン内の同等のUnicodeエスケープ文字を使用することもできます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/La Pe\xf1a/{x}
</pre></div>
</div>
<p>ダイナミックセグメント名には高次の文字を含めることはできないため、パターンのリテラルにのみ適用されます。</p>
<p>パターンの中に `` * <a href="#id1"><span class="problematic" id="id2">``</span></a>がある場合、それに続く名前は&amp;quot;剰余一致&amp;quot;とみなされます。残りのマッチ*はパターンの最後に来なければなりません。セグメント置換マーカーとは異なり、前にスラッシュを付ける必要はありません。例えば：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{baz}/{bar}*fizzle
</pre></div>
</div>
<p>上記のパターンはこれらのURLと一致し、次のmatchdictsを生成します：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/1/2/           -&gt;
         {&#39;baz&#39;:u&#39;1&#39;, &#39;bar&#39;:u&#39;2&#39;, &#39;fizzle&#39;:()}

foo/abc/def/a/b/c  -&gt;
         {&#39;baz&#39;:u&#39;abc&#39;, &#39;bar&#39;:u&#39;def&#39;, &#39;fizzle&#39;:(u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;)}
</pre></div>
</div>
<p>`` * stararg``の剰余一致がマッチすると、matchdictに入れられた値はパスの残りを表すパスセグメントのタプルに変換されます。これらのパスセグメントは、URLを引用符で囲まずにUTF-8からUnicodeにデコードされます。たとえば、次のパターンの場合：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/*fizzle
</pre></div>
</div>
<p>次のパスに一致する場合：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/foo/La%20Pe%C3%B1a/a/b/c
</pre></div>
</div>
<p>次の対戦を生成します：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{&#39;fizzle&#39;:(u&#39;La Pe\xf1a&#39;, u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;)}
</pre></div>
</div>
<p>デフォルトでは、 `` * stararg``は残りのセクションをセグメントごとに分割したタプルに解析します。マーカーの一致に使用する正規表現を変更すると、URLの残りの部分を取得することもできます。たとえば、次のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/{baz}/{bar}{fizzle:.*}
</pre></div>
</div>
<p>上記のパターンはこれらのURLと一致し、次のmatchdictsを生成します：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foo/1/2/           -&gt; {&#39;baz&#39;:u&#39;1&#39;, &#39;bar&#39;:u&#39;2&#39;, &#39;fizzle&#39;:u&#39;&#39;}
foo/abc/def/a/b/c  -&gt; {&#39;baz&#39;:u&#39;abc&#39;, &#39;bar&#39;:u&#39;def&#39;, &#39;fizzle&#39;: u&#39;a/b/c&#39;}
</pre></div>
</div>
<p>これは、マーカのデフォルトの正規表現は `` [^ /] + <a href="#id1"><span class="problematic" id="id2">``</span></a>であり、 `` {<cite>fizzle：。*}</cite> &amp;#39;が最初の `` / <a href="#id3"><span class="problematic" id="id4">``</span></a>まですべてにマッチし、 <cite>。*</cite> <a href="#id5"><span class="problematic" id="id6">`</span></a>の残りの部分を単一の値にキャプチャします。</p>
</div>
<div class="section" id="route-declaration-ordering">
<span id="index-4"></span><h3>ルート宣言の発注<a class="headerlink" href="#route-declaration-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ルート構成宣言は、要求がシステムに入力されたときに特定の順序で評価されます。その結果、ルート設定宣言の順序は非常に重要です。ルート宣言が評価される順序は、起動時にアプリケーションに追加される順序です。 （これは、app： <cite>Pyramid`が提供する、term：</cite> traversal`という、パターンの順序付けに依存しないコードにURLをマッピングする別の方法とは異なります）。</p>
<p>：mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.add_route`メソッドで追加されたルートの場合、ルートが評価される順序は、それらがコンフィグレーションに必須で追加される順序です。</p>
<p>たとえば、次のパターンのルート設定文を次の順序で追加することができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>members/{def}
members/abc
</pre></div>
</div>
<p>このような構成では、 `` members / abc``パターンは決して*マッチしません。これは、一致順序が常に `` members / {def} <a href="#id1"><span class="problematic" id="id2">``</span></a>と最初に一致するためです。 `` members / abc``によるルート設定は決して評価されません。</p>
</div>
<div class="section" id="route-configuration-arguments">
<span id="index-5"></span><h3>ルート設定引数<a class="headerlink" href="#route-configuration-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ルート設定 `` add_route``文は、多数の引数を指定するかもしれません。それらはAPIドキュメントの一部として：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.config.Configurator.add_route`で文書化されています。</p>
<p>これらの引数の多くは、term： <cite>ルート述語`の引数です。ルート述部の引数は、ルートマッチングプロセス中に関連するルートが一致とみなされるためには、要求の一部の側面が真でなければならないことを指定します。ルート述語引数の例は、 `</cite> pattern``、 `` xhr``、 `` request_method``です。</p>
<p>他の引数は `` name``と `` factory``です。これらの引数は、述部も構成情報も表示しません。</p>
</div>
</div>
<div class="section" id="route-matching">
<span id="index-6"></span><h2>ルートマッチング<a class="headerlink" href="#route-matching" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ルート設定の主な目的は、要求中に提供されたWSGI環境に存在する `` PATH_INFO``をURLパスパターンと照合する（または一致させない）ことです。 `` PATH_INFO``は要求されたURLのパス部分を表します。</p>
<p>方法：アプリ： <cite>ピラミッド`これは非常に簡単です。リクエストがシステムに入ると、システムに存在する各ルート設定宣言に対して、：app： `Pyramid`はリクエストの</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>PATH_INFO``を宣言されたパターンと照合します。このチェックはルートが：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>pyramid.config.Configurator.add_route`で宣言された順序で行われます。</p>
<p>ルート設定が宣言されると、それは：term： <cite>ルート述語`引数を含むかもしれません。ルート宣言に関連付けられたすべてのルート述語は、チェック中に特定の要求に使用されるルート構成に対して &amp;quot;True&amp;quot;でなければなりません。ルートコンフィグレーションに与えられた：term： `ルート述語`引数の中の述語が、チェックの間に `</cite> False``を返した場合、そのルートはスキップされ、順序付けられたルートセットを通ってルートマッチングが続けられます。</p>
<p>いずれかのルートが一致すると、ルートマッチングプロセスが停止し、：term： <cite>view lookup`サブシステムが引き継ぎ、一致したルートで呼び出し可能な最も合理的なビューを見つけます。ほとんどの場合、一致するビューは1つだけです（一致したルートと一致する `</cite> route_name``引数で設定されたビュー）。実際のアプリケーションで経路とビューがどのように関連付けられているかをよりよく理解するためには、：ref： <cite>displaying_matching_views`で説明されているように</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>pviews``コマンドを使用できます。</p>
<p>すべてのルートパターンが使い果たされた後にルートが一致しない場合、：app： <cite>Pyramid`は：term：</cite> traversal`に戻ります：term： <cite>resource location`と：term：</cite> view lookup`。</p>
<div class="section" id="the-matchdict">
<span id="matchdict"></span><span id="index-7"></span><h3>マッチディック<a class="headerlink" href="#the-matchdict" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>特定の経路構成に関連するURLパターンが要求によって照合されると、：term： <cite>request`オブジェクトの属性として</cite> <cite>matchdict``という辞書が追加されます。したがって、 `</cite> request.matchdict``は、 `` pattern``要素の置換パターンと一致する値を含みます。 matchdictのキーは文字列です。値はUnicodeオブジェクトになります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ルートURLパターンが一致しない場合、要求に添付された `` matchdict``オブジェクトは `` None``になります。</p>
</div>
</div>
<div class="section" id="the-matched-route">
<span id="matched-route"></span><span id="index-8"></span><h3>マッチしたルート<a class="headerlink" href="#the-matched-route" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>特定のルート構成に関連付けられたURLパターンがリクエストによって照合されると、 `` matched_route``という名前のオブジェクトが：term： <cite>request`オブジェクトの属性として追加されます。したがって、 `</cite> request.matched_route``はリクエストにマッチした：class： <cite>〜pyramid.interfaces.IRoute`インターフェースを実装するオブジェクトになります。ルートオブジェクトの最も有用な属性は `</cite> name``です。これはマッチしたルートの名前です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ルートURLパターンが一致しない場合、要求に添付された `` matched_route``オブジェクトは `` None``になります。</p>
</div>
</div>
</div>
<div class="section" id="routing-examples">
<h2>ルーティングの例<a class="headerlink" href="#routing-examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ルート設定ステートメントが一般的にどのように宣言されるのか、リクエスト内に存在する情報と一致する場合どうなるかの例を見てみましょう。</p>
<div class="section" id="example-1">
<span id="urldispatch-example1"></span><h3>例1<a class="headerlink" href="#example-1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>直接*へのルートマッチを設定する最も簡単なルート宣言は、呼び出し可能な特定のビューを呼び出します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;idea&#39;</span><span class="p">,</span> <span class="s1">&#39;site/{id}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>`` view``属性を持つルート設定がシステムに追加され、入ってくるリクエストがルート設定の*パターン*と一致すると、：term： <cite>view callable`の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>view``属性としてルート設定が呼び出されます。</p>
<p>`` &#64; view_config``は `` config.add_view``を呼び出すのと同じことを思い出してください。 `` config.scan（） <a href="#id1"><span class="problematic" id="id2">``</span></a>の呼び出しは以下に示す `` mypackage.views``をインポートし、 `` config.add_view``を実行します。各ビューは、ルート名を呼び出し可能なビューにマップします。上記の例の場合、リクエストのURLが `` / site / {id} <a href="#id3"><span class="problematic" id="id4">``</span></a>にマッチすると、Pythonの点線のパス名 `` mypackage.views.site_view``で呼び出せるビューがリクエストと共に呼び出されます。つまり、呼び出し可能なビューをルートパターンに直接関連付けました。</p>
<p>リクエスト中に `` / site / {id} <a href="#id1"><span class="problematic" id="id2">``</span></a>のルートパターンが一致すると、callableの `` site_view``ビューがそのリクエストを唯一の引数として呼び出されます。このルートが一致すると、 `` matchdict``が生成され、 `` request.matchdict``としてリクエストに添付されます。一致する特定のURLが `` / site / 1``の場合、 `` matchdict``は単一のキー、 `` id``を持つ辞書になります。値は文字列 `` &amp;#39;1&amp;#39; <a href="#id3"><span class="problematic" id="id4">``</span></a>、例： `` {&amp;#39;id&amp;#39;： &amp;#39;1&amp;#39;} <a href="#id5"><span class="problematic" id="id6">``</span></a>になります。</p>
<p>上記の `` mypackage.views``モジュールは以下のようになります：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;idea&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">site_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
<p>ビューはリクエストを介して直接matchdictにアクセスし、ルートパターンの結果として存在するキーに一致する変数にアクセスできます。</p>
<p>view：ref： <cite>views_chapter</cite>、および：ref：` view_config_chapter`を参照してください。</p>
</div>
<div class="section" id="example-2">
<h3>例2<a class="headerlink" href="#example-2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下は、アプリケーションに追加する複雑なルートステートメントの例です。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;idea&#39;</span><span class="p">,</span> <span class="s1">&#39;ideas/{idea}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;users/{user}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;tag&#39;</span><span class="p">,</span> <span class="s1">&#39;tags/{tag}&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>対応する `` mypackage.views``モジュールの例を以下に示します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;idea&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">idea_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="p">[</span><span class="s1">&#39;idea&#39;</span><span class="p">])</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;user&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;The user is {}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;tag&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tag_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;The tag is {}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>上記の設定では、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`が次の形式のURLを扱うことができます：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/ideas/{idea}
/users/{user}
/tags/{tag}
</pre></div>
</div>
<ul class="simple">
<li>URLがパターン `` / ideas / {idea} <a href="#id1"><span class="problematic" id="id2">``</span></a>にマッチすると、ドット付きのPythonパス名 `` mypackage.views.idea_view`で呼び出し可能なビューが呼び出されます。特定のURL `` / ideas / 1``に対して、：term： <cite>request`に生成され添付される</cite> <cite>matchdict``は</cite> <cite>{&amp;#39;idea&amp;#39;： &amp;#39;1&amp;#39;}</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>で構成されます。</li>
<li>URLがパターン `` / users / {user} <a href="#id1"><span class="problematic" id="id2">``</span></a>と一致すると、点線のPythonパス名 `` mypackage.views.user_view``で呼び出されるビューが呼び出されます。特定のURL `` / users / 1``に対して生成され、：term： <cite>request`に添付された</cite> <cite>matchdict``は</cite> <cite>{&amp;#39;user&amp;#39;： &amp;#39;1&amp;#39;}</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>で構成されます。</li>
<li>URLがパターン `` / tags / {tag} <a href="#id1"><span class="problematic" id="id2">``</span></a>にマッチすると、点線のPythonパス名 `` mypackage.views.tag_view`で呼び出されるビューが呼び出されます。特定のURL &amp;quot;/ tags / 1&amp;quot;の場合、：term： <cite>request`に生成され添付される</cite> <cite>matchdict``は</cite> <cite>{&amp;#39;tag&amp;#39;： &amp;#39;1&amp;#39;}</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>で構成されます。</li>
</ul>
<p>この例では、それぞれのルートを：term： <cite>view callable`に直接関連づけました。すべての場合、プロセスによってURLにある情報を詳述する `</cite> matchdict``属性を持つリクエストは、呼び出し可能なビューに渡されます。</p>
</div>
<div class="section" id="example-3">
<h3>例3<a class="headerlink" href="#example-3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>URLディスパッチの結果として見つかるビューに渡される：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>context`リソースオブジェクトは、デフォルトで起動時に設定された：term：<a href="#id3"><span class="problematic" id="id4">`</span></a>ルートファクトリ &amp;#39;によって返されるオブジェクトのインスタンスになります（ ` root_factory`引数をアプリケーションの設定に使用する：term： <a href="#id5"><span class="problematic" id="id6">`</span></a>Configurator &amp;#39;に置き換えます）。</p>
<p>特定のルートの：meth： <cite>〜pyramid.config.Configurator.add_route`メソッドに</cite> <cite>factory``引数を渡すことで、この動作を無効にすることができます。 `</cite> factory``は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>request`を受け取り、ビューが使うコンテキストリソースとなるクラスのインスタンスを返します。</p>
<p>ファクトリでルートを使用する例：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;idea&#39;</span><span class="p">,</span> <span class="s1">&#39;ideas/{idea}&#39;</span><span class="p">,</span> <span class="n">factory</span><span class="o">=</span><span class="s1">&#39;myproject.resources.Idea&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>上記のルートは `` Idea``リソースを：term： <cite>context`として作ります。</cite> <cite>mypackage.resources.Idea``は、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>__init__``でリクエストを受け付けるクラスに解決されると仮定します。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Idea</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
<p>もっと複雑なアプリケーションでは、このルートファクトリは：term： <cite>SQLAlchemy`モデルを表すクラスであるかもしれません。 `</cite> mypackage.views.idea_view``というビューは次のようになります：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;idea&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">idea_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">idea</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">context</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">idea</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>ここで、 `` request.context``は `` Idea``のインスタンスです。実際にリソースオブジェクトがSQLAlchemyモデルである場合、あなたは `` request.context``を介してリソースにアクセスできるので、呼び出し可能なビューでクエリを実行する必要はありません。</p>
<p>ルートファクトリの使用方法の詳細については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>route_factories`を参照してください。</p>
</div>
</div>
<div class="section" id="matching-the-root-url">
<span id="index-9"></span><h2>ルートURLの照合<a class="headerlink" href="#matching-the-root-url" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ルートパターン（&amp;quot;/ &amp;quot;）にマッチさせるためにルートパターンを使用する方法は完全にはっきりしていません。これを行うには、空の文字列をパターンとして、：meth： <cite>〜pyramid.config.Configurator.add_route</cite>：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>あるいは、リテラル文字列 `` / <a href="#id1"><span class="problematic" id="id2">``</span></a>をパターンとして提供してください：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="generating-route-urls">
<span id="index-10"></span><span id="id2"></span><h2>ルートURLの生成<a class="headerlink" href="#generating-route-urls" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ルートパターンに基づいてURLを生成するには、：meth： <cite>pyramid.request.Request.route_url`メソッドを使用します。たとえば、 ``名前 `</cite> &amp;quot;foo &amp;quot;と <a href="#id1"><span class="problematic" id="id2">``</span></a>パターン `` &amp;quot;{a} / {b} / {c} &amp;quot;の経路を設定した場合、これを行うかもしれません。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">route_url</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>これは、少なくとも現在のプロトコルとホスト名が `` http：// example.com``を暗示している場合は、文字列 `` http：// example.com / 1/2 / 3``のようなものを返します。</p>
<p>ルートからURLの* path <a href="#id1"><span class="problematic" id="id2">*</span></a>部分だけを生成するには、：meth： <cite>〜pyramid.request.Request.route_url`の代わりに：meth：</cite> pyramid.request.Request.route_path` APIを使用します。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">route_path</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは完全なURLではなく、 `` / 1/2 / 3``という文字列を返します。</p>
<p>`` route_url``または `` route_path``に渡される置換値は、Unicodeか、UTF-8でエンコードされたバイト列でなければなりません。このルールの例外の1つは存在します。&amp;quot;剰余&amp;quot;の一致値（ `` * stararg``の置換値）を置き換える場合、値はUnicode文字列またはUTF-8文字列を含むタプルです。</p>
<p>`` route_url``と `` route_path``で生成されるURLとパスは、常にURL引用文字列型です（非ASCII文字は含まれません）。したがって、次のようなルートを追加した場合は、</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;la&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;/La Peña/{city}&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>そして、後であなたは `` route_path``や `` route_url``を使ってURLを生成します：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">route_path</span><span class="p">(</span><span class="s1">&#39;la&#39;</span><span class="p">,</span> <span class="n">city</span><span class="o">=</span><span class="sa">u</span><span class="s1">&#39;Québec&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>あなたはUTF-8にコード化されたパスとURL引用符で囲まれたようになります：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/La%20Pe%C3%B1a/Qu%C3%A9bec
</pre></div>
</div>
<p>あなたのルートパターンの `` * stararg``の残りの動的部分がある場合：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;a/b/c/*foo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>そして、後であなたは、* string <a href="#id1"><span class="problematic" id="id2">*</span></a>を置換値として使って、 `` route_path``または `` route_url``を使ってURLを生成します：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">route_path</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="sa">u</span><span class="s1">&#39;Québec/biz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>渡す値は、結果に埋め込まれたスラッシュを除いて、URLで引用されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/a/b/c/Qu%C3%A9bec/biz
</pre></div>
</div>
<p>パス要素で構成されるタプルを渡すことで、同様の結果が得られます。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">route_path</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;Québec&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;biz&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>タプルの各値はURLで引用され、この場合はスラッシュで結合されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/a/b/c/Qu%C3%A9bec/biz
</pre></div>
</div>
</div>
<div class="section" id="static-routes">
<span id="static-route-narr"></span><span id="index-11"></span><h2>静的ルート<a class="headerlink" href="#static-routes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ルートは `` static``キーワード引数で追加することができます。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;page&#39;</span><span class="p">,</span> <span class="s1">&#39;/page/{action}&#39;</span><span class="p">,</span> <span class="n">static</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>`` True`` `` static``キーワード引数で追加された経路は、リクエスト時にはマッチングのために決して考慮されません。静的ルートは、URL生成目的にのみ役立ちます。結果として、 `` static``が次のように渡されるとき、meth： <cite>〜pyramid.config.Configurator.add_route`に他の非</cite> <cite>name``引数と非 ``pattern``引数を与えるのは無意味です他の議論のどれも採用されることはないので、「真」となる。このルールの例外は、 `</cite> pregenerator``引数の使用です。これは `` static``が `` True``のとき無視されません。</p>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>外部ルート&lt;external_route_narr&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>は暗黙的に静的です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>：meth： <cite>〜pyramid.config.Configurator.add_route`の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>static``引数です。</p>
</div>
</div>
<div class="section" id="external-routes">
<span id="external-route-narr"></span><h2>外部ルート<a class="headerlink" href="#external-routes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.5 で追加.</span></p>
</div>
<p>有効なURLであるルートパターンは外部ルートとして扱われます。同様に：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>静的ルート&lt;static_route_narr&gt;それらはURL生成の目的のみに有用であり、要求時に照合することは決して考えられません。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;youtube&#39;</span><span class="p">,</span> <span class="s1">&#39;https://youtube.com/watch/{video_id}&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">route_url</span><span class="p">(</span><span class="s1">&#39;youtube&#39;</span><span class="p">,</span> <span class="n">video_id</span><span class="o">=</span><span class="s1">&#39;oHg5SJYRHA0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;https://youtube.com/watch/oHg5SJYRHA0&quot;</span>
</pre></div>
</td></tr></table></div>
<p>ほとんどのパターンの置き換えと：meth： <cite>pyramid.request.Request.route_url`への呼び出しは期待通りに動作します。しかし、外部パターンに対して：meth： `pyramid.request.Request.route_path`を呼び出すと例外が発生し、</cite> _app_url``を：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.route_url`に渡してURLを生成します外部パターンを持つルートも例外を発生させます。</p>
</div>
<div class="section" id="redirecting-to-slash-appended-routes">
<span id="index-12"></span><span id="id3"></span><h2>スラッシュが追加されたルートにリダイレクトする<a class="headerlink" href="#redirecting-to-slash-appended-routes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Djangoの `` APPEND_SLASH = True``のような振る舞いについては、：meth： <cite>pyramid.config.Configurator.add_notfound_view`または：class：</cite> pyramidに相当する `` append_slash``引数に `` append_slash``引数を使用してください。 view.notfound_view_config`デコレータ。</p>
<p>`` append_slash = True``を追加すると、URLに末尾のスラッシュがない場合に自動的にリクエストをリダイレクトすることができますが、適切なルートに一致するリクエストが必要です。設定時に、アプリケーション内の他の少なくとも1つのルートとともに、このビューは `` PATH_INFO``の値がスラッシュで終わっていない場合に呼び出され、 `` PATH_INFO`` * plus * aスラッシュは任意のルートのパターンに一致します。この場合、スラッシュが付加された `` PATH_INFO``にHTTPリダイレクトを行います。さらに、class： <cite>pyramid.interfaces.IResponse`を実装しているものを渡すこともできます。これはデフォルトのクラス（：class：</cite> pyramid.httpexceptions.HTTPFound`）の代わりに使用されます。</p>
<p>例を使ってみましょう。アプリケーションに次のルートが設定されている場合：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.httpexceptions</span> <span class="kn">import</span> <span class="n">HTTPNotFound</span>

<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HTTPNotFound</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">no_slash</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;No slash&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_slash</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Has slash&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;noslash&#39;</span><span class="p">,</span> <span class="s1">&#39;no_slash&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;hasslash&#39;</span><span class="p">,</span> <span class="s1">&#39;has_slash/&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">no_slash</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;noslash&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">has_slash</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;hasslash&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_notfound_view</span><span class="p">(</span><span class="n">notfound</span><span class="p">,</span> <span class="n">append_slash</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>要求が `` / no_slash``の `` PATH_INFO``値を持つアプリケーションに入ると、最初の経路が一致し、ブラウザに&amp;quot;スラッシュなし&amp;quot;と表示されます。しかし、要求が `` / no_slash / <a href="#id1"><span class="problematic" id="id2">``</span></a>の値を持つアプリケーションを入力すると、* no <a href="#id3"><span class="problematic" id="id4">*</span></a>のルートが一致し、スラッシュを追加していないビューはスラッシュが付加された一致するルートを見つけられません。その結果、 `` notfound``ビューが呼び出され、&amp;quot;Not found &amp;quot;ボディが返されます。</p>
<p>リクエストが `` / has_slash / <a href="#id1"><span class="problematic" id="id2">``</span></a>の `` PATH_INFO``値を持つアプリケーションに入ると、2番目のルートが一致します。要求が `` / has_slash``の `` PATH_INFO``値を持つアプリケーションに入ると、ルート*はスラッシュ - 追加：term： <cite>Not Found View`によって見つけられます。 `</cite> / has_slash / <a href="#id3"><span class="problematic" id="id4">``</span></a>へのHTTPリダイレクトがユーザのブラウザに返されます。その結果、 `` notfound``ビューは実際には決して呼び出されません。</p>
<p>次のアプリケーションは、：class： <cite>pyramid.view.notfound_view_config`と：class：</cite> pyramid.view.view_config`デコレータと、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>scan`を使って、まったく同じ仕事をします：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.httpexceptions</span> <span class="kn">import</span> <span class="n">HTTPNotFound</span>
<span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">notfound_view_config</span><span class="p">,</span> <span class="n">view_config</span>

<span class="nd">@notfound_view_config</span><span class="p">(</span><span class="n">append_slash</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HTTPNotFound</span><span class="p">()</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;noslash&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_slash</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;No slash&#39;</span><span class="p">)</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;hasslash&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">has_slash</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Has slash&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;noslash&#39;</span><span class="p">,</span> <span class="s1">&#39;no_slash&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;hasslash&#39;</span><span class="p">,</span> <span class="s1">&#39;has_slash/&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">あなたは `` POST``要求をリダイレクトするためにこのメカニズムに依存してはいけません。 slash-appending：term： <cite>Not Found View`のリダイレクトは、</cite> <cite>POST``要求を</cite> <cite>GET``に変換し、元の要求の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>POST``データを失います。</p>
</div>
<p>ビューや：term： <cite>Not Found View`の設定方法のより一般的な説明については：ref：</cite> view_module`と：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>changing_the_notfound_view`を参照してください。</p>
</div>
<div class="section" id="debugging-route-matching">
<span id="debug-routematch-section"></span><span id="index-13"></span><h2>ルートマッチングのデバッグ<a class="headerlink" href="#debugging-route-matching" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>あなたのアプリケーションに入ってくるリクエストが期待どおりにあなたのルートに合っていないときに、ボンネットの下で覗くことができると便利です。ルートマッチングをデバッグするには、 `` PYRAMID_DEBUG_ROUTEMATCH``環境変数か `` pyramid.debug_routematch``設定ファイルの設定（ `` true``にセット）を使います。 ：app： <cite>Pyramid`アプリケーションへの特定の要求に対するルートマッチングの決定の詳細は、あなたがアプリケーションを起動したコンソールの</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>stderr``に出力されます。例えば：</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ PYRAMID_DEBUG_ROUTEMATCH=true $VENV/bin/pserve development.ini
Starting server in PID 13586.
serving on 0.0.0.0:6543 view at http://127.0.0.1:6543
2010-12-16 14:45:19,956 no route matched for url \
                                    http://localhost:6543/wontmatch
2010-12-16 14:45:20,010 no route matched for url \
                            http://localhost:6543/favicon.ico
2010-12-16 14:41:52,084 route matched for url \
                            http://localhost:6543/static/logo.png; \
                            route_name: &#39;static/&#39;, ....
</pre></div>
</td></tr></table></div>
<p>これらの値の設定方法と場所の詳細については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>environment_chapter`を参照してください。</p>
<p>`` proutes``コマンドを使って、アプリケーションで設定されたすべてのルートの表示を見ることもできます。詳細は、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>displaying_application_routes`を参照してください。</p>
</div>
<div class="section" id="using-a-route-prefix-to-compose-applications">
<span id="route-prefix"></span><h2>ルートプレフィックスを使用したアプリケーションの作成<a class="headerlink" href="#using-a-route-prefix-to-compose-applications" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.config.Configurator.include`メソッドを使うと、設定文を別々のファイルからインクルードすることができます。このメソッドについては、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>building_an_extensible_app`を参照してください。 ：meth： <a href="#id5"><span class="problematic" id="id6">`</span></a>pyramid.config.Configurator.include`を使うと、小さくて潜在的に再利用可能なコンポーネントからアプリケーションを構築することができます。</p>
<p>：meth： <cite>pyramid.config.Configurator.include`メソッドは、</cite> <cite>route_prefix``という名前の引数を受け取ります。これは、URLディスパッチベースのアプリケーションの作成者にとって有用なものです。 `</cite> route_prefix``がインクルードメソッドに与えられている場合は、文字列でなければなりません。この文字列は、* included <a href="#id1"><span class="problematic" id="id2">*</span></a>設定で追加されたすべてのルートパターンの先頭に付加されるルートプレフィックスを表します。インクルードされた呼び出し可能ファイル内の：meth： <cite>pyramid.config.Configurator.add_route`への呼び出しには、</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>route_prefix``の値の接頭辞が付きます。これは、同じルート名を維持しながら、インクルードされた呼び出し可能な作成者とは異なる場所に一連のルートをマウントするのに役立ちます。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="k">def</span> <span class="nf">users_include</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;show_users&#39;</span><span class="p">,</span> <span class="s1">&#39;/show&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">global_config</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">users_include</span><span class="p">,</span> <span class="n">route_prefix</span><span class="o">=</span><span class="s1">&#39;/users&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の設定では、 `` show_users``ルートは `` / show``の代わりに `` / users / show``の効果的なルートパターンを持ちます。これは `` route_prefix``引数がパターンの前に付加されるからです。 URLパスが `` / users / show``である場合にのみルートが一致し、 `` show_users``：meth： <cite>pyramid.request.Request.route_url`関数がルート名</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>show_users``で呼び出されると、ルートは一致しますその同じパスを持つURLを生成します。</p>
<p>ルートプレフィックスは再帰的なものなので、インクルード自体を介して実行された呼び出し可能なものがターンアラウンドし、別の呼び出し可能コードを含む場合、第2レベルのルートプレフィックスには最初のものが付加されます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="k">def</span> <span class="nf">timing_include</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;show_times&#39;</span><span class="p">,</span> <span class="s1">&#39;/times&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">users_include</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;show_users&#39;</span><span class="p">,</span> <span class="s1">&#39;/show&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">timing_include</span><span class="p">,</span> <span class="n">route_prefix</span><span class="o">=</span><span class="s1">&#39;/timing&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">global_config</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">users_include</span><span class="p">,</span> <span class="n">route_prefix</span><span class="o">=</span><span class="s1">&#39;/users&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の設定では、 `` show_users``ルートは `` / users / show``という有効なルートパターンを持っています。しかし、 `` show_times``ルートは `` / users / timing / times``の有効なパターンを持ちます。</p>
<p>ルート接頭辞は、与えられたピラミッド構成における経路*名前*のセットが完全に一意でなければならないという要件に影響を与えません。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.config.Configurator.include`を使用して、多くの小さなサブアプリケーションからURLディスパッチアプリケーションを作成する場合は、ルート名にドット付きの名前を使用することをお勧めします。そうすれば、他のパッケージと競合する可能性は低くなります将来追加される予定です。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="k">def</span> <span class="nf">timing_include</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;timing.show_times&#39;</span><span class="p">,</span> <span class="s1">&#39;/times&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">users_include</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;users.show_users&#39;</span><span class="p">,</span> <span class="s1">&#39;/show&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">timing_include</span><span class="p">,</span> <span class="n">route_prefix</span><span class="o">=</span><span class="s1">&#39;/timing&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">global_config</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">users_include</span><span class="p">,</span> <span class="n">route_prefix</span><span class="o">=</span><span class="s1">&#39;/users&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="custom-route-predicates">
<span id="index-14"></span><span id="id4"></span><h2>カスタムルート条件<a class="headerlink" href="#custom-route-predicates" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：meth： <cite>〜pyramid.config.Configurator.add_route`の</cite> <cite>custom_predicates``引数に与えられた述語呼び出し可能ファイルのそれぞれは、2つの引数を受け入れる呼び出し可能でなければなりません。カスタム述語に渡される最初の引数は、通常は `</cite> info``という名前の辞書です。 2番目の引数は、現在の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>request`オブジェクトです。</p>
<p>`` info``辞書には、 `` match``と `` route``を含むいくつかの値が含まれています。 `` match``は、ルートでURLにマッチした引数を表す辞書です。 `` route``は、一致したルートを表すオブジェクトです（このようなルートオブジェクトのAPIについては、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.interfaces.IRoute`を参照してください）。</p>
<p>`` info [&amp;#39;match&amp;#39;] <a href="#id1"><span class="problematic" id="id2">``</span></a>は述語が経路マッチにアクセスする必要があるときに便利です。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any_of</span><span class="p">(</span><span class="n">segment_name</span><span class="p">,</span> <span class="o">*</span><span class="n">allowed</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;match&#39;</span><span class="p">][</span><span class="n">segment_name</span><span class="p">]</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">predicate</span>

<span class="n">num_one_two_or_three</span> <span class="o">=</span> <span class="n">any_of</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;route_to_num&#39;</span><span class="p">,</span> <span class="s1">&#39;/{num}&#39;</span><span class="p">,</span>
                 <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">num_one_two_or_three</span><span class="p">,))</span>
</pre></div>
</td></tr></table></div>
<p>上記の `` any_of``関数は、 `` segment_name``という名前の一致値が `` allowed``で表される許容値の集合にあることを保証する述語を生成します。この `` any_of``関数を使って `` num_one_two_or_three``という名前の述語関数を生成します。これは `` num``セグメントが `` one``、 `` two``、 `` <cite>three_``を呼び出し、それをタプルの中で</cite> <cite>custom_predicates``の引数：meth：</cite>〜pyramid.config.Configurator.add_route`に渡すことで、結果をカスタム述語として使用します。</p>
<p>カスタム経路述語は `` match``辞書を変更することもできます*。たとえば、述部は値の型変換を行うことがあります。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">integers</span><span class="p">(</span><span class="o">*</span><span class="n">segment_names</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;match&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">segment_name</span> <span class="ow">in</span> <span class="n">segment_names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">match</span><span class="p">[</span><span class="n">segment_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">segment_name</span><span class="p">])</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">predicate</span>

<span class="n">ymd_to_int</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;ymd&#39;</span><span class="p">,</span> <span class="s1">&#39;/{year}/{month}/{day}&#39;</span><span class="p">,</span>
                 <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">ymd_to_int</span><span class="p">,))</span>
</pre></div>
</td></tr></table></div>
<p>変換述語は依然として述語なので、 `` True``または `` False``を返す必要があることに注意してください。上記のような*変換のみを行う述語は、無条件に `` True``を返すべきです。</p>
<p>トライ/不確実性を避けるために、ルートパターンにはそのマーカーの要件を指定する正規表現を含めることができます。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">integers</span><span class="p">(</span><span class="o">*</span><span class="n">segment_names</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;match&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">segment_name</span> <span class="ow">in</span> <span class="n">segment_names</span><span class="p">:</span>
            <span class="n">match</span><span class="p">[</span><span class="n">segment_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">segment_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">predicate</span>

<span class="n">ymd_to_int</span> <span class="o">=</span> <span class="n">integers</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;ymd&#39;</span><span class="p">,</span> <span class="s1">&#39;/{year:\d+}/{month:\d+}/{day:\d+}&#39;</span><span class="p">,</span>
                 <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">ymd_to_int</span><span class="p">,))</span>
</pre></div>
</td></tr></table></div>
<p>これらのマーカーが `` d + <a href="#id1"><span class="problematic" id="id2">``</span></a>にマッチしない限り、ルートがまったくマッチしないため、try / exceptはもう必要ありません。 `` int``型変換の有効数字にする必要があります。</p>
<p>ルートに付けられた各述語に `` info``の中で渡される `` match``辞書は、同じ辞書になります。したがって、 `` match``を変更するカスタム述部を登録するとき、述部を登録するコードは通常、<em>。*カスタム述部である述部をカスタム述部リストに配置する必要があります。さもなければ、 `` match``を実行する述語に続いて発生するカスタム述語は、</em> modified <a href="#id1"><span class="problematic" id="id2">*</span></a>一致辞書を受け取ります。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">1つの述部が別の述部の副作用に依存する変換パイプラインを構築するために、カスタム述部の順序付けに依存することは賢明ではありません。たとえば、値のintへの変換を処理する2つのカスタム述部を登録することはお勧めできません。次に、その整数の一部のカスタム・オブジェクトへの変換を処理する次の述部を登録します。単一のカスタム述語ですべてを行うだけです。</p>
</div>
<p>`` info`` dictの `` route``オブジェクトは、 `` name``と `` pattern``の2つの有用な属性を持つオブジェクトです。 `` name``属性はルート名です。 `` pattern``属性はルートパターンです。一連のルート述語でルートを使用する例を次に示します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">twenty_ten</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;route&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ymd&#39;</span><span class="p">,</span> <span class="s1">&#39;ym&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;match&#39;</span><span class="p">][</span><span class="s1">&#39;year&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2010&#39;</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;/{year}&#39;</span><span class="p">,</span> <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">twenty_ten</span><span class="p">,))</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;ym&#39;</span><span class="p">,</span> <span class="s1">&#39;/{year}/{month}&#39;</span><span class="p">,</span> <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">twenty_ten</span><span class="p">,))</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;ymd&#39;</span><span class="p">,</span> <span class="s1">&#39;/{year}/{month}/{day}&#39;</span><span class="p">,</span>
                 <span class="n">custom_predicates</span><span class="o">=</span><span class="p">(</span><span class="n">twenty_ten</span><span class="p">,))</span>
</pre></div>
</td></tr></table></div>
<p>上記の述語をいくつかのルート構成に追加すると、ルート名が &amp;#39;ymd&amp;#39;、 &amp;#39;ym&amp;#39;、または &amp;#39;y&amp;#39;の場合にのみ、年一致引数が &amp;#39;2010&amp;#39;になります。</p>
<p>`` __text__``属性を設定することで、述語に字幕を付けることもできます。これは `` pviews``コマンド（：ref： <cite>displaying_application_routes`を参照）と</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid_debugtoolbar``を手伝ってくれます。</p>
<p>述語がクラスの場合、標準的な方法で `` __text__``プロパティを追加するだけです。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DummyCustomPredicate1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__text__</span> <span class="o">=</span> <span class="s1">&#39;my custom class predicate&#39;</span>

<span class="k">class</span> <span class="nc">DummyCustomPredicate2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__text__</span> <span class="o">=</span> <span class="s1">&#39;my custom class predicate&#39;</span>
</pre></div>
</td></tr></table></div>
<p>述語がメソッドの場合、メソッド宣言の後にそれを割り当てる必要があります（ <a href="#id1"><span class="problematic" id="id2">`</span></a>PEP 232 &lt;<a class="reference external" href="https://www.python.org/dev/peps/pep-0232/">https://www.python.org/dev/peps/pep-0232/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_）。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">custom_predicate</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="n">custom_predicate</span><span class="o">.</span><span class="n">__text__</span> <span class="o">=</span> <span class="s1">&#39;my custom method predicate&#39;</span>
</pre></div>
</td></tr></table></div>
<p>述語がクラスメソッドである場合、 `` &#64; classmethod``を使っても動作しませんが、classmethodコールでそれをラップすることで簡単に行うことができます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">classmethod_predicate</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="n">classmethod_predicate</span><span class="o">.</span><span class="n">__text__</span> <span class="o">=</span> <span class="s1">&#39;my classmethod predicate&#39;</span>
<span class="n">classmethod_predicate</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">classmethod_predicate</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>同じことが `` staticmethod``では `` classmethod``の代わりに `` staticmethod``を使って動作します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">ルートオブジェクトに関するAPIドキュメントの詳細は、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.interfaces.IRoute`を参照してください。</p>
</div>
</div>
<div class="section" id="route-factories">
<span id="index-15"></span><span id="id5"></span><h2>ルートファクトリー<a class="headerlink" href="#route-factories" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的なアプリケーションでは特に一般的なニーズではありませんが、&amp;quot;route &amp;quot;構成宣言では&amp;quot;factory &amp;quot;と言います。ルートが要求と一致し、そのルートにファクトリが添付されている場合、起動時に：term： <cite>Configurator`に渡される：term：`ルートファクトリ &amp;#39;は無視されます。代わりにルートに関連付けられたファクトリを使用して：term： `ルート`オブジェクトを生成します。このオブジェクトは通常：term： `view lookup`を介して最終的に見つけられるcallableのview：term：</cite> context`リソースとして使用されます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;/abc&#39;</span><span class="p">,</span>
                 <span class="n">factory</span><span class="o">=</span><span class="s1">&#39;myproject.resources.root_factory&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myproject.views.theview&#39;</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>ファクトリは、上記のように、Pythonオブジェクトまたは：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>点線のPython名`（文字列）のいずれかで、そのようなPythonオブジェクトを指します。</p>
<p>このように、各ルートは異なるファクトリを使用することができ、異なる：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>context`リソースオブジェクトをそれぞれの特定のルートに関連するビューに供給することができます。</p>
<p>ファクトリは、要求を受け取り、任意のPythonオブジェクトを返す呼び出し可能なものでなければなりません。たとえば、以下のクラスはファクトリとして使用できます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
<p>ルートファクトリは、実際には：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>the_resource_tree`に記述されている：term：<a href="#id3"><span class="problematic" id="id4">`</span></a>ルートファクトリ &amp;#39;と概念的には同じです。</p>
<p>宣言的なcontext sensitive security checkを提供するために、：app： <cite>Pyramid</cite>：term：<cite>認可ポリシー `を使用しようとしているとき、それぞれのルートに対して異なるリソースファクトリを提供することは便利です。各リソースは、：ref： `using_security_with_urldispatch`に記載されているように、別名：term：</cite> ACL`を保持することができます。これは：ref： <cite>hybrid_chapter`の中で文書化されているようにURLディスパッチを：term：</cite> traversal`と組み合わせたい場合にも便利です。</p>
</div>
<div class="section" id="using-pyramid-security-with-url-dispatch">
<span id="using-security-with-urldispatch"></span><span id="index-16"></span><h2>使用：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`セキュリティとURLディスパッチ<a class="headerlink" href="#using-pyramid-security-with-url-dispatch" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：app： <cite>Pyramid`はアプリケーションコードの呼び出しを許可する前に：term：`認可ポリシー `を調べる独自のセキュリティフレームワークを提供します。このフレームワークは、リソースオブジェクトの `</cite> __acl__``属性として格納されているアクセス制御リストの観点から動作します。一般的なことは、宣言的なセキュリティ目的のためにリソースオブジェクトに `` __acl__``を動的に付加することです。ファクトリを指す `` factory``引数は、作成時にカスタム `` __acl__``をオブジェクトに付加して使うことができます。</p>
<p>そのような「工場」は次のように見えるかもしれません：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
       <span class="n">matchdict</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">matchdict</span>
       <span class="n">article</span> <span class="o">=</span> <span class="n">matchdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;article&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
       <span class="k">if</span> <span class="n">article</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">__acl__</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">Allow</span><span class="p">,</span> <span class="s1">&#39;editor&#39;</span><span class="p">,</span> <span class="s1">&#39;view&#39;</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</td></tr></table></div>
<p>： <cite>archives / {article}</cite> <cite>が一致し、アーティクル番号が</cite> <cite>1``の場合、：app：</cite> Pyramid`はACLを持つ `` Article``：term： <cite>context`リソースを生成します``編集 ``プリンシパルの `</cite> view``パーミッションを許可します。明らかに、 `` article``引数が特定の文字列にマッチするかどうかを調べるために、ルートの一致を調べるよりも一般的なことができます。サンプルの `` Article``工場クラスはあまり野心的ではありません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">詳細は：ref： <cite>security_chapter`を参照してください：app：</cite> Pyramid`セキュリティとACL。</p>
</div>
</div>
<div class="section" id="route-view-callable-registration-and-lookup-details">
<span id="index-17"></span><h2>ルートビュー呼び出し可能な登録と参照の詳細<a class="headerlink" href="#route-view-callable-registration-and-lookup-details" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リクエストがルートのパターンに一致するシステムに入ると、通常の結果は簡単です。ルートに関連付けられたコール可能なビューが、呼び出しの原因となったリクエストとともに呼び出されます。</p>
<p>ほとんどの場合、これ以上理解する必要はありません。どのように動作するかは実装の詳細です。しかし、完全性のために、このセクションでどのように*動作するかを説明します。あなたが無関心なら、あなたはそれをスキップすることができます。</p>
<p>ビューがルート設定に関連付けられている場合、：app： <cite>Pyramid`はa：term：</cite> view configuration`が登録されていることを確認します。これはリクエスト中にルートパターンが一致したときに常に見つけられます。そうするには：</p>
<ul class="simple">
<li>特別なルート特有の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`は各ルート設定宣言のために起動時に作成されます。</li>
<li>`` add_view``文が `` route name``属性を記述すると、起動時に：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view configuration`が登録されます。このビュー構成では、経路指定インタフェースを：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>request`型として使用します。</li>
<li>実行時に、要求によって任意のルートが一致すると、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>request`オブジェクトがルート固有のインタフェースで修飾されます。</li>
<li>要求が経路特有のインタフェースで装飾されているという事実は、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view lookup`機構が、経路構成に一致する要求を処理するために経路構成によってそのインタフェースを使用して呼び出された呼び出し可能なビューを常に使用するようにします。</li>
</ul>
<p>上の説明からわかるように、技術的には、URLディスパッチはURLパターンを直接ビュー呼び出し可能にマップしません。代わりに、URLディスパッチは：term： <cite>resource location`メカニズムです。 A：app： `Pyramid</cite>：term：` resource location`サブシステム（：term： <cite>URL dispatch`または：term：</cite> traversal`）は：term： <cite>context`であるa：term：</cite> resource`オブジェクトを検索します。 <cite>の：term：`要求 &amp;#39; ：term： `context`が決定されると、term：</cite> view lookup`という独立したサブシステムは、コンテキストと要求で利用可能な情報に基づいて：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view callable`を見つけて呼び出します。 URLディスパッチが使用されると、：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid &amp;#39;によって提供されるリソースロケーションとビュールックアップサブシステムはまだ使用されていますが、開発者がどちらかを詳細に理解する必要はありません。</p>
<p>：term： <cite>URL dispatch`を使用してルートが一致しない場合、：app：</cite> Pyramid`はterm： <cite>traversal`に落ちて：term：</cite> request`を処理します。</p>
</div>
<div class="section" id="references">
<h2>参考文献<a class="headerlink" href="#references" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ref： <cite>bfg_sql_wiki_tutorial`に：app：</cite> Pyramid`アプリケーションを作成するためのterm： <a href="#id1"><span class="problematic" id="id2">`</span></a>URL dispatch`の使い方を示すチュートリアルです。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">(機械翻訳) URLディスパッチ</a><ul>
<li><a class="reference internal" href="#high-level-operational-overview">高度な運用概要</a></li>
<li><a class="reference internal" href="#route-configuration">ルート設定</a><ul>
<li><a class="reference internal" href="#configuring-a-route-to-match-a-view">ビューと一致するようにルートを設定する</a></li>
<li><a class="reference internal" href="#route-pattern-syntax">ルートパターンの構文</a></li>
<li><a class="reference internal" href="#route-declaration-ordering">ルート宣言の発注</a></li>
<li><a class="reference internal" href="#route-configuration-arguments">ルート設定引数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#route-matching">ルートマッチング</a><ul>
<li><a class="reference internal" href="#the-matchdict">マッチディック</a></li>
<li><a class="reference internal" href="#the-matched-route">マッチしたルート</a></li>
</ul>
</li>
<li><a class="reference internal" href="#routing-examples">ルーティングの例</a><ul>
<li><a class="reference internal" href="#example-1">例1</a></li>
<li><a class="reference internal" href="#example-2">例2</a></li>
<li><a class="reference internal" href="#example-3">例3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#matching-the-root-url">ルートURLの照合</a></li>
<li><a class="reference internal" href="#generating-route-urls">ルートURLの生成</a></li>
<li><a class="reference internal" href="#static-routes">静的ルート</a></li>
<li><a class="reference internal" href="#external-routes">外部ルート</a></li>
<li><a class="reference internal" href="#redirecting-to-slash-appended-routes">スラッシュが追加されたルートにリダイレクトする</a></li>
<li><a class="reference internal" href="#debugging-route-matching">ルートマッチングのデバッグ</a></li>
<li><a class="reference internal" href="#using-a-route-prefix-to-compose-applications">ルートプレフィックスを使用したアプリケーションの作成</a></li>
<li><a class="reference internal" href="#custom-route-predicates">カスタムルート条件</a></li>
<li><a class="reference internal" href="#route-factories">ルートファクトリー</a></li>
<li><a class="reference internal" href="#using-pyramid-security-with-url-dispatch">使用：app： `Pyramid`セキュリティとURLディスパッチ</a></li>
<li><a class="reference internal" href="#route-view-callable-registration-and-lookup-details">ルートビュー呼び出し可能な登録と参照の詳細</a></li>
<li><a class="reference internal" href="#references">参考文献</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="router.html"
                        title="前の章へ">リクエスト処理(Request Processing)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="views.html"
                        title="次の章へ">ビュー(Views)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/narr/urldispatch.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="views.html" title="ビュー(Views)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="router.html" title="リクエスト処理(Request Processing)"
             >前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 11月 13, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 で生成しました。
    </div>
  </body>
</html>
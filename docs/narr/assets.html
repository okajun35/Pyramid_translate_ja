
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Static Assets &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="Request and Response Objects" href="webob.html" />
    <link rel="prev" title="View Configuration" href="viewconfig.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="webob.html" title="Request and Response Objects"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="viewconfig.html" title="View Configuration"
             accesskey="P">前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="static-assets">
<span id="assets-chapter"></span><span id="index-0"></span><h1>Static Assets<a class="headerlink" href="#static-assets" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>An <a class="reference internal" href="../glossary.html#term-asset"><span class="xref std std-term">asset</span></a> is any file contained within a Python <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">package</span></a> which is
<em>not</em> a Python source code file.  For example, each of the following is an
asset:</p>
<ul class="simple">
<li>a GIF image file contained within a Python package or contained within any
subdirectory of a Python package.</li>
<li>a CSS file contained within a Python package or contained within any
subdirectory of a Python package.</li>
<li>a JavaScript source file contained within a Python package or contained
within any subdirectory of a Python package.</li>
<li>A directory within a package that does not have an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> in it (if
it possessed an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> it would <em>be</em> a package).</li>
<li>a <a class="reference internal" href="../glossary.html#term-chameleon"><span class="xref std std-term">Chameleon</span></a> or <a class="reference internal" href="../glossary.html#term-mako"><span class="xref std std-term">Mako</span></a> template file contained within a Python
package.</li>
</ul>
<p>The use of assets is quite common in most web development projects.  For
example, when you create a <span>Pyramid</span> application using one of the
available <a class="reference internal" href="../glossary.html#term-cookiecutter"><span class="xref std std-term">cookiecutter</span></a>s, as described in <a class="reference internal" href="project.html#creating-a-project"><span class="std std-ref">Creating the Project</span></a>, the directory
representing the application contains a Python <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">package</span></a>. Within that
Python package, there are directories full of files which are static assets.
For example, there's a <code class="docutils literal notranslate"><span class="pre">static</span></code> directory which contains <code class="docutils literal notranslate"><span class="pre">.css</span></code>, <code class="docutils literal notranslate"><span class="pre">.js</span></code>,
and <code class="docutils literal notranslate"><span class="pre">.gif</span></code> files.  These asset files are delivered when a user visits an
application URL.</p>
<div class="section" id="understanding-asset-specifications">
<span id="asset-specifications"></span><span id="index-1"></span><h2>Understanding Asset Specifications<a class="headerlink" href="#understanding-asset-specifications" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Let's imagine you've created a <span>Pyramid</span> application that uses a
<a class="reference internal" href="../glossary.html#term-chameleon"><span class="xref std std-term">Chameleon</span></a> ZPT template via the
<a class="reference internal" href="../api/renderers.html#pyramid.renderers.render_to_response" title="pyramid.renderers.render_to_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyramid.renderers.render_to_response()</span></code></a> API.  For example, the application
might address the asset using the <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a>
<code class="docutils literal notranslate"><span class="pre">myapp:templates/some_template.pt</span></code> using that API within a <code class="docutils literal notranslate"><span class="pre">views.py</span></code> file
inside a <code class="docutils literal notranslate"><span class="pre">myapp</span></code> package:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.renderers</span> <span class="kn">import</span> <span class="n">render_to_response</span>
<span class="n">render_to_response</span><span class="p">(</span><span class="s1">&#39;myapp:templates/some_template.pt&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>&quot;Under the hood&quot;, when this API is called, <span>Pyramid</span> attempts to make
sense out of the string <code class="docutils literal notranslate"><span class="pre">myapp:templates/some_template.pt</span></code> provided by the
developer.  This string is an <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a>.  It is composed of
two parts:</p>
<ul class="simple">
<li>The <em>package name</em> (<code class="docutils literal notranslate"><span class="pre">myapp</span></code>)</li>
<li>The <em>asset name</em> (<code class="docutils literal notranslate"><span class="pre">templates/some_template.pt</span></code>), relative to the package
directory.</li>
</ul>
<p>The two parts are separated by a colon <code class="docutils literal notranslate"><span class="pre">:</span></code> character.</p>
<p><span>Pyramid</span> uses the Python <a class="reference internal" href="../glossary.html#term-pkg-resources"><span class="xref std std-term">pkg_resources</span></a> API to resolve the package
name and asset name to an absolute (operating system-specific) file name.  It
eventually passes this resolved absolute filesystem path to the Chameleon
templating engine, which then uses it to load, parse, and execute the template
file.</p>
<p>There is a second form of asset specification: a <em>relative</em> asset
specification.  Instead of using an &quot;absolute&quot; asset specification which
includes the package name, in certain circumstances you can omit the package
name from the specification.  For example, you might be able to use
<code class="docutils literal notranslate"><span class="pre">templates/mytemplate.pt</span></code> instead of <code class="docutils literal notranslate"><span class="pre">myapp:templates/some_template.pt</span></code>.
Such asset specifications are usually relative to a &quot;current package&quot;.  The
&quot;current package&quot; is usually the package which contains the code that <em>uses</em>
the asset specification.  <span>Pyramid</span> APIs which accept relative asset
specifications typically describe to what the asset is relative in their
individual documentation.</p>
</div>
<div class="section" id="serving-static-assets">
<span id="static-assets-section"></span><span id="index-2"></span><h2>Serving Static Assets<a class="headerlink" href="#serving-static-assets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><span>Pyramid</span> makes it possible to serve up static asset files from a
directory on a filesystem to an application user's browser.  Use the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_static_view()</span></code></a> to instruct <span>Pyramid</span>
to serve static assets, such as JavaScript and CSS files. This mechanism makes
a directory of static files available at a name relative to the application
root URL, e.g., <code class="docutils literal notranslate"><span class="pre">/static</span></code>, or as an external URL.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> cannot serve a single
file, nor can it serve a directory of static files directly relative to the
root URL of a <span>Pyramid</span> application.  For these features, see
<a class="reference internal" href="#advanced-static"><span class="std std-ref">Advanced: Serving Static Assets Using a View Callable</span></a>.</p>
</div>
<p>Here's an example of a use of
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> that will serve files up
from the <code class="docutils literal notranslate"><span class="pre">/var/www/static</span></code> directory of the computer which runs the
<span>Pyramid</span> application as URLs beneath the <code class="docutils literal notranslate"><span class="pre">/static</span></code> URL prefix.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;/var/www/static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> represents a URL <em>prefix</em>.  In order for files that live in the
<code class="docutils literal notranslate"><span class="pre">path</span></code> directory to be served, a URL that requests one of them must begin
with that prefix.  In the example above, <code class="docutils literal notranslate"><span class="pre">name</span></code> is <code class="docutils literal notranslate"><span class="pre">static</span></code> and <code class="docutils literal notranslate"><span class="pre">path</span></code> is
<code class="docutils literal notranslate"><span class="pre">/var/www/static</span></code>.  In English this means that you wish to serve the files
that live in <code class="docutils literal notranslate"><span class="pre">/var/www/static</span></code> as sub-URLs of the <code class="docutils literal notranslate"><span class="pre">/static</span></code> URL prefix.
Therefore, the file <code class="docutils literal notranslate"><span class="pre">/var/www/static/foo.css</span></code> will be returned when the user
visits your application's URL <code class="docutils literal notranslate"><span class="pre">/static/foo.css</span></code>.</p>
<p>A static directory named at <code class="docutils literal notranslate"><span class="pre">path</span></code> may contain subdirectories recursively,
and any subdirectories may hold files; these will be resolved by the static
view as you would expect.  The <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> header returned by the static
view for each particular type of file is dependent upon its file extension.</p>
<p>By default, all files made available via
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> are accessible by
completely anonymous users.  Simple authorization can be required, however. To
protect a set of static files using a permission, in addition to passing the
required <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">path</span></code> arguments, also pass the <code class="docutils literal notranslate"><span class="pre">permission</span></code> keyword
argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a>. The value of
the <code class="docutils literal notranslate"><span class="pre">permission</span></code> argument represents the <a class="reference internal" href="../glossary.html#term-permission"><span class="xref std std-term">permission</span></a> that the user
must have relative to the current <a class="reference internal" href="../glossary.html#term-context"><span class="xref std std-term">context</span></a> when the static view is
invoked.  A user will be required to possess this permission to view any of the
files represented by <code class="docutils literal notranslate"><span class="pre">path</span></code> of the static view.  If your static assets must
be protected by a more complex authorization scheme, see
<a class="reference internal" href="#advanced-static"><span class="std std-ref">Advanced: Serving Static Assets Using a View Callable</span></a>.</p>
<p>Here's another example that uses an <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a> instead of an
absolute path as the <code class="docutils literal notranslate"><span class="pre">path</span></code> argument.  To convince
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> to serve files up under
the <code class="docutils literal notranslate"><span class="pre">/static</span></code> URL from the <code class="docutils literal notranslate"><span class="pre">a/b/c/static</span></code> directory of the Python package
named <code class="docutils literal notranslate"><span class="pre">some_package</span></code>, we can use a fully qualified <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset
specification</span></a> as the <code class="docutils literal notranslate"><span class="pre">path</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;some_package:a/b/c/static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">path</span></code> provided to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a>
may be a fully qualified <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a> or an <em>absolute path</em>.</p>
<p>Instead of representing a URL prefix, the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument of a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> can alternately be a
<em>URL</em>.  Each of the examples we've seen so far have shown usage of the <code class="docutils literal notranslate"><span class="pre">name</span></code>
argument as a URL prefix.  However, when <code class="docutils literal notranslate"><span class="pre">name</span></code> is a <em>URL</em>, static assets can
be served from an external webserver.  In this mode, the <code class="docutils literal notranslate"><span class="pre">name</span></code> is used as
the URL prefix when generating a URL using
<a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.static_url()</span></code></a>.</p>
<p>For example, <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> may be fed a
<code class="docutils literal notranslate"><span class="pre">name</span></code> argument which is <code class="docutils literal notranslate"><span class="pre">http://example.com/images</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://example.com/images&#39;</span><span class="p">,</span>
                       <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:images&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Because <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> is provided with a
<code class="docutils literal notranslate"><span class="pre">name</span></code> argument that is the URL <code class="docutils literal notranslate"><span class="pre">http://example.com/images</span></code>, subsequent
calls to <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> with paths that start with
the <code class="docutils literal notranslate"><span class="pre">path</span></code> argument passed to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> will generate a URL
something like <code class="docutils literal notranslate"><span class="pre">http://example.com/images/logo.png</span></code>.  The external webserver
listening on <code class="docutils literal notranslate"><span class="pre">example.com</span></code> must be itself configured to respond properly to
such a request.  The <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> API is
discussed in more detail later in this chapter.</p>
<div class="section" id="generating-static-asset-urls">
<span id="index-3"></span><span id="id1"></span><h3>Generating Static Asset URLs<a class="headerlink" href="#generating-static-asset-urls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When an <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> method is used to
register a static asset directory, a special helper API named
<a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.static_url()</span></code></a> can be used to generate the
appropriate URL for an asset that lives in one of the directories named by the
static registration <code class="docutils literal notranslate"><span class="pre">path</span></code> attribute.</p>
<p>For example, let's assume you create a set of static declarations like so:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static1&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:assets/1&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static2&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:assets/2&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>These declarations create URL-accessible directories which have URLs that begin
with <code class="docutils literal notranslate"><span class="pre">/static1</span></code> and <code class="docutils literal notranslate"><span class="pre">/static2</span></code>, respectively.  The assets in the
<code class="docutils literal notranslate"><span class="pre">assets/1</span></code> directory of the <code class="docutils literal notranslate"><span class="pre">mypackage</span></code> package are consulted when a user
visits a URL which begins with <code class="docutils literal notranslate"><span class="pre">/static1</span></code>, and the assets in the <code class="docutils literal notranslate"><span class="pre">assets/2</span></code>
directory of the <code class="docutils literal notranslate"><span class="pre">mypackage</span></code> package are consulted when a user visits a URL
which begins with <code class="docutils literal notranslate"><span class="pre">/static2</span></code>.</p>
<p>You needn't generate the URLs to static assets &quot;by hand&quot; in such a
configuration.  Instead, use the <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a>
API to generate them for you.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.renderers</span> <span class="kn">import</span> <span class="n">render_to_response</span>

<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">css_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:assets/1/foo.css&#39;</span><span class="p">)</span>
    <span class="n">js_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:assets/2/foo.js&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s1">&#39;templates/my_template.pt&#39;</span><span class="p">,</span>
                              <span class="nb">dict</span><span class="p">(</span><span class="n">css_url</span><span class="o">=</span><span class="n">css_url</span><span class="p">,</span> <span class="n">js_url</span><span class="o">=</span><span class="n">js_url</span><span class="p">),</span>
                              <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If the request &quot;application URL&quot; of the running system is
<code class="docutils literal notranslate"><span class="pre">http://example.com</span></code>, the <code class="docutils literal notranslate"><span class="pre">css_url</span></code> generated above would be:
<code class="docutils literal notranslate"><span class="pre">http://example.com/static1/foo.css</span></code>.  The <code class="docutils literal notranslate"><span class="pre">js_url</span></code> generated above would
be <code class="docutils literal notranslate"><span class="pre">http://example.com/static2/foo.js</span></code>.</p>
<p>One benefit of using the <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> function
rather than constructing static URLs &quot;by hand&quot; is that if you need to change
the <code class="docutils literal notranslate"><span class="pre">name</span></code> of a static URL declaration, the generated URLs will continue to
resolve properly after the rename.</p>
<p>URLs may also be generated by <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> to
static assets that live <em>outside</em> the <span>Pyramid</span> application.  This will
happen when the <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> API
associated with the path fed to <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> is
a <em>URL</em> instead of a view name.  For example, the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument may be
<code class="docutils literal notranslate"><span class="pre">http://example.com</span></code> while the <code class="docutils literal notranslate"><span class="pre">path</span></code> given may be <code class="docutils literal notranslate"><span class="pre">mypackage:images</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://example.com/images&#39;</span><span class="p">,</span>
                       <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:images&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Under such a configuration, the URL generated by <code class="docutils literal notranslate"><span class="pre">static_url</span></code> for assets
which begin with <code class="docutils literal notranslate"><span class="pre">mypackage:images</span></code> will be prefixed with
<code class="docutils literal notranslate"><span class="pre">http://example.com/images</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:images/logo.png&#39;</span><span class="p">)</span>
<span class="c1"># -&gt; http://example.com/images/logo.png</span>
</pre></div>
</td></tr></table></div>
<p>Using <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> in conjunction with a
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> makes it possible to put
static media on a separate webserver during production (if the <code class="docutils literal notranslate"><span class="pre">name</span></code>
argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> is a URL),
while keeping static media package-internal and served by the development
webserver during development (if the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> is a URL prefix).</p>
<p>For example, we may define a <a class="reference internal" href="environment.html#adding-a-custom-setting"><span class="std std-ref">custom setting</span></a>
named <code class="docutils literal notranslate"><span class="pre">media_location</span></code> which we can set to an external URL in production when
our assets are hosted on a CDN.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">media_location</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;media_location&#39;</span><span class="p">,</span> <span class="s1">&#39;static&#39;</span><span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;myapp:static&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">media_location</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Now we can optionally define the setting in our ini file:</p>
<div class="highlight-ini notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># production.ini</span>
<span class="k">[app:main]</span>
<span class="na">use</span> <span class="o">=</span> <span class="s">egg:myapp#main</span>

<span class="na">media_location</span> <span class="o">=</span> <span class="s">http://static.example.com/</span>
</pre></div>
</td></tr></table></div>
<p>It is also possible to serve assets that live outside of the source by
referring to an absolute path on the filesystem. There are two ways to
accomplish this.</p>
<p>First, <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> supports taking an
absolute path directly instead of an asset spec. This works as expected,
looking in the file or folder of files and serving them up at some URL within
your application or externally. Unfortunately, this technique has a drawback in
that it is not possible to use the <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a>
method to generate URLs, since it works based on an asset specification.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加.</span></p>
</div>
<p>The second approach, available in Pyramid 1.6+, uses the asset overriding APIs
described in the <a class="reference internal" href="#overriding-assets-section"><span class="std std-ref">Overriding Assets</span></a> section. It is then possible
to configure a &quot;dummy&quot; package which then serves its file or folder from an
absolute path.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;myapp:static_images&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;myapp:static_images/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;/abs/path/to/images/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>From this configuration it is now possible to use
<a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> to generate URLs to the data in the
folder by doing something like
<code class="docutils literal notranslate"><span class="pre">request.static_url('myapp:static_images/foo.png')</span></code>. While it is not
necessary that the <code class="docutils literal notranslate"><span class="pre">static_images</span></code> file or folder actually exist in the
<code class="docutils literal notranslate"><span class="pre">myapp</span></code> package, it is important that the <code class="docutils literal notranslate"><span class="pre">myapp</span></code> portion points to a valid
package. If the folder does exist, then the overriden folder is given priority,
if the file's name exists in both locations.</p>
</div>
</div>
<div class="section" id="cache-busting">
<span id="index-4"></span><span id="id2"></span><h2>Cache Busting<a class="headerlink" href="#cache-busting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加.</span></p>
</div>
<p>In order to maximize performance of a web application, you generally want to
limit the number of times a particular client requests the same static asset.
Ideally a client would cache a particular static asset &quot;forever&quot;, requiring it
to be sent to the client a single time.  The HTTP protocol allows you to send
headers with an HTTP response that can instruct a client to cache a particular
asset for an amount of time.  As long as the client has a copy of the asset in
its cache and that cache hasn't expired, the client will use the cached copy
rather than request a new copy from the server.  The drawback to sending cache
headers to the client for a static asset is that at some point the static asset
may change, and then you'll want the client to load a new copy of the asset.
Under normal circumstances you'd just need to wait for the client's cached copy
to expire before they get the new version of the static resource.</p>
<p>A commonly used workaround to this problem is a technique known as
<a class="reference internal" href="../glossary.html#term-cache-busting"><span class="xref std std-term">cache busting</span></a>.  Cache busting schemes generally involve generating a
URL for a static asset that changes when the static asset changes.  This way
headers can be sent along with the static asset instructing the client to cache
the asset for a very long time.  When a static asset is changed, the URL used
to refer to it in a web page also changes, so the client sees it as a new
resource and requests the asset, regardless of any caching policy set for the
resource's old URL.</p>
<p><span>Pyramid</span> can be configured to produce cache busting URLs for static
assets using <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_cache_buster()</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">QueryStringConstantCacheBuster</span>

<span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:folder/static/&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span>
    <span class="s1">&#39;mypackage:folder/static/&#39;</span><span class="p">,</span>
    <span class="n">QueryStringConstantCacheBuster</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))))</span>
</pre></div>
</td></tr></table></div>
<p>Adding the cachebuster instructs <span>Pyramid</span> to add the current time for
a static asset to the query string in the asset's URL:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">js_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:folder/static/js/myapp.js&#39;</span><span class="p">)</span>
<span class="c1"># Returns: &#39;http://www.example.com/static/js/myapp.js?x=1445318121&#39;</span>
</pre></div>
</td></tr></table></div>
<p>When the web server restarts, the time constant will change and therefore so
will its URL.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Cache busting is an inherently complex topic as it integrates the asset
pipeline and the web application. It is expected and desired that
application authors will write their own cache buster implementations
conforming to the properties of their own asset pipelines. See
<a class="reference internal" href="#custom-cache-busters"><span class="std std-ref">Customizing the Cache Buster</span></a> for information on writing your own.</p>
</div>
<div class="section" id="disabling-the-cache-buster">
<h3>Disabling the Cache Buster<a class="headerlink" href="#disabling-the-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It can be useful in some situations (e.g., development) to globally disable all
configured cache busters without changing calls to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">add_cache_buster()</span></code>.  To do this set the
<code class="docutils literal notranslate"><span class="pre">PYRAMID_PREVENT_CACHEBUST</span></code> environment variable or the
<code class="docutils literal notranslate"><span class="pre">pyramid.prevent_cachebust</span></code> configuration value to a true value.</p>
</div>
<div class="section" id="customizing-the-cache-buster">
<span id="custom-cache-busters"></span><h3>Customizing the Cache Buster<a class="headerlink" href="#customizing-the-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Calls to <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_cache_buster()</span></code> may use
any object that implements the interface
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.ICacheBuster" title="pyramid.interfaces.ICacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">ICacheBuster</span></code></a>.</p>
<p><span>Pyramid</span> ships with a very simplistic
<a class="reference internal" href="../api/static.html#pyramid.static.QueryStringConstantCacheBuster" title="pyramid.static.QueryStringConstantCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryStringConstantCacheBuster</span></code></a>, which adds an
arbitrary token you provide to the query string of the asset's URL. This
is almost never what you want in production as it does not allow fine-grained
busting of individual assets.</p>
<p>In order to implement your own cache buster, you can write your own class from
scratch which implements the <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.ICacheBuster" title="pyramid.interfaces.ICacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">ICacheBuster</span></code></a>
interface.  Alternatively you may choose to subclass one of the existing
implementations.  One of the most likely scenarios is you'd want to change the
way the asset token is generated.  To do this just subclass
<a class="reference internal" href="../api/static.html#pyramid.static.QueryStringCacheBuster" title="pyramid.static.QueryStringCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryStringCacheBuster</span></code></a> and define a
<code class="docutils literal notranslate"><span class="pre">tokenize(pathspec)</span></code> method. Here is an example which uses Git to get
the hash of the current commit:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">QueryStringCacheBuster</span>

<span class="k">class</span> <span class="nc">GitCacheBuster</span><span class="p">(</span><span class="n">QueryStringCacheBuster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assuming your code is installed as a Git checkout, as opposed to an egg</span>
<span class="sd">    from an egg repository like PYPI, you can use this cachebuster to get</span>
<span class="sd">    the current commit&#39;s SHA1 to use as the cache bust token.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">repo_path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GitCacheBuster</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repo_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">repo_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sha1</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;git&#39;</span><span class="p">,</span> <span class="s1">&#39;rev-parse&#39;</span><span class="p">,</span> <span class="s1">&#39;HEAD&#39;</span><span class="p">],</span>
            <span class="n">cwd</span><span class="o">=</span><span class="n">repo_path</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathspec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sha1</span>
</pre></div>
</td></tr></table></div>
<p>A simple cache buster that modifies the path segment can be constructed as
well:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">posixpath</span>

<span class="k">class</span> <span class="nc">PathConstantCacheBuster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">subpath</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="n">base_subpath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">posixpath</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
        <span class="n">new_subpath</span> <span class="o">=</span> <span class="n">base_subpath</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="k">return</span> <span class="n">new_subpath</span><span class="p">,</span> <span class="n">kw</span>
</pre></div>
</td></tr></table></div>
<p>The caveat with this approach is that modifying the path segment
changes the file name, and thus must match what is actually on the
filesystem in order for <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a>
to find the file. It's better to use the
<a class="reference internal" href="../api/static.html#pyramid.static.ManifestCacheBuster" title="pyramid.static.ManifestCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManifestCacheBuster</span></code></a> for these situations, as
described in the next section.</p>
</div>
<div class="section" id="path-segments-and-choosing-a-cache-buster">
<span id="path-segment-cache-busters"></span><h3>Path Segments and Choosing a Cache Buster<a class="headerlink" href="#path-segments-and-choosing-a-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Many caching HTTP proxies will fail to cache a resource if the URL contains
a query string.  Therefore, in general, you should prefer a cache busting
strategy which modifies the path segment rather than methods which add a
token to the query string.</p>
<p>You will need to consider whether the <span>Pyramid</span> application will be
serving your static assets, whether you are using an external asset pipeline
to handle rewriting urls internal to the css/javascript, and how fine-grained
do you want the cache busting tokens to be.</p>
<p>In many cases you will want to host the static assets on another web server
or externally on a CDN. In these cases your <span>Pyramid</span> application may not
even have access to a copy of the static assets. In order to cache bust these
assets you will need some information about them.</p>
<p>If you are using an external asset pipeline to generate your static files you
should consider using the <a class="reference internal" href="../api/static.html#pyramid.static.ManifestCacheBuster" title="pyramid.static.ManifestCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManifestCacheBuster</span></code></a>.
This cache buster can load a standard JSON formatted file generated by your
pipeline and use it to cache bust the assets. This has many performance
advantages as <span>Pyramid</span> does not need to look at the files to generate
any cache busting tokens, but still supports fine-grained per-file tokens.</p>
<p>Assuming an example <code class="docutils literal notranslate"><span class="pre">manifest.json</span></code> like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;css/main.css&quot;</span><span class="p">:</span> <span class="s2">&quot;css/main-678b7c80.css&quot;</span><span class="p">,</span>
    <span class="nt">&quot;images/background.png&quot;</span><span class="p">:</span> <span class="s2">&quot;images/background-a8169106.png&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following code would set up a cachebuster:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">ManifestCacheBuster</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://mycdn.example.com/&#39;</span><span class="p">,</span>
    <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:static&#39;</span><span class="p">)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span>
    <span class="s1">&#39;mypackage:static/&#39;</span><span class="p">,</span>
    <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;myapp:static/manifest.json&#39;</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>It's important to note that the cache buster only handles generating
cache-busted URLs for static assets. It does <strong>NOT</strong> provide any solutions for
serving those assets. For example, if you generated a URL for
<code class="docutils literal notranslate"><span class="pre">css/main-678b7c80.css</span></code> then that URL needs to be valid either by
configuring <code class="docutils literal notranslate"><span class="pre">add_static_view</span></code> properly to point to the location of the files
or some other mechanism such as the files existing on your CDN or rewriting
the incoming URL to remove the cache bust tokens.</p>
</div>
<div class="section" id="css-and-javascript-source-and-cache-busting">
<span id="index-5"></span><h3>CSS and JavaScript source and cache busting<a class="headerlink" href="#css-and-javascript-source-and-cache-busting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Often one needs to refer to images and other static assets inside CSS and
JavaScript files. If cache busting is active, the final static asset URL is not
available until the static assets have been assembled. These URLs cannot be
handwritten. Below is an example of how to integrate the cache buster into
the entire stack. Remember, it is just an example and should be modified to
fit your specific tools.</p>
<ul class="simple">
<li>First, process the files by using a precompiler which rewrites URLs to their
final cache-busted form. Then, you can use the
<a class="reference internal" href="../api/static.html#pyramid.static.ManifestCacheBuster" title="pyramid.static.ManifestCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManifestCacheBuster</span></code></a> to synchronize your asset
pipeline with <span>Pyramid</span>, allowing the pipeline to have full control
over the final URLs of your assets.</li>
</ul>
<p>Now that you are able to generate static URLs within <span>Pyramid</span>,
you'll need to handle URLs that are out of our control. To do this you may
use some of the following options to get started:</p>
<ul class="simple">
<li>Configure your asset pipeline to rewrite URL references inline in
CSS and JavaScript. This is the best approach because then the files
may be hosted by <span>Pyramid</span> or an external CDN without having to
change anything. They really are static.</li>
<li>Templatize JS and CSS, and call <code class="docutils literal notranslate"><span class="pre">request.static_url()</span></code> inside their
template code. While this approach may work in certain scenarios, it is not
recommended because your static assets will not really be static and are now
dependent on <span>Pyramid</span> to be served correctly. See
<a class="reference internal" href="#advanced-static"><span class="std std-ref">Advanced: Serving Static Assets Using a View Callable</span></a> for more information on this approach.</li>
</ul>
<p>If your CSS and JavaScript assets use URLs to reference other assets it is
recommended that you implement an external asset pipeline that can rewrite the
generated static files with new URLs containing cache busting tokens. The
machinery inside <span>Pyramid</span> will not help with this step as it has very
little knowledge of the asset types your application may use. The integration
into <span>Pyramid</span> is simply for linking those assets into your HTML and
other dynamic content.</p>
</div>
</div>
<div class="section" id="advanced-serving-static-assets-using-a-view-callable">
<span id="advanced-static"></span><h2>Advanced: Serving Static Assets Using a View Callable<a class="headerlink" href="#advanced-serving-static-assets-using-a-view-callable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For more flexibility, static assets can be served by a <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>
which you register manually.  For example, if you're using <a class="reference internal" href="../glossary.html#term-url-dispatch"><span class="xref std std-term">URL
dispatch</span></a>, you may want static assets to only be available as a fallback if no
previous route matches.  Alternatively, you might like to serve a particular
static asset manually, because its download requires authentication.</p>
<p>Note that you cannot use the <a class="reference internal" href="../api/request.html#pyramid.request.Request.static_url" title="pyramid.request.Request.static_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">static_url()</span></code></a> API to
generate URLs against assets made accessible by registering a custom static
view.</p>
<div class="section" id="root-relative-custom-static-view-url-dispatch-only">
<h3>Root-Relative Custom Static View (URL Dispatch Only)<a class="headerlink" href="#root-relative-custom-static-view-url-dispatch-only" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <a class="reference internal" href="../api/static.html#pyramid.static.static_view" title="pyramid.static.static_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.static.static_view</span></code></a> helper class generates a Pyramid view
callable.  This view callable can serve static assets from a directory.  An
instance of this class is actually used by the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_static_view()</span></code></a> configuration method, so
its behavior is almost exactly the same once it's configured.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The following example <em>will not work</em> for applications that use
<a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">traversal</span></a>; it will only work if you use <a class="reference internal" href="../glossary.html#term-url-dispatch"><span class="xref std std-term">URL dispatch</span></a>
exclusively.  The root-relative route we'll be registering will always be
matched before traversal takes place, subverting any views registered via
<code class="docutils literal notranslate"><span class="pre">add_view</span></code> (at least those without a <code class="docutils literal notranslate"><span class="pre">route_name</span></code>).  A
<a class="reference internal" href="../api/static.html#pyramid.static.static_view" title="pyramid.static.static_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">static_view</span></code></a> static view cannot be made
root-relative when you use traversal unless it's registered as a <a class="reference internal" href="../glossary.html#term-not-found-view"><span class="xref std std-term">Not
Found View</span></a>.</p>
</div>
<p>To serve files within a directory located on your filesystem at
<code class="docutils literal notranslate"><span class="pre">/path/to/static/dir</span></code> as the result of a &quot;catchall&quot; route hanging from the
root that exists at the end of your routing table, create an instance of the
<a class="reference internal" href="../api/static.html#pyramid.static.static_view" title="pyramid.static.static_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">static_view</span></code></a> class inside a <code class="docutils literal notranslate"><span class="pre">static.py</span></code> file in your
application root as below.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">static_view</span>
<span class="n">static_view</span> <span class="o">=</span> <span class="n">static_view</span><span class="p">(</span><span class="s1">&#39;/path/to/static/dir&#39;</span><span class="p">,</span> <span class="n">use_subpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For better cross-system flexibility, use an <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a> as
the argument to <a class="reference internal" href="../api/static.html#pyramid.static.static_view" title="pyramid.static.static_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">static_view</span></code></a> instead of a physical
absolute filesystem path, e.g., <code class="docutils literal notranslate"><span class="pre">mypackage:static</span></code>, instead of
<code class="docutils literal notranslate"><span class="pre">/path/to/mypackage/static</span></code>.</p>
</div>
<p>Subsequently, you may wire the files that are served by this view up to be
accessible as <code class="docutils literal notranslate"><span class="pre">/&lt;filename&gt;</span></code> using a configuration method in your
application's startup code.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># .. every other add_route declaration should come</span>
<span class="c1"># before this one, as it will, by default, catch all requests</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;catchall_static&#39;</span><span class="p">,</span> <span class="s1">&#39;/*subpath&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.static.static_view&#39;</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;catchall_static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The special name <code class="docutils literal notranslate"><span class="pre">*subpath</span></code> above is used by the
<a class="reference internal" href="../api/static.html#pyramid.static.static_view" title="pyramid.static.static_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">static_view</span></code></a> view callable to signify the path of the
file relative to the directory you're serving.</p>
</div>
<div class="section" id="registering-a-view-callable-to-serve-a-static-asset">
<h3>Registering a View Callable to Serve a &quot;Static&quot; Asset<a class="headerlink" href="#registering-a-view-callable-to-serve-a-static-asset" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>You can register a simple view callable to serve a single static asset.  To do
so, do things &quot;by hand&quot;.  First define the view callable.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">FileResponse</span>

<span class="k">def</span> <span class="nf">favicon_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">here</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">icon</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="s1">&#39;favicon.ico&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FileResponse</span><span class="p">(</span><span class="n">icon</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above bit of code within <code class="docutils literal notranslate"><span class="pre">favicon_view</span></code> computes &quot;here&quot;, which is a path
relative to the Python file in which the function is defined.  It then creates
a <a class="reference internal" href="../api/response.html#pyramid.response.FileResponse" title="pyramid.response.FileResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.FileResponse</span></code></a> using the file path as the response's
<code class="docutils literal notranslate"><span class="pre">path</span></code> argument and the request as the response's <code class="docutils literal notranslate"><span class="pre">request</span></code> argument.
<a class="reference internal" href="../api/response.html#pyramid.response.FileResponse" title="pyramid.response.FileResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.FileResponse</span></code></a> will serve the file as quickly as
possible when it's used this way.  It makes sure to set the right content
length and content_type, too, based on the file extension of the file you pass.</p>
<p>You might register such a view via configuration as a view callable that should
be called as the result of a traversal:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.views.favicon_view&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;favicon.ico&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Or you might register it to be the view callable for a particular route:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;favicon&#39;</span><span class="p">,</span> <span class="s1">&#39;/favicon.ico&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.views.favicon_view&#39;</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;favicon&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Because this is a simple view callable, it can be protected with a
<a class="reference internal" href="../glossary.html#term-permission"><span class="xref std std-term">permission</span></a> or can be configured to respond under different
circumstances using <a class="reference internal" href="../glossary.html#term-view-predicate"><span class="xref std std-term">view predicate</span></a> arguments.</p>
</div>
</div>
<div class="section" id="overriding-assets">
<span id="overriding-assets-section"></span><span id="index-6"></span><h2>Overriding Assets<a class="headerlink" href="#overriding-assets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>It can often be useful to override specific assets from &quot;outside&quot; a given
<span>Pyramid</span> application.  For example, you may wish to reuse an existing
<span>Pyramid</span> application more or less unchanged.  However, some specific
template file owned by the application might have inappropriate HTML, or some
static asset (such as a logo file or some CSS file) might not be appropriate.
You <em>could</em> just fork the application entirely, but it's often more convenient
to just override the assets that are inappropriate and reuse the application
&quot;as is&quot;.  This is particularly true when you reuse some &quot;core&quot; application over
and over again for some set of customers (such as a CMS application, or some
bug tracking application), and you want to make arbitrary visual modifications
to a particular application deployment without forking the underlying code.</p>
<p>To this end, <span>Pyramid</span> contains a feature that makes it possible to
&quot;override&quot; one asset with one or more other assets.  In support of this
feature, a <a class="reference internal" href="../glossary.html#term-configurator"><span class="xref std std-term">Configurator</span></a> API exists named
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.override_asset" title="pyramid.config.Configurator.override_asset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.override_asset()</span></code></a>.  This API allows you to
<em>override</em> the following kinds of assets defined in any Python package:</p>
<ul class="simple">
<li>Individual template files.</li>
<li>A directory containing multiple template files.</li>
<li>Individual static files served up by an instance of the
<code class="docutils literal notranslate"><span class="pre">pyramid.static.static_view</span></code> helper class.</li>
<li>A directory of static files served up by an instance of the
<code class="docutils literal notranslate"><span class="pre">pyramid.static.static_view</span></code> helper class.</li>
<li>Any other asset (or set of assets) addressed by code that uses the setuptools
<a class="reference internal" href="../glossary.html#term-pkg-resources"><span class="xref std std-term">pkg_resources</span></a> API.</li>
</ul>
<div class="section" id="the-override-asset-api">
<span id="override-asset"></span><span id="index-7"></span><h3>The <code class="docutils literal notranslate"><span class="pre">override_asset</span></code> API<a class="headerlink" href="#the-override-asset-api" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An individual call to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.override_asset" title="pyramid.config.Configurator.override_asset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">override_asset()</span></code></a> can
override a single asset.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span>
    <span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package:templates/mytemplate.pt&#39;</span><span class="p">,</span>
    <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:othertemplates/anothertemplate.pt&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The string value passed to both <code class="docutils literal notranslate"><span class="pre">to_override</span></code> and <code class="docutils literal notranslate"><span class="pre">override_with</span></code> sent to
the <code class="docutils literal notranslate"><span class="pre">override_asset</span></code> API is called an <a class="reference internal" href="../glossary.html#term-asset-specification"><span class="xref std std-term">asset specification</span></a>.  The colon
separator in a specification separates the <em>package name</em> from the <em>asset
name</em>.  The colon and the following asset name are optional.  If they are not
specified, the override attempts to resolve every lookup into a package from
the directory of another package.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Individual subdirectories within a package can also be overridden:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package:templates/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:othertemplates/&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If you wish to override a directory with another directory, you <em>must</em> make
sure to attach the slash to the end of both the <code class="docutils literal notranslate"><span class="pre">to_override</span></code> specification
and the <code class="docutils literal notranslate"><span class="pre">override_with</span></code> specification.  If you fail to attach a slash to the
end of a specification that points to a directory, you will get unexpected
results.</p>
<p>You cannot override a directory specification with a file specification, and
vice versa; a startup error will occur if you try.  You cannot override an
asset with itself; a startup error will occur if you try.</p>
<p>Only individual <em>package</em> assets may be overridden.  Overrides will not
traverse through subpackages within an overridden package.  This means that if
you want to override assets for both <code class="docutils literal notranslate"><span class="pre">some.package:templates</span></code>, and
<code class="docutils literal notranslate"><span class="pre">some.package.views:templates</span></code>, you will need to register two overrides.</p>
<p>The package name in a specification may start with a dot, meaning that the
package is relative to the package in which the configuration construction file
resides (or the <code class="docutils literal notranslate"><span class="pre">package</span></code> argument to the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator" title="pyramid.config.Configurator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Configurator</span></code></a> class construction). For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;.subpackage:templates/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:templates/&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Multiple calls to <code class="docutils literal notranslate"><span class="pre">override_asset</span></code> which name a shared <code class="docutils literal notranslate"><span class="pre">to_override</span></code> but a
different <code class="docutils literal notranslate"><span class="pre">override_with</span></code> specification can be &quot;stacked&quot; to form a search
path.  The first asset that exists in the search path will be used; if no asset
exists in the override path, the original asset is used.</p>
<p>Asset overrides can actually override assets other than templates and static
files.  Any software which uses the
<code class="xref py py-func docutils literal notranslate"><span class="pre">pkg_resources.get_resource_filename()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">pkg_resources.get_resource_stream()</span></code>, or
<code class="xref py py-func docutils literal notranslate"><span class="pre">pkg_resources.get_resource_string()</span></code> APIs will obtain an overridden file
when an override is used.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加: </span>As of Pyramid 1.6, it is also possible to override an asset by supplying an
absolute path to a file or directory. This may be useful if the assets are
not distributed as part of a Python package.</p>
</div>
</div>
<div class="section" id="cache-busting-and-asset-overrides">
<h3>Cache Busting and Asset Overrides<a class="headerlink" href="#cache-busting-and-asset-overrides" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Overriding static assets that are being hosted using
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_static_view" title="pyramid.config.Configurator.add_static_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_static_view()</span></code></a> can affect your cache
busting strategy when using any cache busters that are asset-aware such as
<a class="reference internal" href="../api/static.html#pyramid.static.ManifestCacheBuster" title="pyramid.static.ManifestCacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.static.ManifestCacheBuster</span></code></a>. What sets asset-aware cache
busters apart is that they have logic tied to specific assets. For example,
a manifest is only generated for a specific set of pre-defined assets. Now,
imagine you have overridden an asset defined in this manifest with a new,
unknown version. By default, the cache buster will be invoked for an asset
it has never seen before and will likely end up returning a cache busting
token for the original asset rather than the asset that will actually end up
being served! In order to get around this issue, it's possible to attach a
different <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.ICacheBuster" title="pyramid.interfaces.ICacheBuster"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.ICacheBuster</span></code></a> implementation to the
new assets. This would cause the original assets to be served by their
manifest, and the new assets served by their own cache buster. To do this,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_cache_buster()</span></code> supports an <code class="docutils literal notranslate"><span class="pre">explicit</span></code>
option. For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">ManifestCacheBuster</span>

<span class="c1"># define a static view for myapp:static assets</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="s1">&#39;myapp:static&#39;</span><span class="p">)</span>

<span class="c1"># setup a cache buster for your app based on the myapp:static assets</span>
<span class="n">my_cb</span> <span class="o">=</span> <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;myapp:static/manifest.json&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span><span class="s1">&#39;myapp:static&#39;</span><span class="p">,</span> <span class="n">my_cb</span><span class="p">)</span>

<span class="c1"># override an asset</span>
<span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span>
    <span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;myapp:static/background.png&#39;</span><span class="p">,</span>
    <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;theme:static/background.png&#39;</span><span class="p">)</span>

<span class="c1"># override the cache buster for theme:static assets</span>
<span class="n">theme_cb</span> <span class="o">=</span> <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;theme:static/manifest.json&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span><span class="s1">&#39;theme:static&#39;</span><span class="p">,</span> <span class="n">theme_cb</span><span class="p">,</span> <span class="n">explicit</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example there is a default cache buster, <code class="docutils literal notranslate"><span class="pre">my_cb</span></code>, for all
assets served from the <code class="docutils literal notranslate"><span class="pre">myapp:static</span></code> folder. This would also affect
<code class="docutils literal notranslate"><span class="pre">theme:static/background.png</span></code> when generating URLs via
<code class="docutils literal notranslate"><span class="pre">request.static_url('myapp:static/background.png')</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">theme_cb</span></code> is defined explicitly for any assets loaded from the
<code class="docutils literal notranslate"><span class="pre">theme:static</span></code> folder. Explicit cache busters have priority and thus
<code class="docutils literal notranslate"><span class="pre">theme_cb</span></code> would be invoked for
<code class="docutils literal notranslate"><span class="pre">request.static_url('myapp:static/background.png')</span></code>, but <code class="docutils literal notranslate"><span class="pre">my_cb</span></code> would
be used for any other assets like
<code class="docutils literal notranslate"><span class="pre">request.static_url('myapp:static/favicon.ico')</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Static Assets</a><ul>
<li><a class="reference internal" href="#understanding-asset-specifications">Understanding Asset Specifications</a></li>
<li><a class="reference internal" href="#serving-static-assets">Serving Static Assets</a><ul>
<li><a class="reference internal" href="#generating-static-asset-urls">Generating Static Asset URLs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-busting">Cache Busting</a><ul>
<li><a class="reference internal" href="#disabling-the-cache-buster">Disabling the Cache Buster</a></li>
<li><a class="reference internal" href="#customizing-the-cache-buster">Customizing the Cache Buster</a></li>
<li><a class="reference internal" href="#path-segments-and-choosing-a-cache-buster">Path Segments and Choosing a Cache Buster</a></li>
<li><a class="reference internal" href="#css-and-javascript-source-and-cache-busting">CSS and JavaScript source and cache busting</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-serving-static-assets-using-a-view-callable">Advanced: Serving Static Assets Using a View Callable</a><ul>
<li><a class="reference internal" href="#root-relative-custom-static-view-url-dispatch-only">Root-Relative Custom Static View (URL Dispatch Only)</a></li>
<li><a class="reference internal" href="#registering-a-view-callable-to-serve-a-static-asset">Registering a View Callable to Serve a &quot;Static&quot; Asset</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overriding-assets">Overriding Assets</a><ul>
<li><a class="reference internal" href="#the-override-asset-api">The <code class="docutils literal notranslate"><span class="pre">override_asset</span></code> API</a></li>
<li><a class="reference internal" href="#cache-busting-and-asset-overrides">Cache Busting and Asset Overrides</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="viewconfig.html"
                        title="前の章へ">View Configuration</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="webob.html"
                        title="次の章へ">Request and Response Objects</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/narr/assets.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="webob.html" title="Request and Response Objects"
             >次へ</a> |</li>
        <li class="right" >
          <a href="viewconfig.html" title="View Configuration"
             >前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 8月 15, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4 で生成しました。
    </div>
  </body>
</html>
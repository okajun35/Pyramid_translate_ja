
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>(機械翻訳) 静的資産 &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="(機械翻訳) 要求オブジェクトと応答オブジェクト" href="webob.html" />
    <link rel="prev" title="(機械翻訳) 設定を表示" href="viewconfig.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="webob.html" title="(機械翻訳) 要求オブジェクトと応答オブジェクト"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="viewconfig.html" title="(機械翻訳) 設定を表示"
             accesskey="P">前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="static-assets">
<span id="assets-chapter"></span><span id="index-0"></span><h1>(機械翻訳) 静的資産<a class="headerlink" href="#static-assets" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>An：term： <cite>asset`は、PythonソースコードファイルではないPython：term：</cite> package`に含まれるファイルです。たとえば、以下はそれぞれ資産です。</p>
<ul class="simple">
<li>Pythonパッケージに含まれるGIF画像ファイル、またはPythonパッケージのサブディレクトリに含まれるGIF画像ファイル。</li>
<li>Pythonパッケージに含まれるCSSファイル、またはPythonパッケージのサブディレクトリに含まれるCSSファイル。</li>
<li>Pythonパッケージに含まれるか、Pythonパッケージのサブディレクトリに含まれるJavaScriptソースファイル。</li>
<li>それが `` __init __。py``を持たないパッケージ内のディレクトリ（パッケージである `` __init __。py``を持っている場合）です。</li>
<li>a：term： <cite>Chameleon`または：term：</cite> Mako`テンプレートファイル（Pythonパッケージに含まれています）。</li>
</ul>
<p>ほとんどのWeb開発プロジェクトでは、資産の使用が非常に一般的です。たとえば、：ref： <cite>creating_a_project`で説明されているように、：app：</cite> Pyramid`アプリケーションを利用可能なterm： <cite>cookiecutter</cite> sで作成すると、アプリケーションを表すディレクトリにPython：term： <cite>パッケージ</cite>。そのPythonパッケージ内には、静的資産であるファイルがいっぱいのディレクトリがあります。たとえば、 `` .css``、 `` .js``、および <cite>.gif``ファイルを含む</cite> <cite>静的</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>ディレクトリがあります。これらのアセットファイルは、ユーザーがアプリケーションURLにアクセスしたときに配信されます。</p>
<div class="section" id="understanding-asset-specifications">
<span id="asset-specifications"></span><span id="index-1"></span><h2>資産の仕様の理解<a class="headerlink" href="#understanding-asset-specifications" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>pyramid.renderers.render_to_response</cite> APIを使って：term：` Chameleon` ZPTテンプレートを使用する：app： <cite>Pyramid`アプリケーションを作成したとします。例えば、アプリケーションは `</cite> myapp``パッケージ内の `` views.py``ファイル内でそのAPIを使用して：term： <cite>asset specification`</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>myapp：templates / some_template.pt``を使ってアセットにアクセスするかもしれません：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.renderers</span> <span class="kn">import</span> <span class="n">render_to_response</span>
<span class="n">render_to_response</span><span class="p">(</span><span class="s1">&#39;myapp:templates/some_template.pt&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>&amp;quot;Under the hood &amp;quot;、このAPIが呼び出されると、：app： <cite>Pyramid`は、開発者によって提供された文字列</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>myapp：templates / some_template.pt`の意味を理解しようとします。この文字列は：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>asset specification`です。これは2つの部分で構成されています。</p>
<ul class="simple">
<li><a href="#id1"><span class="problematic" id="id2">*</span></a>パッケージ名*（ `` myapp``）</li>
<li>パッケージディレクトリに対する*アセット名*（ `` templates / some_template.pt``）。</li>
</ul>
<p>2つの部分はコロン <a href="#id1"><span class="problematic" id="id2">``</span></a>： <a href="#id3"><span class="problematic" id="id4">``</span></a>文字で区切られています。</p>
<p>：app： <cite>Pyramid`は、Python：term：</cite> pkg_resources` APIを使用して、パッケージ名とアセット名を絶対（オペレーティングシステム固有の）ファイル名に解決します。最終的には解決されたこの絶対ファイルシステムパスをChameleonテンプレートエンジンに渡し、テンプレートエンジンを使用してテンプレートファイルの読み込み、解析、実行を行います。</p>
<p>第二の形式の資産指定：相対*資産指定があります。特定の状況では、パッケージ名を含むアセット指定を&amp;quot;絶対&amp;quot;の代わりに指定から省略することができます。たとえば、 `` myapp：templates / some_template.pt``の代わりに `` templates / mytemplate.pt``を使うことができます。このような資産の仕様は、通常、現在のパッケージとの相対的なものです。 &amp;quot;現在のパッケージ&amp;quot;は通常、資産仕様を使用するコードを含むパッケージです。 ：app：ピラミッドAPIは、相対資産仕様を受け入れるもので、一般的に、個々の文書でその資産が相対的なものであることを表します。</p>
</div>
<div class="section" id="serving-static-assets">
<span id="static-assets-section"></span><span id="index-2"></span><h2>静的資産の提供<a class="headerlink" href="#serving-static-assets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：app： <cite>Pyramid`は、ファイルシステム上のディレクトリから静的アセットファイルをアプリケーションユーザのブラウザに提供することを可能にします。 ：meth： `pyramid.config.Configurator.add_static_view`を使って、app：</cite> Pyramid`にJavaScriptやCSSファイルなどの静的アセットを提供するよう指示します。このメカニズムは静的ファイルのディレクトリをアプリケーションのルートURLに関連する名前、例えば `` / static``や外部URLとして利用可能にします。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：meth： <cite>〜pyramid.config.Configurator.add_static_view`は1つのファイルを提供することはできませんし、a：app：</cite> Pyramid`アプリケーションのルートURLに対して直接静的ファイルのディレクトリを提供することもできません。これらの機能については、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>advanced_static`を参照してください。</p>
</div>
<p>以下は、：meth： <cite>〜pyramid.config.Configurator.add_static_view`の使用例です。これは：app：</cite> Pyramid`を実行するコンピュータの `` / var / www / static``ディレクトリからファイルを提供します。アプリケーションを `` / static`` URL接頭辞の下にURLとして追加します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;/var/www/static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>`` name``はURL <a href="#id1"><span class="problematic" id="id2">*</span></a>プレフィックス*を表します。 `` path``ディレクトリにあるファイルが提供されるためには、それらのうちの1つを要求するURLがその接頭辞で始まらなければなりません。上記の例では、 `` name``は <code class="docutils literal notranslate"><span class="pre">静的</span> <span class="pre">``で、</span> <span class="pre">``</span> <span class="pre">path``は</span> <span class="pre">``</span> <span class="pre">/</span> <span class="pre">var</span> <span class="pre">/</span> <span class="pre">www</span> <span class="pre">/</span> <span class="pre">static``です。英語では、</span> <span class="pre">``</span> <span class="pre">/</span> <span class="pre">var</span> <span class="pre">/</span> <span class="pre">www</span> <span class="pre">/</span> <span class="pre">static``にあるファイルを</span> <span class="pre">``</span> <span class="pre">/</span> <span class="pre">static</span></code> URL接頭辞のサブURLとして提供したいと考えています。したがって、ユーザーがあなたのアプリケーションのURL「/ static / foo.css」を訪れたときに、ファイル `` / var / www / static / foo.css``が返されます。</p>
<p>`` path``で指定された静的ディレクトリには、サブディレクトリが再帰的に含まれることがあります。また、サブディレクトリにはファイルが保存されます。これらは静的ビューによって解決されます。特定のファイルタイプごとに静的ビューから返される `` Content-Type``ヘッダーは、そのファイル拡張子に依存します。</p>
<p>デフォルトでは、：meth： <cite>〜pyramid.config.Configurator.add_static_view`で利用できるすべてのファイルは完全に匿名のユーザーがアクセスできます。ただし、単純な承認が必要な場合があります。パーミッションを使って静的ファイルのセットを保護するには、必要な `</cite> name``と `` path``引数を渡すだけでなく、 `` permission``キーワード引数を：meth： <cite>〜pyramid.configに渡します。 Configurator.add_static_view</cite>。 `` permission``引数の値は、静的ビューが呼び出されたときにユーザがcurrent：term： <cite>context`を基準にして持っていなければならない：term：</cite> permission`を表します。ユーザは静的ビューの `` path``で表されるファイルを見るためにこの許可を持っている必要があります。静的資産をより複雑な認可スキームで保護する必要がある場合は、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>advanced_static`を参照してください。</p>
<p>`` path``引数として絶対パスの代わりに：term： <cite>asset specification`を使用する別の例を次に示します。確かめるには：meth： `〜pyramid.config.Configurator.add_static_view`は、</cite> <cite>some_packageというPythonパッケージの</cite> <cite>a / b / c / static``ディレクトリから</cite> <cite>/ static`</cite> URLの下にファイルを提供する``、 `` path``として完全修飾：項：資産指定を使うことができます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;some_package:a/b/c/static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.add_static_view`は、完全修飾語：用語：資産指定または*絶対パス*とすることができます。</p>
<p>URL接頭辞を表す代わりに、：meth： <cite>〜pyramid.config.Configurator.add_static_view`の呼び出しの</cite> <cite>name``引数は、代わりに* URL *にすることができます。これまでに見てきたそれぞれの例では、URL接頭辞として &amp;quot;name&amp;quot;引数を使用しています。ただし、 `</cite> name``が* URL <a href="#id1"><span class="problematic" id="id2">*</span></a>の場合、静的アセットは外部Webサーバーから提供されます。このモードでは、：meth： <cite>pyramid.request.Request.static_url`を使用してURLを生成するときに、</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>name``がURLプレフィックスとして使用されます。</p>
<p>たとえば、：meth： <cite>〜pyramid.config.Configurator.add_static_view`は、</cite> <cite>http：// example.com / images``という名前の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>name``引数を与えられます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://example.com/images&#39;</span><span class="p">,</span>
                       <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:images&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>：meth： <cite>〜pyramid.config.Configurator.add_static_view`は</cite> <cite>http：// example.com / images``のURLである</cite> <cite>name``引数で提供され、それ以降の：meth：</cite>〜 pyramid.request.Request.static_url`に渡された `` path``引数で始まるパス：meth： <cite>〜pyramid.config.Configurator.add_static_view`は、</cite> <cite>http://example.com &amp;#39;のようなURLを生成します/ images / logo.png`</cite>。 `` example.com``をリッスンしている外部Webサーバーは、そのような要求に適切に応答するように構成されていなければなりません。 ：meth： <cite>〜pyramid.request.Request.static_url</cite> APIについては、この章の後半で詳しく説明します。</p>
<div class="section" id="generating-static-asset-urls">
<span id="index-3"></span><span id="id1"></span><h3>静的資産URLの生成<a class="headerlink" href="#generating-static-asset-urls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>静的アセットディレクトリを登録するために：meth： <cite>〜pyramid.config.Configurator.add_static_view`メソッドが使用された場合、適切なURLを生成するために：meth：</cite> pyramid.request.Request.static_url`という名前の特殊ヘルパーAPIを使用できます静的登録 `` path``属性によって指定されたディレクトリの1つに存在するアセットのためのものです。</p>
<p>たとえば、次のような静的宣言のセットを作成するとします。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static1&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:assets/1&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static2&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:assets/2&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>これらの宣言は、それぞれが `` / static1``と `` / static2``で始まるURLを持つURLアクセス可能なディレクトリを作成します。ユーザーが `` / static1``で始まるURLを訪問し、 `` assets / 2``の資産を参照すると、 `` mypackage``パッケージの `` assets / 1``ディレクトリにある資産が参照されますユーザが `` / static2``で始まるURLにアクセスすると、 `` mypackage``パッケージのディレクトリが参照されます。</p>
<p>このような構成では、静的アセットへのURLを手作業で生成する必要はありません。代わりに、：meth： <cite>〜pyramid.request.Request.static_url</cite> APIを使用してそれらを生成してください。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.renderers</span> <span class="kn">import</span> <span class="n">render_to_response</span>

<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">css_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:assets/1/foo.css&#39;</span><span class="p">)</span>
    <span class="n">js_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:assets/2/foo.js&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s1">&#39;templates/my_template.pt&#39;</span><span class="p">,</span>
                              <span class="nb">dict</span><span class="p">(</span><span class="n">css_url</span><span class="o">=</span><span class="n">css_url</span><span class="p">,</span> <span class="n">js_url</span><span class="o">=</span><span class="n">js_url</span><span class="p">),</span>
                              <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>実行中のシステムのリクエスト &amp;quot;アプリケーションURL&amp;quot;が &amp;quot;http：// example.com&amp;quot;の場合、上記で生成された &amp;quot;css_url&amp;quot;は次のようになります： &amp;quot;http://example.com/static1/foo .css``。上記で生成された `` js_url``は `` http：// example.com / static2 / foo.js``です。</p>
<p>静的URLを手作業で構築するのではなく、：meth： <cite>〜pyramid.request.Request.static_url`関数を使う利点の1つは、静的URL宣言の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>name``を変更する必要がある場合、生成されたURLは名前の変更後も引き続き適切に解決されます。</p>
<p>URL：：meth： <cite>〜pyramid.request.Request.static_url`を使って：app：</cite> Pyramid`アプリケーションの外部にある静的アセットにURLを生成することもできます。これは、：meth： <cite>〜pyramid.config.Configurator.add_static_view</cite> APIが、：meth：<cite>〜pyramid.request.Request.static_url`に与えられたパスに関連付けられ、ビュー名の代わりに* URL *である場合に発生します。たとえば、 `</cite> name``引数は `` http：// example.com``であり、 `` path``は `` mypackage：images``：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://example.com/images&#39;</span><span class="p">,</span>
                       <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:images&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>このような設定では、 `` mypackage：images``で始まるアセットの `` static_url``で生成されるURLの先頭に `` http：// example.com / images``という接頭辞が付きます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:images/logo.png&#39;</span><span class="p">)</span>
<span class="c1"># -&gt; http://example.com/images/logo.png</span>
</pre></div>
</td></tr></table></div>
<p>：meth： <cite>〜pyramid.request.Request.static_url`を：meth：</cite>〜pyramid.config.Configurator.add_static_view`と組み合わせて使用​​すると、制作中に別のウェブサーバーに静的メディアを置くことができます（ <a href="#id1"><span class="problematic" id="id2">``</span></a>名前開発中に開発中のWebサーバが静的メディアを内部的に保持しておきながら（meth： <cite>〜pyramid.config.Configurator.add_static_view`はURLです）、</cite> <cite>meth：</cite> ` <a href="#id3"><span class="problematic" id="id4">`</span></a>〜pyramid.config.Configurator.add_static_view`はURLプレフィックスです）。</p>
<p>たとえば、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>カスタム設定を定義することができます&lt;adding_a_custom_setting&gt;私たちの資産がCDN上でホストされているときに、本番環境の外部URLに設定できる <a href="#id3"><span class="problematic" id="id4">`</span></a>media_location`という名前です。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">media_location</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;media_location&#39;</span><span class="p">,</span> <span class="s1">&#39;static&#39;</span><span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;myapp:static&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">media_location</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>これで設定をiniファイルに定義することができます：</p>
<div class="highlight-ini notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># production.ini</span>
<span class="k">[app:main]</span>
<span class="na">use</span> <span class="o">=</span> <span class="s">egg:myapp#main</span>

<span class="na">media_location</span> <span class="o">=</span> <span class="s">http://static.example.com/</span>
</pre></div>
</td></tr></table></div>
<p>また、ファイルシステム上の絶対パスを参照することで、ソース外にある資産を提供することもできます。これを達成するには2つの方法があります。</p>
<p>まず、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.add_static_view`はアセット仕様の代わりに絶対パスを直接取ることをサポートしています。これは期待どおりに動作し、ファイルやファイルのフォルダを探し、アプリケーション内のあるURLや外部から提供します。残念ながら、このテクニックには、アセット仕様に基づいて動作するため、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜pyramid.request.Request.static_url`メソッドを使用してURLを生成することができないという欠点があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加.</span></p>
</div>
<p>Pyramid 1.6以降で利用可能な2番目のアプローチは、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>overriding_assets_section`セクションで説明されているアセットオーバーライドAPIを使用しています。 &amp;quot;ダミー&amp;quot;パッケージを構成して、そのファイルまたはフォルダを絶対パスから提供することは可能です。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;myapp:static_images&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;myapp:static_images/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;/abs/path/to/images/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>この設定から、 `` request.static_url（ &amp;#39;myapp：static_images / foo.png&amp;#39;のようなことをして、フォルダ内のデータへのURLを生成するために：meth： <cite>〜pyramid.request.Request.static_url`を使うことが可能になりました。 ） `</cite>。 `` static_images``ファイルまたはフォルダが実際に `` myapp``パッケージに存在する必要はありませんが、 `` myapp``部分が有効なパッケージを指していることが重要です。フォルダーが存在する場合は、ファイルの名前が両方の場所に存在する場合は、オーバーライドされたフォルダーに優先順位が与えられます。</p>
</div>
</div>
<div class="section" id="cache-busting">
<span id="index-4"></span><span id="id2"></span><h2>キャッシュバスト<a class="headerlink" href="#cache-busting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加.</span></p>
</div>
<p>Webアプリケーションのパフォーマンスを最大限にするには、一般に、特定のクライアントが同じ静的資産を要求する回数を制限する必要があります。理想的には、クライアントは特定の静的資産を永久にキャッシュし、クライアントに一度だけ送信する必要があります。 HTTPプロトコルを使用すると、特定のアセットを一定時間キャッシュするようにクライアントに指示できるHTTPレスポンスでヘッダーを送信できます。クライアントがキャッシュ内にアセットのコピーを持ち、そのキャッシュの有効期限が切れていない限り、クライアントはサーバーから新しいコピーを要求するのではなく、キャッシュされたコピーを使用します。静的アセットのクライアントへのキャッシュヘッダーの送信の欠点は、ある時点で静的アセットが変更される可能性があることです。クライアントはアセットの新しいコピーをロードする必要があります。通常の状況下では、クライアントのキャッシュされたコピーが期限切れになるのを待ってから、新しいバージョンの静的リソースを取得する必要があります。</p>
<p>この問題の一般的な回避策は、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>cache busting`と呼ばれる手法です。キャッシュ無効化方式には、通常、静的資産が変更されたときに変更される静的資産のURLを生成することが含まれます。このようにして、クライアントに静的アセットを送信して、クライアントにアセットを非常に長時間キャッシュするように指示することができます。静的アセットが変更されると、Webページでそれを参照するために使用されるURLも変更されるため、クライアントは新しいリソースとして認識し、リソースの古いURLに設定されたキャッシュポリシーに関係なくアセットを要求します。</p>
<p>：app： <cite>Pyramid`は、以下を使って静的アセットのキャッシュ破棄URLを生成するように設定できます：meth：</cite>〜pyramid.config.Configurator.add_cache_buster`：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">QueryStringConstantCacheBuster</span>

<span class="c1"># config is an instance of pyramid.config.Configurator</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:folder/static/&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span>
    <span class="s1">&#39;mypackage:folder/static/&#39;</span><span class="p">,</span>
    <span class="n">QueryStringConstantCacheBuster</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))))</span>
</pre></div>
</td></tr></table></div>
<p>キャッシュバスターを追加すると：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`は、資産のURLのクエリ文字列に静的アセットの現在の時刻を追加します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">js_url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">static_url</span><span class="p">(</span><span class="s1">&#39;mypackage:folder/static/js/myapp.js&#39;</span><span class="p">)</span>
<span class="c1"># Returns: &#39;http://www.example.com/static/js/myapp.js?x=1445318121&#39;</span>
</pre></div>
</td></tr></table></div>
<p>Webサーバーが再起動すると、時定数が変更されるため、URLも変更されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">キャッシュ・バスト処理は、資産パイプラインとWebアプリケーションを統合するため、本質的に複雑なトピックです。アプリケーション作成者は、独自のアセットパイプラインのプロパティに準拠した独自のキャッシュバスター実装を作成することが期待され、望まれています。独自の記述については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>custom_cache_busters`を参照してください。</p>
</div>
<div class="section" id="disabling-the-cache-buster">
<h3>キャッシュ・バスターの無効化<a class="headerlink" href="#disabling-the-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜pyramid.config.Configurator.add_cache_buster`への呼び出しを変更することなく、設定されたすべてのキャッシュバスターをグローバルに無効にすることができます（開発など）。これを行うには、 `</cite> PYRAMID_PREVENT_CACHEBUST``環境変数か `` pyramid.prevent_cachebust``設定値を真の値に設定します。</p>
</div>
<div class="section" id="customizing-the-cache-buster">
<span id="custom-cache-busters"></span><h3>キャッシュ・バスターのカスタマイズ<a class="headerlink" href="#customizing-the-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜pyramid.config.Configurator.add_cache_buster`を呼び出すと、class：</cite>〜pyramid.interfaces.ICacheBuster`というインターフェースを実装するオブジェクトを使用できます。</p>
<p>：app： <cite>Pyramid`は非常に単純化されています：class：</cite>〜pyramid.static.QueryStringConstantCacheBuster`：アセットのURLのクエリ文字列にあなたが提供する任意のトークンを追加します。これは、個々の資産をきめ細かく破棄することができないため、プロダクションではほとんど望みません。</p>
<p>独自のキャッシュ・バスターを実装するために、：class： <cite>〜pyramid.interfaces.ICacheBuster`インターフェースを実装して独自のクラスを一から書くことができます。あるいは、既存の実装の1つをサブクラス化することもできます。最も可能性の高いシナリオの1つは、資産トークンの生成方法を変更することです。これを行うにはclass： `〜pyramid.static.QueryStringCacheBuster`をサブクラス化し、</cite> <cite>tokenize（pathspec）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>メソッドを定義してください。 Gitを使って現在のコミットのハッシュを取得する例を以下に示します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">QueryStringCacheBuster</span>

<span class="k">class</span> <span class="nc">GitCacheBuster</span><span class="p">(</span><span class="n">QueryStringCacheBuster</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assuming your code is installed as a Git checkout, as opposed to an egg</span>
<span class="sd">    from an egg repository like PYPI, you can use this cachebuster to get</span>
<span class="sd">    the current commit&#39;s SHA1 to use as the cache bust token.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">repo_path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GitCacheBuster</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repo_path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">repo_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sha1</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;git&#39;</span><span class="p">,</span> <span class="s1">&#39;rev-parse&#39;</span><span class="p">,</span> <span class="s1">&#39;HEAD&#39;</span><span class="p">],</span>
            <span class="n">cwd</span><span class="o">=</span><span class="n">repo_path</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathspec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sha1</span>
</pre></div>
</td></tr></table></div>
<p>パスセグメントを変更する簡単なキャッシュバスターも構築できます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">posixpath</span>

<span class="k">class</span> <span class="nc">PathConstantCacheBuster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">subpath</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
        <span class="n">base_subpath</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">posixpath</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">subpath</span><span class="p">)</span>
        <span class="n">new_subpath</span> <span class="o">=</span> <span class="n">base_subpath</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="k">return</span> <span class="n">new_subpath</span><span class="p">,</span> <span class="n">kw</span>
</pre></div>
</td></tr></table></div>
<p>このアプローチの注意点は、パスセグメントを変更するとファイル名が変更されるため、実際にファイルシステムにあるものと一致して、ファイルを見つけるために：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.add_static_view`が必要であるということです。次のセクションで説明するように、これらの状況には：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜pyramid.static.ManifestCacheBuster`を使用する方が良いでしょう。</p>
</div>
<div class="section" id="path-segments-and-choosing-a-cache-buster">
<span id="path-segment-cache-busters"></span><h3>パスセグメントとキャッシュバスターの選択<a class="headerlink" href="#path-segments-and-choosing-a-cache-buster" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多くのキャッシュHTTPプロキシは、URLにクエリ文字列が含まれている場合、リソースをキャッシュできません。したがって、一般に、トークンをクエリ文字列に追加する方法ではなく、パスセグメントを変更するキャッシュ破棄戦略を使用することをお勧めします。</p>
<p>：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションがあなたの静的資産を提供するかどうか、css / javascript内部の書き換えURLを処理するために外部の資産パイプラインを使用しているかどうか、キャッシュをどのように細かくしたいかを検討する必要がありますトークンを破る。</p>
<p>多くの場合、静的資産を別のWebサーバーまたはCDNの外部にホストする必要があります。これらの場合、your：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションは静的資産のコピーにアクセスすることさえできないことがあります。これらの資産をバストにキャッシュするには、それらに関するいくつかの情報が必要です。</p>
<p>静的ファイルを生成するために外部アセットパイプラインを使用する場合は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.static.ManifestCacheBuster`を使用することを検討する必要があります。このキャッシュ・バスターは、パイプラインによって生成された標準JSON形式のファイルをロードし、それを使用してアセットをバッシュ・キャッシュすることができます。 app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`は、キャッシュ破棄トークンを生成するためにファイルを見る必要はありませんが、ファイル単位の細かいトークンをサポートしています。</p>
<p>例えば、 `` manifest.json``のような例を考えます：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="nt">&quot;css/main.css&quot;</span><span class="p">:</span> <span class="s2">&quot;css/main-678b7c80.css&quot;</span><span class="p">,</span>
    <span class="nt">&quot;images/background.png&quot;</span><span class="p">:</span> <span class="s2">&quot;images/background-a8169106.png&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次のコードはキャッシュバスターを設定します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">ManifestCacheBuster</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;http://mycdn.example.com/&#39;</span><span class="p">,</span>
    <span class="n">path</span><span class="o">=</span><span class="s1">&#39;mypackage:static&#39;</span><span class="p">)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span>
    <span class="s1">&#39;mypackage:static/&#39;</span><span class="p">,</span>
    <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;myapp:static/manifest.json&#39;</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>キャッシュバスターは、静的アセットのキャッシュで破棄されたURLの生成のみを処理することに注意することが重要です。これらの資産を提供するためのソリューションは提供していません**。たとえば、 `` css / main-678b7c80.css``のURLを生成した場合、そのURLはファイルの場所を指すように `` add_static_view``を適切に設定するか、あなたのCDN上に存在するファイル、または着信URLを書き換えてキャッシュバストトークンを削除します。</p>
</div>
<div class="section" id="css-and-javascript-source-and-cache-busting">
<span id="index-5"></span><h3>CSSとJavaScriptのソースとキャッシュの破棄<a class="headerlink" href="#css-and-javascript-source-and-cache-busting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多くの場合、CSSやJavaScriptファイル内のイメージやその他の静的なアセットを参照する必要があります。キャッシュ無効化が有効な場合、最終的な静的アセットURLは、静的アセットがアセンブルされるまで使用できません。これらのURLは手書きできません。以下は、キャッシュバスターをスタック全体に統合する方法の例です。これは単なる例であり、特定のツールに合わせて修正する必要があることを覚えておいてください。</p>
<ul class="simple">
<li>最初に、URLを最終的なキャッシュ・バスト・フォームに書き換えるプリコンパイラを使用してファイルを処理します。次に、：class： <cite>〜pyramid.static.ManifestCacheBuster`を使用してアセットパイプラインを：app：</cite> Pyramid`と同期させることができます。パイプラインはアセットの最終URLを完全に制御できます。</li>
</ul>
<p>これで、：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`内で静的URLを生成できるようになったので、あなたがコントロールできないURLを処理する必要があります。これを行うには、以下のオプションのいくつかを使用して開始してください。</p>
<ul class="simple">
<li>アセットパイプラインを設定して、CSSおよびJavaScriptでURL参照をインラインで書き直すようにします。これは、ファイルをapp： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`または外部のCDNで変更することなくホストすることができるため、最良の方法です。彼らは本当に静的です。</li>
<li>JSとCSSをTemplatizeし、テンプレートコードの中で `` request.static_url（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を呼び出します。このアプローチは特定のシナリオではうまくいくかもしれませんが、静的資産は実際には静的ではなく、app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`が正しく提供されるため、推奨されません。このアプローチの詳細については：ref： <a href="#id5"><span class="problematic" id="id6">`</span></a>advanced_static`を参照してください。</li>
</ul>
<p>CSSおよびJavaScriptアセットでURLを使用して他のアセットを参照する場合、生成された静的ファイルをキャッシュ破棄トークンを含む新しいURLに書き換えることができる外部アセットパイプラインを実装することをお勧めします。内部の機械：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`は、アプリケーションが使用する資産の種類についての知識がほとんどないため、このステップを助けません。 ：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`への統合は、単にそれらのアセットをHTMLや他の動的コンテンツにリンクするためだけです。</p>
</div>
</div>
<div class="section" id="advanced-serving-static-assets-using-a-view-callable">
<span id="advanced-static"></span><h2>上級者：ビューコールバックを使用した静的資産の処理<a class="headerlink" href="#advanced-serving-static-assets-using-a-view-callable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>柔軟性を高めるために、静的資産は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view callable`によって提供され、手動で登録します。たとえば、：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>URL dispatch`を使用している場合、以前のルートが一致しない場合にのみ静的資産をフォールバックとして使用できるようにすることができます。あるいは、ダウンロードに認証が必要なため、特定の静的資産を手動で提供することもできます。</p>
<p>：meth： <cite>〜pyramid.request.Request.static_url</cite> APIを使用して、カスタム静的ビューを登録してアクセス可能にしたアセットに対するURLを生成することはできません。</p>
<div class="section" id="root-relative-custom-static-view-url-dispatch-only">
<h3>ルート関連のカスタムスタティックビュー（URLディスパッチのみ）<a class="headerlink" href="#root-relative-custom-static-view-url-dispatch-only" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.static.static_view`ヘルパークラスは、呼び出し可能なピラミッドビューを生成します。このビュー呼び出し可能は、ディレクトリから静的資産を提供することができます。このクラスのインスタンスは：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜pyramid.config.Configurator.add_static_view`設定メソッドによって実際に使用されるため、設定された動作はほぼ同じになります。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">次の例では、term： <cite>traversal`を使用するアプリケーションで*動作しません。 term： `URL dispatch`を排他的に使用すると動作します。登録するルート相対ルートは、トラバーサルが発生する前に常に一致し、 `</cite> add_view``（少なくとも `` route_name``がないもの）によって登録されたビューを覆します。 A：class： <cite>〜pyramid.static.static_view`静的ビューは：term：</cite> Not Found View`として登録されていない限り、トラバーサルを使用するとroot相対にすることはできません。</p>
</div>
<p>ルーティングテーブルの最後にあるルートからハングする&amp;quot;catchall &amp;quot;ルートの結果として、ファイルシステム上にあるディレクトリ内のファイルを `` / path / to / static / dir``に提供するには、あなたのアプリケーションルートの `` static.py``ファイルの中で：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.static.static_view`クラスのインスタンスを作成します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">static_view</span>
<span class="n">static_view</span> <span class="o">=</span> <span class="n">static_view</span><span class="p">(</span><span class="s1">&#39;/path/to/static/dir&#39;</span><span class="p">,</span> <span class="n">use_subpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">クロスシステムの柔軟性を高めるために、物理的な絶対ファイルシステムパスの代わりに：class： <cite>〜pyramid.static.static_view`の引数として：term：</cite> asset specification`を使用してください。たとえば、 `` mypackage：static``の代わりに`` / path / to / mypackage / static``のようなものです。</p>
</div>
<p>その後、このビューで提供されるファイルを `` / &lt;filename&gt; <a href="#id1"><span class="problematic" id="id2">``</span></a>あなたのアプリケーションのスタートアップコードで設定メソッドを使います。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># .. every other add_route declaration should come</span>
<span class="c1"># before this one, as it will, by default, catch all requests</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;catchall_static&#39;</span><span class="p">,</span> <span class="s1">&#39;/*subpath&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.static.static_view&#39;</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;catchall_static&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上の特別な名前 `` * subpath``は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.static.static_view`ビューによって呼び出され、あなたが提供しているディレクトリを基準にファイルのパスを指定します。</p>
</div>
<div class="section" id="registering-a-view-callable-to-serve-a-static-asset">
<h3>&amp;quot;スタティック&amp;quot;アセットを表示するためのビュー呼び出し可能の登録<a class="headerlink" href="#registering-a-view-callable-to-serve-a-static-asset" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>単一の静的資産を提供するために呼び出し可能な単純ビューを登録することができます。そうするには、手で&amp;quot;手で行います。まず、呼び出し可能なビューを定義します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">FileResponse</span>

<span class="k">def</span> <span class="nf">favicon_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">here</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">icon</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="s1">&#39;favicon.ico&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FileResponse</span><span class="p">(</span><span class="n">icon</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>`` favicon_view``内の上記のコードは&amp;quot;here &amp;quot;を計算します。これは関数が定義されているPythonファイルを基準とした相対パスです。次に、レスポンスの `` path``引数としてファイルパスを使用し、レスポンスの `` request``引数として要求を使用して：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.response.FileResponse`を作成します。 ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>pyramid.response.FileResponse`は、このように使用されたときにできるだけ早くファイルを提供します。渡すファイルのファイル拡張子に基づいて、正しいコンテンツの長さとcontent_typeを設定します。</p>
<p>このようなビューは、トラバーサルの結果として呼び出されるビュー呼び出し可能として構成によって登録することができます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.views.favicon_view&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;favicon.ico&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>または、特定のルートで呼び出し可能なビューに登録することもできます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;favicon&#39;</span><span class="p">,</span> <span class="s1">&#39;/favicon.ico&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="s1">&#39;myapp.views.favicon_view&#39;</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;favicon&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>これは呼び出し可能な単純なビューなので、：term： <cite>permission`で保護することも、term：</cite> view predicate`引数を使って異なる状況下で応答するように設定することもできます。</p>
</div>
</div>
<div class="section" id="overriding-assets">
<span id="overriding-assets-section"></span><span id="index-6"></span><h2>アセットのオーバーライド<a class="headerlink" href="#overriding-assets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>特定の資産をapp： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションの外から上書きすると便利なことがよくあります。たとえば、既存の：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`アプリケーションを多かれ少なかれ変更せずに再利用することができます。ただし、アプリケーションが所有する特定のテンプレートファイルの中に不適切なHTMLが含まれている場合や、スタティックアセット（ロゴファイルやCSSファイルなど）が適切でない場合があります。アプリケーションを完全にフォークすることはできますが、不適切なアセットをオーバーライドしてアプリケーションをそのまま使用すると便利です。これは、いくつかの顧客（CMSアプリケーションやバグ追跡アプリケーションなど）のためにいくつかの&amp;quot;コア&amp;quot;アプリケーションを何度も何度も何度も再利用し、特定のアプリケーションデプロイメントに対して任意の視覚的な変更を加えたい場合に特に当てはまります基礎となるコードをフォークすることなく。</p>
<p>この目的のために、：app： <cite>Pyramid`には、ある資産を1つ以上の他の資産と&amp;quot;上書き &amp;quot;する機能を含みます。この機能をサポートするために、a：term： `Configurator</cite> APIが存在します：meth：` pyramid.config.Configurator.override_asset`。このAPIを使用すると、任意のPythonパッケージで定義された次の種類のアセットをオーバーライドできます。</p>
<ul class="simple">
<li>個々のテンプレートファイル。</li>
<li>複数のテンプレートファイルを含むディレクトリ。</li>
<li>個々の静的ファイルは、 `` pyramid.static.static_view``ヘルパークラスのインスタンスによって提供されます。</li>
<li>静的ファイルのディレクトリで、 `` pyramid.static.static_view``ヘルパークラスのインスタンスによって提供されます。</li>
<li>setuptools：term： <cite>pkg_resources</cite> APIを使用するコードで扱われるその他のアセット（またはアセットのセット）。</li>
</ul>
<div class="section" id="the-override-asset-api">
<span id="override-asset"></span><span id="index-7"></span><h3>`` override_asset`` API<a class="headerlink" href="#the-override-asset-api" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.override_asset`を個別に呼び出すと、単一のアセットをオーバーライドできます。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span>
    <span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package:templates/mytemplate.pt&#39;</span><span class="p">,</span>
    <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:othertemplates/anothertemplate.pt&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>`` override_asset`` APIに送られる `` to_override``と `` override_with``の両方に渡される文字列値は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>asset specification`と呼ばれます。仕様のコロン区切り記号は、<a href="#id3"><span class="problematic" id="id4">*</span></a>パッケージ名*を*資産名*から分離します。コロンと次のアセット名はオプションです。それらが指定されていない場合、オーバーライドは別のパッケージのディレクトリからパッケージへのすべてのルックアップを解決しようとします。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>パッケージ内の個々のサブディレクトリも上書きできます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;some.package:templates/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:othertemplates/&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>ディレクトリを別のディレクトリで上書きする場合は、スラッシュを `` to_override``仕様と `` override_with``仕様の両方の末尾に付ける必要があります。ディレクトリを指す指定の最後にスラッシュを付けると、予期しない結果が発生します。</p>
<p>ディレクトリ指定をファイル指定で上書きすることはできません。逆もできません。試してみると起動エラーが発生します。アセット自体をオーバーライドすることはできません。試してみると起動エラーが発生します。</p>
<p>個々の* package <a href="#id1"><span class="problematic" id="id2">*</span></a>アセットだけがオーバーライドされます。オーバーライドは、オーバーライドされたパッケージ内のサブパッケージを通過しません。これは、 `` some.package：templates``と `` some.package.views：templates``の両方のアセットをオーバーライドする場合、2つのオーバーライドを登録する必要があることを意味します。</p>
<p>仕様のパッケージ名は、ドットで始まることがあります。これは、パッケージがコンフィギュレーション構築ファイルが存在するパッケージ（または：class： <cite>〜pyramid.config.Configurator`の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>package``引数）に相対的であることを意味します。クラス構造）。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span><span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;.subpackage:templates/&#39;</span><span class="p">,</span>
                      <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;another.package:templates/&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>共有された `` to_override``を指定するが、別の `` override_with``を指定する `` override_asset``への複数の呼び出しは、検索パスを形成するためにスタックされます。検索パスに存在する最初のアセットが使用されます。上書きパスに資産が存在しない場合は、元の資産が使用されます。</p>
<p>資産オーバーライドは、テンプレートや静的ファイル以外の資産を実際にオーバーライドできます。 ：func： <cite>pkg_resources.get_resource_filename</cite>、：func：` pkg_resources.get_resource_stream`、または：func： <cite>pkg_resources.get_resource_string</cite> APIを使用するソフトウェアは、オーバーライドが使用されるときにオーバーライドされたファイルを取得します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加: </span>Pyramid 1.6以降では、ファイルまたはディレクトリへの絶対パスを指定することでアセットをオーバーライドすることもできます。これは、アセットがPythonパッケージの一部として配布されていない場合に便利です。</p>
</div>
</div>
<div class="section" id="cache-busting-and-asset-overrides">
<h3>キャッシュバストと資産のオーバーライド<a class="headerlink" href="#cache-busting-and-asset-overrides" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>pyramid.config.Configurator.add_static_view`を使用してホストされている静的アセットをオーバーライドすると、class：</cite> pyramid.static.ManifestCacheBuster`のようなアセット対応のキャッシュバスターを使用するときのキャッシュ破棄戦略に影響を与える可能性があります。アセット・アウェア・キャッシュ・バスターは、ロジックを特定のアセットに結び付けている点で違いがあります。たとえば、マニフェストは、事前定義された特定のアセットのセットに対してのみ生成されます。今、このマニフェストで定義されたアセットを、新しい未知のバージョンで上書きしたとします。デフォルトでは、これまでに見たことがないアセットに対してキャッシュバスターが呼び出され、実際に配信されるアセットではなく、元のアセットのキャッシュ破棄トークンが返される可能性があります。この問題を回避するために、異なる：class： <cite>pyramid.interfaces.ICacheBuster`実装を新しいアセットに付加することが可能です。これにより、元のアセットはマニフェストによって提供され、新しいアセットは独自のキャッシュ・バスターによって提供されます。これを行うには：meth： `pyramid.config.Configurator.add_cache_buster`は</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>explicit``オプションをサポートしています。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.static</span> <span class="kn">import</span> <span class="n">ManifestCacheBuster</span>

<span class="c1"># define a static view for myapp:static assets</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_static_view</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="s1">&#39;myapp:static&#39;</span><span class="p">)</span>

<span class="c1"># setup a cache buster for your app based on the myapp:static assets</span>
<span class="n">my_cb</span> <span class="o">=</span> <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;myapp:static/manifest.json&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span><span class="s1">&#39;myapp:static&#39;</span><span class="p">,</span> <span class="n">my_cb</span><span class="p">)</span>

<span class="c1"># override an asset</span>
<span class="n">config</span><span class="o">.</span><span class="n">override_asset</span><span class="p">(</span>
    <span class="n">to_override</span><span class="o">=</span><span class="s1">&#39;myapp:static/background.png&#39;</span><span class="p">,</span>
    <span class="n">override_with</span><span class="o">=</span><span class="s1">&#39;theme:static/background.png&#39;</span><span class="p">)</span>

<span class="c1"># override the cache buster for theme:static assets</span>
<span class="n">theme_cb</span> <span class="o">=</span> <span class="n">ManifestCacheBuster</span><span class="p">(</span><span class="s1">&#39;theme:static/manifest.json&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_cache_buster</span><span class="p">(</span><span class="s1">&#39;theme:static&#39;</span><span class="p">,</span> <span class="n">theme_cb</span><span class="p">,</span> <span class="n">explicit</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の例では、 `` myapp：static``フォルダから提供されるすべてのアセットに対して、デフォルトのキャッシュ・バスター、 `` my_cb``があります。これは、 `` request.static_url（ &amp;#39;myapp：static / background.png&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>でURLを生成するときに `` theme：static / background.png``にも影響します。</p>
<p>`` theme_cb``は `` theme：static``フォルダから読み込まれたアセットに対して明示的に定義されています。明示的なキャッシュバスターは優先順位があり、 `` request.static_url（ &amp;#39;myapp：static / background.png&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>に対して `` theme_cb``が呼び出されますが、 `` my_cb``は ` <cite>request.static_url（ &amp;#39;myapp：static / favicon.ico&amp;#39;）</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>です。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">(機械翻訳) 静的資産</a><ul>
<li><a class="reference internal" href="#understanding-asset-specifications">資産の仕様の理解</a></li>
<li><a class="reference internal" href="#serving-static-assets">静的資産の提供</a><ul>
<li><a class="reference internal" href="#generating-static-asset-urls">静的資産URLの生成</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-busting">キャッシュバスト</a><ul>
<li><a class="reference internal" href="#disabling-the-cache-buster">キャッシュ・バスターの無効化</a></li>
<li><a class="reference internal" href="#customizing-the-cache-buster">キャッシュ・バスターのカスタマイズ</a></li>
<li><a class="reference internal" href="#path-segments-and-choosing-a-cache-buster">パスセグメントとキャッシュバスターの選択</a></li>
<li><a class="reference internal" href="#css-and-javascript-source-and-cache-busting">CSSとJavaScriptのソースとキャッシュの破棄</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-serving-static-assets-using-a-view-callable">上級者：ビューコールバックを使用した静的資産の処理</a><ul>
<li><a class="reference internal" href="#root-relative-custom-static-view-url-dispatch-only">ルート関連のカスタムスタティックビュー（URLディスパッチのみ）</a></li>
<li><a class="reference internal" href="#registering-a-view-callable-to-serve-a-static-asset">&amp;quot;スタティック&amp;quot;アセットを表示するためのビュー呼び出し可能の登録</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overriding-assets">アセットのオーバーライド</a><ul>
<li><a class="reference internal" href="#the-override-asset-api">`` override_asset`` API</a></li>
<li><a class="reference internal" href="#cache-busting-and-asset-overrides">キャッシュバストと資産のオーバーライド</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="viewconfig.html"
                        title="前の章へ">(機械翻訳) 設定を表示</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="webob.html"
                        title="次の章へ">(機械翻訳) 要求オブジェクトと応答オブジェクト</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/narr/assets.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="webob.html" title="(機械翻訳) 要求オブジェクトと応答オブジェクト"
             >次へ</a> |</li>
        <li class="right" >
          <a href="viewconfig.html" title="(機械翻訳) 設定を表示"
             >前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 11月 03, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 で生成しました。
    </div>
  </body>
</html>
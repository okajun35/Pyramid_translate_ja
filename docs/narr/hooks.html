
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Using Hooks &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="Pyramid Configuration Introspection" href="introspector.html" />
    <link rel="prev" title="Invoking a Subrequest" href="subrequest.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="introspector.html" title="Pyramid Configuration Introspection"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="subrequest.html" title="Invoking a Subrequest"
             accesskey="P">前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-hooks">
<span id="hooks-chapter"></span><h1>Using Hooks<a class="headerlink" href="#using-hooks" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>&quot;Hooks&quot; can be used to influence the behavior of the <span>Pyramid</span> framework
in various ways.</p>
<div class="section" id="changing-the-not-found-view">
<span id="changing-the-notfound-view"></span><span id="index-0"></span><h2>Changing the Not Found View<a class="headerlink" href="#changing-the-not-found-view" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When <span>Pyramid</span> can't map a URL to view code, it invokes a <a class="reference internal" href="../glossary.html#term-not-found-view"><span class="xref std std-term">Not Found
View</span></a>, which is a <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>. The default Not Found View can be
overridden through application configuration.</p>
<p>If your application uses <a class="reference internal" href="../glossary.html#term-imperative-configuration"><span class="xref std std-term">imperative configuration</span></a>, you can replace the
Not Found View by using the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></code></a> method:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Not Found&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_notfound_view</span><span class="p">(</span><span class="n">notfound</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The <a class="reference internal" href="../glossary.html#term-not-found-view"><span class="xref std std-term">Not Found View</span></a> callable is a view callable like any other.</p>
<p>If your application instead uses <a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.view_config</span></code></a> decorators
and a <a class="reference internal" href="../glossary.html#term-scan"><span class="xref std std-term">scan</span></a>, you can replace the Not Found View by using the
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.notfound_view_config</span></code></a> decorator:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">notfound_view_config</span>

<span class="nd">@notfound_view_config</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Not Found&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>This does exactly what the imperative example above showed.</p>
<p>Your application can define <em>multiple</em> Not Found Views if necessary.  Both
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></code></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.notfound_view_config</span></code></a> take most of the same arguments as
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view</span></code></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.view_config</span></code></a>, respectively.  This means that Not Found
Views can carry predicates limiting their applicability.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">notfound_view_config</span>

<span class="nd">@notfound_view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s1">&#39;GET&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notfound_get</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Not Found during GET&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="nd">@notfound_view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">notfound_post</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Not Found during POST&#39;</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s1">&#39;404 Not Found&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
   <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">notfound_get</span></code> view will be called when a view could not be found and the
request method was <code class="docutils literal notranslate"><span class="pre">GET</span></code>.  The <code class="docutils literal notranslate"><span class="pre">notfound_post</span></code> view will be called when a
view could not be found and the request method was <code class="docutils literal notranslate"><span class="pre">POST</span></code>.</p>
<p>Like any other view, the Not Found View must accept at least a <code class="docutils literal notranslate"><span class="pre">request</span></code>
parameter, or both <code class="docutils literal notranslate"><span class="pre">context</span></code> and <code class="docutils literal notranslate"><span class="pre">request</span></code>.  The <code class="docutils literal notranslate"><span class="pre">request</span></code> is the current
<a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a> representing the denied action.  The <code class="docutils literal notranslate"><span class="pre">context</span></code> (if used in
the call signature) will be the instance of the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPNotFound</span></code></a> exception that caused the view to
be called.</p>
<p>Both <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_notfound_view" title="pyramid.config.Configurator.add_notfound_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_notfound_view()</span></code></a> and
<a class="reference internal" href="../api/view.html#pyramid.view.notfound_view_config" title="pyramid.view.notfound_view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.notfound_view_config</span></code></a> can be used to automatically
redirect requests to slash-appended routes. See
<a class="reference internal" href="urldispatch.html#redirecting-to-slash-appended-routes"><span class="std std-ref">Redirecting to Slash-Appended Routes</span></a> for examples.</p>
<p>Here's some sample code that implements a minimal <a class="reference internal" href="../glossary.html#term-not-found-view"><span class="xref std std-term">Not Found View</span></a>
callable:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.httpexceptions</span> <span class="kn">import</span> <span class="n">HTTPNotFound</span>

<span class="k">def</span> <span class="nf">notfound</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HTTPNotFound</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When a Not Found View callable is invoked, it is passed a <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a>.
The <code class="docutils literal notranslate"><span class="pre">exception</span></code> attribute of the request will be an instance of the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPNotFound</span></code></a> exception that caused the Not
Found View to be called.  The value of <code class="docutils literal notranslate"><span class="pre">request.exception.message</span></code> will be
a value explaining why the Not Found exception was raised.  This message has
different values depending on whether the <code class="docutils literal notranslate"><span class="pre">pyramid.debug_notfound</span></code>
environment setting is true or false.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When a Not Found View callable accepts an argument list as described in
<a class="reference internal" href="views.html#request-and-context-view-definitions"><span class="std std-ref">Alternate View Callable Argument/Calling Conventions</span></a>, the <code class="docutils literal notranslate"><span class="pre">context</span></code> passed as the
first argument to the view callable will be the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPNotFound</span></code></a> exception instance.  If
available, the resource context will still be available as
<code class="docutils literal notranslate"><span class="pre">request.context</span></code>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The <a class="reference internal" href="../glossary.html#term-not-found-view"><span class="xref std std-term">Not Found View</span></a> callables are only invoked when a
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPNotFound" title="pyramid.httpexceptions.HTTPNotFound"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPNotFound</span></code></a> exception is raised. If the
exception is returned from a view then it will be treated as a regular
response object and it will not trigger the custom view.</p>
</div>
</div>
<div class="section" id="changing-the-forbidden-view">
<span id="index-1"></span><span id="id1"></span><h2>Changing the Forbidden View<a class="headerlink" href="#changing-the-forbidden-view" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When <span>Pyramid</span> can't authorize execution of a view based on the
<a class="reference internal" href="../glossary.html#term-authorization-policy"><span class="xref std std-term">authorization policy</span></a> in use, it invokes a <a class="reference internal" href="../glossary.html#term-forbidden-view"><span class="xref std std-term">forbidden view</span></a>. The
default forbidden response has a 403 status code and is very plain, but the
view which generates it can be overridden as necessary.</p>
<p>The <a class="reference internal" href="../glossary.html#term-forbidden-view"><span class="xref std std-term">forbidden view</span></a> callable is a view callable like any other.  The
<a class="reference internal" href="../glossary.html#term-view-configuration"><span class="xref std std-term">view configuration</span></a> which causes it to be a &quot;forbidden&quot; view consists of
using the <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_forbidden_view" title="pyramid.config.Configurator.add_forbidden_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_forbidden_view()</span></code></a> API or the
<a class="reference internal" href="../api/view.html#pyramid.view.forbidden_view_config" title="pyramid.view.forbidden_view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.forbidden_view_config</span></code></a> decorator.</p>
<p>For example, you can add a forbidden view by using the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_forbidden_view" title="pyramid.config.Configurator.add_forbidden_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_forbidden_view()</span></code></a> method to register a
forbidden view:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;forbidden&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_forbidden_view</span><span class="p">(</span><span class="n">forbidden</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If instead you prefer to use decorators and a <a class="reference internal" href="../glossary.html#term-scan"><span class="xref std std-term">scan</span></a>, you can use the
<a class="reference internal" href="../api/view.html#pyramid.view.forbidden_view_config" title="pyramid.view.forbidden_view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.view.forbidden_view_config</span></code></a> decorator to mark a view callable
as a forbidden view:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">forbidden_view_config</span>

<span class="nd">@forbidden_view_config</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;forbidden&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="nb">globals</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
   <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
   <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>Like any other view, the forbidden view must accept at least a <code class="docutils literal notranslate"><span class="pre">request</span></code>
parameter, or both <code class="docutils literal notranslate"><span class="pre">context</span></code> and <code class="docutils literal notranslate"><span class="pre">request</span></code>.  If a forbidden view callable
accepts both <code class="docutils literal notranslate"><span class="pre">context</span></code> and <code class="docutils literal notranslate"><span class="pre">request</span></code>, the HTTP Exception is passed as
context. The <code class="docutils literal notranslate"><span class="pre">context</span></code> as found by the router when the view was denied (which
you normally would expect) is available as <code class="docutils literal notranslate"><span class="pre">request.context</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">request</span></code> is the  current <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a> representing the denied action.</p>
<p>Here's some sample code that implements a minimal forbidden view:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">forbidden_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;forbidden&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When a forbidden view callable is invoked, it is passed a <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a>.
The <code class="docutils literal notranslate"><span class="pre">exception</span></code> attribute of the request will be an instance of the
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPForbidden" title="pyramid.httpexceptions.HTTPForbidden"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPForbidden</span></code></a> exception that caused the
forbidden view to be called.  The value of <code class="docutils literal notranslate"><span class="pre">request.exception.message</span></code>
will be a value explaining why the forbidden exception was raised, and
<code class="docutils literal notranslate"><span class="pre">request.exception.result</span></code> will be extended information about the
forbidden exception.  These messages have different values depending on
whether the <code class="docutils literal notranslate"><span class="pre">pyramid.debug_authorization</span></code> environment setting is true or
false.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The <a class="reference internal" href="../glossary.html#term-forbidden-view"><span class="xref std std-term">forbidden view</span></a> callables are only invoked when a
<a class="reference internal" href="../api/httpexceptions.html#pyramid.httpexceptions.HTTPForbidden" title="pyramid.httpexceptions.HTTPForbidden"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPForbidden</span></code></a> exception is raised. If the
exception is returned from a view then it will be treated as a regular
response object and it will not trigger the custom view.</p>
</div>
</div>
<div class="section" id="changing-the-request-factory">
<span id="index-2"></span><span id="id2"></span><h2>Changing the Request Factory<a class="headerlink" href="#changing-the-request-factory" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Whenever <span>Pyramid</span> handles a request from a <a class="reference internal" href="../glossary.html#term-wsgi"><span class="xref std std-term">WSGI</span></a> server, it
creates a <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a> object based on the WSGI environment it has been
passed.  By default, an instance of the <a class="reference internal" href="../api/request.html#pyramid.request.Request" title="pyramid.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.request.Request</span></code></a> class
is created to represent the request object.</p>
<p>The class (a.k.a., &quot;factory&quot;) that <span>Pyramid</span> uses to create a request
object instance can be changed by passing a <code class="docutils literal notranslate"><span class="pre">request_factory</span></code> argument to the
constructor of the <a class="reference internal" href="../glossary.html#term-configurator"><span class="xref std std-term">configurator</span></a>.  This argument can be either a
callable or a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a> representing a callable.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">class</span> <span class="nc">MyRequest</span><span class="p">(</span><span class="n">Request</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">(</span><span class="n">request_factory</span><span class="o">=</span><span class="n">MyRequest</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If you're doing imperative configuration, and you'd rather do it after you've
already constructed a <a class="reference internal" href="../glossary.html#term-configurator"><span class="xref std std-term">configurator</span></a>, it can also be registered via the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_request_factory" title="pyramid.config.Configurator.set_request_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.set_request_factory()</span></code></a> method:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">class</span> <span class="nc">MyRequest</span><span class="p">(</span><span class="n">Request</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">set_request_factory</span><span class="p">(</span><span class="n">MyRequest</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="adding-methods-or-properties-to-a-request-object">
<span id="adding-request-method"></span><span id="index-3"></span><h2>Adding Methods or Properties to a Request Object<a class="headerlink" href="#adding-methods-or-properties-to-a-request-object" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.4 で追加.</span></p>
</div>
<p>Since each Pyramid application can only have one <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a> factory,
<a class="reference internal" href="#changing-the-request-factory"><span class="std std-ref">changing the request factory</span></a> is not that
extensible, especially if you want to build composable features (e.g., Pyramid
add-ons and plugins).</p>
<p>A lazy property can be registered to the request object via the
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_request_method" title="pyramid.config.Configurator.add_request_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_request_method()</span></code></a> API. This allows you to
specify a callable that will be available on the request object, but will not
actually execute the function until accessed.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">This will silently override methods and properties from <a class="reference internal" href="../glossary.html#term-request-factory"><span class="xref std std-term">request
factory</span></a> that have the same name.</p>
</div>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;getting the property&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;the property&quot;</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">total</span></code> is added as a method. However, <code class="docutils literal notranslate"><span class="pre">prop</span></code> is
added as a property and its result is cached per-request by setting
<code class="docutils literal notranslate"><span class="pre">reify=True</span></code>. This way, we eliminate the overhead of running the function
multiple times.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">prop</span>
<span class="go">getting the property</span>
<span class="go">&#39;the property&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">prop</span>
<span class="go">&#39;the property&#39;</span>
</pre></div>
</div>
<p>To not cache the result of <code class="docutils literal notranslate"><span class="pre">request.prop</span></code>, set <code class="docutils literal notranslate"><span class="pre">property=True</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">reify=True</span></code>.</p>
<p>Here is an example of passing a class to <code class="docutils literal notranslate"><span class="pre">Configurator.add_request_method</span></code>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.decorator</span> <span class="kn">import</span> <span class="n">reify</span>

<span class="k">class</span> <span class="nc">ExtraStuff</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span>

    <span class="k">def</span> <span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># use @property if you don&#39;t want to cache the result</span>
    <span class="nd">@reify</span>
    <span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;getting the property&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;the property&quot;</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_request_method</span><span class="p">(</span><span class="n">ExtraStuff</span><span class="p">,</span> <span class="s1">&#39;extra&#39;</span><span class="p">,</span> <span class="n">reify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>We attach and cache an object named <code class="docutils literal notranslate"><span class="pre">extra</span></code> to the <code class="docutils literal notranslate"><span class="pre">request</span></code> object.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">prop</span>
<span class="go">getting the property</span>
<span class="go">&#39;the property&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">prop</span>
<span class="go">&#39;the property&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="changing-the-response-factory">
<span id="index-4"></span><span id="id3"></span><h2>Changing the Response Factory<a class="headerlink" href="#changing-the-response-factory" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.6 で追加.</span></p>
</div>
<p>Whenever <span>Pyramid</span> returns a response from a view, it creates a
<a class="reference internal" href="../glossary.html#term-response"><span class="xref std std-term">response</span></a> object.  By default, an instance of the
<a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.Response</span></code></a> class is created to represent the response
object.</p>
<p>The factory that <span>Pyramid</span> uses to create a response object instance can
be changed by passing a <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponseFactory" title="pyramid.interfaces.IResponseFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IResponseFactory</span></code></a> argument
to the constructor of the <a class="reference internal" href="../glossary.html#term-configurator"><span class="xref std std-term">configurator</span></a>.  This argument can be either a
callable or a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a> representing a callable.</p>
<p>The factory takes a single positional argument, which is a <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">Request</span></a>
object. The argument may be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">class</span> <span class="nc">MyResponse</span><span class="p">(</span><span class="n">Response</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">(</span><span class="n">response_factory</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">MyResponse</span><span class="p">())</span>
</pre></div>
</td></tr></table></div>
<p>If you're doing imperative configuration and you'd rather do it after you've
already constructed a <a class="reference internal" href="../glossary.html#term-configurator"><span class="xref std std-term">configurator</span></a>, it can also be registered via the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.set_response_factory()</span></code> method:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">class</span> <span class="nc">MyResponse</span><span class="p">(</span><span class="n">Response</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">set_response_factory</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">MyResponse</span><span class="p">())</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="using-the-before-render-event">
<span id="beforerender-event"></span><span id="index-5"></span><h2>Using the Before Render Event<a class="headerlink" href="#using-the-before-render-event" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Subscribers to the <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.BeforeRender</span></code></a> event may introspect
and modify the set of <a class="reference internal" href="../glossary.html#term-renderer-globals"><span class="xref std std-term">renderer globals</span></a> before they are passed to a
<a class="reference internal" href="../glossary.html#term-renderer"><span class="xref std std-term">renderer</span></a>.  This event object iself has a dictionary-like interface that
can be used for this purpose.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>
<span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">BeforeRender</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">BeforeRender</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_global</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="p">[</span><span class="s1">&#39;mykey&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
</pre></div>
</td></tr></table></div>
<p>An object of this type is sent as an event just before a <a class="reference internal" href="../glossary.html#term-renderer"><span class="xref std std-term">renderer</span></a> is
invoked.</p>
<p>If a subscriber attempts to add a key that already exists in the renderer
globals dictionary, a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> is raised.  This limitation is enforced
because event subscribers do not possess any relative ordering.  The set of
keys added to the renderer globals dictionary by all
<a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.BeforeRender</span></code></a> subscribers and renderer globals factories
must be unique.</p>
<p>The dictionary returned from the view is accessible through the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">rendering_val</span></code> attribute of a <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeforeRender</span></code></a>
event.</p>
<p>Suppose you return <code class="docutils literal notranslate"><span class="pre">{'mykey':</span> <span class="pre">'somevalue',</span> <span class="pre">'mykey2':</span> <span class="pre">'somevalue2'}</span></code> from your
view callable, like so:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.view</span> <span class="kn">import</span> <span class="n">view_config</span>

<span class="nd">@view_config</span><span class="p">(</span><span class="n">renderer</span><span class="o">=</span><span class="s1">&#39;some_renderer&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">myview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;mykey&#39;</span><span class="p">:</span> <span class="s1">&#39;somevalue&#39;</span><span class="p">,</span> <span class="s1">&#39;mykey2&#39;</span><span class="p">:</span> <span class="s1">&#39;somevalue2&#39;</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">rendering_val</span></code> can be used to access these values from the
<a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeforeRender</span></code></a> object:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>
<span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">BeforeRender</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">BeforeRender</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_return</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c1"># {&#39;mykey&#39;: &#39;somevalue&#39;} is returned from the view</span>
    <span class="k">print</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">rendering_val</span><span class="p">[</span><span class="s1">&#39;mykey&#39;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
<p>See the API documentation for the <a class="reference internal" href="../api/events.html#pyramid.events.BeforeRender" title="pyramid.events.BeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">BeforeRender</span></code></a> event
interface at <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IBeforeRender" title="pyramid.interfaces.IBeforeRender"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IBeforeRender</span></code></a>.</p>
</div>
<div class="section" id="using-response-callbacks">
<span id="index-6"></span><span id="id4"></span><h2>Using Response Callbacks<a class="headerlink" href="#using-response-callbacks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Unlike many other web frameworks, <span>Pyramid</span> does not eagerly create a
global response object.  Adding a <a class="reference internal" href="../glossary.html#term-response-callback"><span class="xref std std-term">response callback</span></a> allows an
application to register an action to be performed against whatever response
object is returned by a view, usually in order to mutate the response.</p>
<p>The <a class="reference internal" href="../api/request.html#pyramid.request.Request.add_response_callback" title="pyramid.request.Request.add_response_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.add_response_callback()</span></code></a> method is used to
register a response callback.</p>
<p>A response callback is a callable which accepts two positional parameters:
<code class="docutils literal notranslate"><span class="pre">request</span></code> and <code class="docutils literal notranslate"><span class="pre">response</span></code>.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cache_callback</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the cache_control max_age for the response&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">exception</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">cache_control</span><span class="o">.</span><span class="n">max_age</span> <span class="o">=</span> <span class="mi">360</span>
<span class="n">request</span><span class="o">.</span><span class="n">add_response_callback</span><span class="p">(</span><span class="n">cache_callback</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>No response callback is called if an unhandled exception happens in application
code, or if the response object returned by a <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a> is invalid.
Response callbacks <em>are</em>, however, invoked when a <a class="reference internal" href="../glossary.html#term-exception-view"><span class="xref std std-term">exception view</span></a> is
rendered successfully.  In such a case, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">request.exception</span></code> attribute
of the request when it enters a response callback will be an exception object
instead of its default value of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Response callbacks are called in the order they're added
(first-to-most-recently-added).  All response callbacks are called <em>before</em> the
<a class="reference internal" href="../api/events.html#pyramid.events.NewResponse" title="pyramid.events.NewResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewResponse</span></code></a> event is sent.  Errors raised by response
callbacks are not handled specially.  They will be propagated to the caller of
the <span>Pyramid</span> router application.</p>
<p>A response callback has a lifetime of a <em>single</em> request.  If you want a
response callback to happen as the result of <em>every</em> request, you must
re-register the callback into every new request (perhaps within a subscriber of
a <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewRequest</span></code></a> event).</p>
</div>
<div class="section" id="using-finished-callbacks">
<span id="index-7"></span><span id="id5"></span><h2>Using Finished Callbacks<a class="headerlink" href="#using-finished-callbacks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A <a class="reference internal" href="../glossary.html#term-finished-callback"><span class="xref std std-term">finished callback</span></a> is a function that will be called unconditionally
by the <span>Pyramid</span> <a class="reference internal" href="../glossary.html#term-router"><span class="xref std std-term">router</span></a> at the very end of request processing. A
finished callback can be used to perform an action at the end of a request
unconditionally.</p>
<p>The <a class="reference internal" href="../api/request.html#pyramid.request.Request.add_finished_callback" title="pyramid.request.Request.add_finished_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.add_finished_callback()</span></code></a> method is used to
register a finished callback.</p>
<p>A finished callback is a callable which accepts a single positional parameter:
<code class="docutils literal notranslate"><span class="pre">request</span></code>.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">log_callback</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Log information at the end of request&quot;&quot;&quot;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Request is finished.&#39;</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">add_finished_callback</span><span class="p">(</span><span class="n">log_callback</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Finished callbacks are called in the order they're added
(first-to-most-recently-added).  Finished callbacks (unlike a <a class="reference internal" href="../glossary.html#term-response-callback"><span class="xref std std-term">response
callback</span></a>) are <em>always</em> called, even if an exception happens in application
code that prevents a response from being generated.</p>
<p>The set of finished callbacks associated with a request are called <em>very late</em>
in the processing of that request; they are essentially the very last thing
called by the <a class="reference internal" href="../glossary.html#term-router"><span class="xref std std-term">router</span></a> before a request &quot;ends&quot;. They are called after
response processing has already occurred in a top-level <code class="docutils literal notranslate"><span class="pre">finally:</span></code> block
within the router request processing code.  As a result, mutations performed to
the <code class="docutils literal notranslate"><span class="pre">request</span></code> provided to a finished callback will have no meaningful effect,
because response processing will have already occurred, and the request's scope
will expire almost immediately after all finished callbacks have been
processed.</p>
<p>Errors raised by finished callbacks are not handled specially.  They will be
propagated to the caller of the <span>Pyramid</span> router application.</p>
<p>A finished callback has a lifetime of a <em>single</em> request.  If you want a
finished callback to happen as the result of <em>every</em> request, you must
re-register the callback into every new request (perhaps within a subscriber of
a <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewRequest</span></code></a> event).</p>
</div>
<div class="section" id="changing-the-traverser">
<span id="index-8"></span><span id="id6"></span><h2>Changing the Traverser<a class="headerlink" href="#changing-the-traverser" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The default <a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">traversal</span></a> algorithm that <span>Pyramid</span> uses is explained
in <a class="reference internal" href="traversal.html#traversal-algorithm"><span class="std std-ref">The Traversal Algorithm</span></a>.  Though it is rarely necessary, this default
algorithm can be swapped out selectively for a different traversal pattern via
configuration.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">Traverser</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_traverser</span><span class="p">(</span><span class="n">Traverser</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">myapp.traversal.Traverser</span></code> is assumed to be a class
that implements the following interface:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Traverser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Accept the root object returned from the root factory &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a dictionary with (at least) the keys ``root``,</span>
<span class="sd">        ``context``, ``view_name``, ``subpath``, ``traversed``,</span>
<span class="sd">        ``virtual_root``, and ``virtual_root_path``.  These values are</span>
<span class="sd">        typically the result of a resource tree traversal.  ``root``</span>
<span class="sd">        is the physical root object, ``context`` will be a resource</span>
<span class="sd">        object, ``view_name`` will be the view name used (a Unicode</span>
<span class="sd">        name), ``subpath`` will be a sequence of Unicode names that</span>
<span class="sd">        followed the view name but were not traversed, ``traversed``</span>
<span class="sd">        will be a sequence of Unicode names that were traversed</span>
<span class="sd">        (including the virtual root path, if any) ``virtual_root``</span>
<span class="sd">        will be a resource object representing the virtual root (or the</span>
<span class="sd">        physical root if traversal was not performed), and</span>
<span class="sd">        ``virtual_root_path`` will be a sequence representing the</span>
<span class="sd">        virtual root path (a sequence of Unicode names) or None if</span>
<span class="sd">        traversal was not performed.</span>

<span class="sd">        Extra keys for special purpose functionality can be added as</span>
<span class="sd">        necessary.</span>

<span class="sd">        All values returned in the dictionary will be made available</span>
<span class="sd">        as attributes of the ``request`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</pre></div>
</td></tr></table></div>
<p>More than one traversal algorithm can be active at the same time.  For
instance, if your <a class="reference internal" href="../glossary.html#term-root-factory"><span class="xref std std-term">root factory</span></a> returns more than one type of object
conditionally, you could claim that an alternative traverser adapter is &quot;for&quot;
only one particular class or interface.  When the root factory returned an
object that implemented that class or interface, a custom traverser would be
used.  Otherwise the default traverser would be used.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">Traverser</span>
<span class="kn">from</span> <span class="nn">myapp.resources</span> <span class="kn">import</span> <span class="n">MyRoot</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_traverser</span><span class="p">(</span><span class="n">Traverser</span><span class="p">,</span> <span class="n">MyRoot</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If the above stanza was added to a Pyramid <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file's <code class="docutils literal notranslate"><span class="pre">main</span></code>
function, <span>Pyramid</span> would use the <code class="docutils literal notranslate"><span class="pre">myapp.traversal.Traverser</span></code> only when
the application <a class="reference internal" href="../glossary.html#term-root-factory"><span class="xref std std-term">root factory</span></a> returned an instance of the
<code class="docutils literal notranslate"><span class="pre">myapp.resources.MyRoot</span></code> object.  Otherwise it would use the default
<span>Pyramid</span> traverser to do traversal.</p>
</div>
<div class="section" id="changing-how-pyramid-request-request-resource-url-generates-a-url">
<span id="changing-resource-url"></span><span id="index-9"></span><h2>Changing How <a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.resource_url()</span></code></a> Generates a URL<a class="headerlink" href="#changing-how-pyramid-request-request-resource-url-generates-a-url" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When you add a traverser as described in <a class="reference internal" href="#changing-the-traverser"><span class="std std-ref">Changing the Traverser</span></a>, it's
often convenient to continue to use the
<a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.request.Request.resource_url()</span></code></a> API.  However, since the way
traversal is done will have been modified, the URLs it generates by default may
be incorrect when used against resources derived from your custom traverser.</p>
<p>If you've added a traverser, you can change how
<a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resource_url()</span></code></a> generates a URL for a specific
type of resource by adding a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_resource_url_adapter" title="pyramid.config.Configurator.add_resource_url_adapter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_resource_url_adapter()</span></code></a>.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myapp.traversal</span> <span class="kn">import</span> <span class="n">ResourceURLAdapter</span>
<span class="kn">from</span> <span class="nn">myapp.resources</span> <span class="kn">import</span> <span class="n">MyRoot</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_resource_url_adapter</span><span class="p">(</span><span class="n">ResourceURLAdapter</span><span class="p">,</span> <span class="n">MyRoot</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, the <code class="docutils literal notranslate"><span class="pre">myapp.traversal.ResourceURLAdapter</span></code> class will be
used to provide services to <a class="reference internal" href="../api/request.html#pyramid.request.Request.resource_url" title="pyramid.request.Request.resource_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resource_url()</span></code></a> any
time the <a class="reference internal" href="../glossary.html#term-resource"><span class="xref std std-term">resource</span></a> passed to <code class="docutils literal notranslate"><span class="pre">resource_url</span></code> is of the class
<code class="docutils literal notranslate"><span class="pre">myapp.resources.MyRoot</span></code>.  The <code class="docutils literal notranslate"><span class="pre">resource_iface</span></code> argument <code class="docutils literal notranslate"><span class="pre">MyRoot</span></code>
represents the type of interface that must be possessed by the resource for
this resource url factory to be found.  If the <code class="docutils literal notranslate"><span class="pre">resource_iface</span></code> argument is
omitted, this resource URL adapter will be used for <em>all</em> resources.</p>
<p>The API that must be implemented by a class that provides
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResourceURL" title="pyramid.interfaces.IResourceURL"><code class="xref py py-class docutils literal notranslate"><span class="pre">IResourceURL</span></code></a> is as follows:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyResourceURL</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An adapter which provides the virtual and physical paths of a</span>
<span class="sd">        resource</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Accept the resource and request and set self.physical_path and</span>
<span class="sd">        self.virtual_path &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtual_path</span> <span class="o">=</span>  <span class="n">some_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">virtual_path_tuple</span> <span class="o">=</span>  <span class="n">some_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physical_path</span> <span class="o">=</span>  <span class="n">some_other_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physical_path_tuple</span> <span class="o">=</span>  <span class="n">some_function_of</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The default context URL generator is available for perusal as the class
<code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.traversal.ResourceURL</span></code> in the <a class="reference external" href="https://github.com/Pylons/pyramid/blob/master/pyramid/traversal.py">traversal module</a> of the
<a class="reference internal" href="../glossary.html#term-pylons"><span class="xref std std-term">Pylons</span></a> GitHub Pyramid repository.</p>
<p>See <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_resource_url_adapter" title="pyramid.config.Configurator.add_resource_url_adapter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_resource_url_adapter()</span></code></a> for more
information.</p>
</div>
<div class="section" id="changing-how-pyramid-treats-view-responses">
<span id="using-iresponse"></span><span id="index-10"></span><h2>Changing How Pyramid Treats View Responses<a class="headerlink" href="#changing-how-pyramid-treats-view-responses" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<p>It is possible to control how Pyramid treats the result of calling a view
callable on a per-type basis by using a hook involving
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_response_adapter" title="pyramid.config.Configurator.add_response_adapter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_response_adapter()</span></code></a> or the
<a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">response_adapter</span></code></a> decorator.</p>
<p>Pyramid, in various places, adapts the result of calling a view callable to the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">IResponse</span></code></a> interface to ensure that the object
returned by the view callable is a &quot;true&quot; response object.  The vast majority
of time, the result of this adaptation is the result object itself, as view
callables written by &quot;civilians&quot; who read the narrative documentation contained
in this manual will always return something that implements the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">IResponse</span></code></a> interface.  Most typically, this will be
an instance of the <a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.Response</span></code></a> class or a subclass. If a
civilian returns a non-Response object from a view callable that isn't
configured to use a <a class="reference internal" href="../glossary.html#term-renderer"><span class="xref std std-term">renderer</span></a>, they will typically expect the router to
raise an error.  However, you can hook Pyramid in such a way that users can
return arbitrary values from a view callable by providing an adapter which
converts the arbitrary return value into something that implements
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">IResponse</span></code></a>.</p>
<p>For example, if you'd like to allow view callables to return bare string
objects (without requiring a <a class="reference internal" href="../glossary.html#term-renderer"><span class="xref std std-term">renderer</span></a> to convert a string to a response
object), you can register an adapter which converts the string to a Response:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">string_response_adapter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="c1"># config is an instance of pyramid.config.Configurator</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">string_response_adapter</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Likewise, if you want to be able to return a simplified kind of response object
from view callables, you can use the IResponse hook to register an adapter to
the more complex IResponse interface:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">class</span> <span class="nc">SimpleResponse</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>

<span class="k">def</span> <span class="nf">simple_response_adapter</span><span class="p">(</span><span class="n">simple_response</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">simple_response</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="c1"># config is an instance of pyramid.config.Configurator</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">simple_response_adapter</span><span class="p">,</span> <span class="n">SimpleResponse</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If you want to implement your own Response object instead of using the
<a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.Response</span></code></a> object in any capacity at all, you'll have
to make sure that the object implements every attribute and method outlined in
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IResponse</span></code></a> and you'll have to ensure that it uses
<code class="docutils literal notranslate"><span class="pre">zope.interface.implementer(IResponse)</span></code> as a class decorator.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IResponse</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IResponse</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyResponse</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ... an implementation of every method and attribute</span>
    <span class="c1"># documented in IResponse should follow ...</span>
</pre></div>
</td></tr></table></div>
<p>When an alternate response object implementation is returned by a view
callable, if that object asserts that it implements
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IResponse" title="pyramid.interfaces.IResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">IResponse</span></code></a> (via
<code class="docutils literal notranslate"><span class="pre">zope.interface.implementer(IResponse)</span></code>) , an adapter needn't be registered
for the object; Pyramid will use it directly.</p>
<p>An IResponse adapter for <code class="docutils literal notranslate"><span class="pre">webob.Response</span></code> (as opposed to
<a class="reference internal" href="../api/response.html#pyramid.response.Response" title="pyramid.response.Response"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.Response</span></code></a>) is registered by Pyramid by default at
startup time, as by their nature, instances of this class (and instances of
subclasses of the class) will natively provide IResponse.  The adapter
registered for <code class="docutils literal notranslate"><span class="pre">webob.Response</span></code> simply returns the response object.</p>
<p>Instead of using <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_response_adapter" title="pyramid.config.Configurator.add_response_adapter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_response_adapter()</span></code></a>, you
can use the <a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.response.response_adapter</span></code></a> decorator:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">response_adapter</span>

<span class="nd">@response_adapter</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">string_response_adapter</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</td></tr></table></div>
<p>The above example, when scanned, has the same effect as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_response_adapter</span><span class="p">(</span><span class="n">string_response_adapter</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../api/response.html#pyramid.response.response_adapter" title="pyramid.response.response_adapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">response_adapter</span></code></a> decorator will have no effect
until activated by a <a class="reference internal" href="../glossary.html#term-scan"><span class="xref std std-term">scan</span></a>.</p>
</div>
<div class="section" id="using-a-view-mapper">
<span id="index-11"></span><span id="id7"></span><h2>Using a View Mapper<a class="headerlink" href="#using-a-view-mapper" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The default calling conventions for view callables are documented in the
<a class="reference internal" href="views.html#views-chapter"><span class="std std-ref">Views</span></a> chapter.  You can change the way users define view
callables by employing a <a class="reference internal" href="../glossary.html#term-view-mapper"><span class="xref std std-term">view mapper</span></a>.</p>
<p>A view mapper is an object that accepts a set of keyword arguments and which
returns a callable.  The returned callable is called with the <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view
callable</span></a> object.  The returned callable should itself return another callable
which can be called with the &quot;internal calling protocol&quot; <code class="docutils literal notranslate"><span class="pre">(context,</span>
<span class="pre">request)</span></code>.</p>
<p>You can use a view mapper in a number of ways:</p>
<ul class="simple">
<li>by setting a <code class="docutils literal notranslate"><span class="pre">__view_mapper__</span></code> attribute (which is the view mapper object)
on the view callable itself</li>
<li>by passing the mapper object to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view()</span></code></a>
(or its declarative and decorator equivalents) as the <code class="docutils literal notranslate"><span class="pre">mapper</span></code> argument</li>
<li>by registering a <em>default</em> view mapper</li>
</ul>
<p>Here's an example of a view mapper that emulates (somewhat) a Pylons
&quot;controller&quot;.  The mapper is initialized with some keyword arguments.  Its
<code class="docutils literal notranslate"><span class="pre">__call__</span></code> method accepts the view object (which will be a class).  It uses
the <code class="docutils literal notranslate"><span class="pre">attr</span></code> keyword argument it is passed to determine which attribute should
be used as an action method.  The wrapper method it returns accepts <code class="docutils literal notranslate"><span class="pre">(context,</span>
<span class="pre">request)</span></code> and returns the result of calling the action method with keyword
arguments implied by the <a class="reference internal" href="../glossary.html#term-matchdict"><span class="xref std std-term">matchdict</span></a> after popping the <code class="docutils literal notranslate"><span class="pre">action</span></code> out of
it.  This somewhat emulates the Pylons style of calling action methods with
routing parameters pulled out of the route matching dict as keyword arguments.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># framework</span>

<span class="k">class</span> <span class="nc">PylonsControllerViewMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">[</span><span class="s1">&#39;attr&#39;</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
            <span class="n">matchdict</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">matchdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">matchdict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;action&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">view</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="o">**</span><span class="n">matchdict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">class</span> <span class="nc">BaseController</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__view_mapper__</span> <span class="o">=</span> <span class="n">PylonsControllerViewMapper</span>
</pre></div>
</td></tr></table></div>
<p>A user might make use of these framework components like so:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># user application</span>

<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">import</span> <span class="nn">pyramid_handlers</span>
<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>

<span class="k">class</span> <span class="nc">MyController</span><span class="p">(</span><span class="n">BaseController</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">pyramid_handlers</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;/{id}&#39;</span><span class="p">,</span> <span class="n">MyController</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
    <span class="n">config</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;/{action}/{id}&#39;</span><span class="p">,</span> <span class="n">MyController</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">())</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>The <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_view_mapper" title="pyramid.config.Configurator.set_view_mapper"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.set_view_mapper()</span></code></a> method can be used to
set a <em>default</em> view mapper (overriding the superdefault view mapper used by
Pyramid itself).</p>
<p>A <em>single</em> view registration can use a view mapper by passing the mapper as the
<code class="docutils literal notranslate"><span class="pre">mapper</span></code> argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_view()</span></code></a>.</p>
</div>
<div class="section" id="registering-configuration-decorators">
<span id="index-12"></span><span id="id8"></span><h2>Registering Configuration Decorators<a class="headerlink" href="#registering-configuration-decorators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Decorators such as <a class="reference internal" href="../api/view.html#pyramid.view.view_config" title="pyramid.view.view_config"><code class="xref py py-class docutils literal notranslate"><span class="pre">view_config</span></code></a> don't change the behavior
of the functions or classes they're decorating.  Instead when a <a class="reference internal" href="../glossary.html#term-scan"><span class="xref std std-term">scan</span></a> is
performed, a modified version of the function or class is registered with
<span>Pyramid</span>.</p>
<p>You may wish to have your own decorators that offer such behaviour. This is
possible by using the <a class="reference internal" href="../glossary.html#term-venusian"><span class="xref std std-term">Venusian</span></a> package in the same way that it is used
by <span>Pyramid</span>.</p>
<p>By way of example, let's suppose you want to write a decorator that registers
the function it wraps with a <a class="reference internal" href="../glossary.html#term-zope-component-architecture"><span class="xref std std-term">Zope Component Architecture</span></a> &quot;utility&quot;
within the <a class="reference internal" href="../glossary.html#term-application-registry"><span class="xref std std-term">application registry</span></a> provided by <span>Pyramid</span>. The
application registry and the utility inside the registry is likely only to be
available once your application's configuration is at least partially
completed. A normal decorator would fail as it would be executed before the
configuration had even begun.</p>
<p>However, using <a class="reference internal" href="../glossary.html#term-venusian"><span class="xref std std-term">Venusian</span></a>, the decorator could be written as follows:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">venusian</span>
<span class="kn">from</span> <span class="nn">mypackage.interfaces</span> <span class="kn">import</span> <span class="n">IMyUtility</span>

<span class="k">class</span> <span class="nc">registerFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scanner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="n">registry</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">registry</span>
        <span class="n">registry</span><span class="o">.</span><span class="n">getUtility</span><span class="p">(</span><span class="n">IMyUtility</span><span class="p">)</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="n">venusian</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</td></tr></table></div>
<p>This decorator could then be used to register functions throughout your code:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nd">@registerFunction</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
    <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>However, the utility would only be looked up when a <a class="reference internal" href="../glossary.html#term-scan"><span class="xref std std-term">scan</span></a> was performed,
enabling you to set up the utility in advance:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>

<span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">mypackage.interfaces</span> <span class="kn">import</span> <span class="n">IMyUtility</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IMyUtility</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">UtilityImplementation</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registrations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">callable_</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registrations</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">callable_</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">registerUtility</span><span class="p">(</span><span class="n">UtilityImplementation</span><span class="p">())</span>
    <span class="n">config</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>For full details, please read the <a class="reference external" href="https://docs.pylonsproject.org/projects/venusian/en/latest/index.html#venusian" title="(in venusian v1.1.0)"><span class="xref std std-ref">Venusian documentation</span></a>.</p>
</div>
<div class="section" id="registering-tweens">
<span id="id9"></span><h2>Registering Tweens<a class="headerlink" href="#registering-tweens" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加: </span>Tweens</p>
</div>
<p>A <a class="reference internal" href="../glossary.html#term-tween"><span class="xref std std-term">tween</span></a> (a contraction of the word &quot;between&quot;) is a bit of code that
sits between the Pyramid router's main request handling function and the
upstream WSGI component that uses <span>Pyramid</span> as its &quot;app&quot;.  This is a
feature that may be used by Pyramid framework extensions to provide, for
example, Pyramid-specific view timing support bookkeeping code that examines
exceptions before they are returned to the upstream WSGI application.  Tweens
behave a bit like <a class="reference internal" href="../glossary.html#term-wsgi"><span class="xref std std-term">WSGI</span></a> <a class="reference internal" href="../glossary.html#term-middleware"><span class="xref std std-term">middleware</span></a>, but they have the benefit of
running in a context in which they have access to the Pyramid <a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a>,
<a class="reference internal" href="../glossary.html#term-response"><span class="xref std std-term">response</span></a>, and <a class="reference internal" href="../glossary.html#term-application-registry"><span class="xref std std-term">application registry</span></a>, as well as the Pyramid
rendering machinery.</p>
<div class="section" id="creating-a-tween">
<h3>Creating a Tween<a class="headerlink" href="#creating-a-tween" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To create a tween, you must write a &quot;tween factory&quot;.  A tween factory must be a
globally importable callable which accepts two arguments: <code class="docutils literal notranslate"><span class="pre">handler</span></code> and
<code class="docutils literal notranslate"><span class="pre">registry</span></code>.  <code class="docutils literal notranslate"><span class="pre">handler</span></code> will be either the main Pyramid request handling
function or another tween.  <code class="docutils literal notranslate"><span class="pre">registry</span></code> will be the Pyramid <a class="reference internal" href="../glossary.html#term-application-registry"><span class="xref std std-term">application
registry</span></a> represented by this Configurator.  A tween factory must return the
tween (a callable object) when it is called.</p>
<p>A tween is called with a single argument, <code class="docutils literal notranslate"><span class="pre">request</span></code>, which is the
<a class="reference internal" href="../glossary.html#term-request"><span class="xref std std-term">request</span></a> created by Pyramid's router when it receives a WSGI request. A
tween should return a <a class="reference internal" href="../glossary.html#term-response"><span class="xref std std-term">response</span></a>, usually the one generated by the
downstream Pyramid application.</p>
<p>You can write the tween factory as a simple closure-returning function:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_tween_factory</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
    <span class="c1"># one-time configuration code goes here</span>

    <span class="k">def</span> <span class="nf">simple_tween</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="c1"># code to be executed for each request before</span>
        <span class="c1"># the actual application code goes here</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># code to be executed for each request after</span>
        <span class="c1"># the actual application code goes here</span>

        <span class="k">return</span> <span class="n">response</span>

    <span class="k">return</span> <span class="n">simple_tween</span>
</pre></div>
</td></tr></table></div>
<p>Alternatively, the tween factory can be a class with the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> magic
method:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">simple_tween_factory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registry</span> <span class="o">=</span> <span class="n">registry</span>

        <span class="c1"># one-time configuration code goes here</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c1"># code to be executed for each request before</span>
        <span class="c1"># the actual application code goes here</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># code to be executed for each request after</span>
        <span class="c1"># the actual application code goes here</span>

        <span class="k">return</span> <span class="n">response</span>
</pre></div>
</td></tr></table></div>
<p>You should avoid mutating any state on the tween instance. The tween is invoked
once per request and any shared mutable state needs to be carefully handled to
avoid any race conditions.</p>
<p>The closure style performs slightly better and enables you to conditionally
omit the tween from the request processing pipeline (see the following timing
tween example), whereas the class style makes it easier to have shared mutable
state and allows subclassing.</p>
<p>Here's a complete example of a tween that logs the time spent processing each
request:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># in a module named myapp.tweens</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pyramid.settings</span> <span class="kn">import</span> <span class="n">asbool</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">timing_tween_factory</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">registry</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">asbool</span><span class="p">(</span><span class="n">registry</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;do_timing&#39;</span><span class="p">)):</span>
        <span class="c1"># if timing support is enabled, return a wrapper</span>
        <span class="k">def</span> <span class="nf">timing_tween</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The request took </span><span class="si">%s</span><span class="s1"> seconds&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">response</span>
        <span class="k">return</span> <span class="n">timing_tween</span>
    <span class="c1"># if timing support is not enabled, return the original</span>
    <span class="c1"># handler</span>
    <span class="k">return</span> <span class="n">handler</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, the tween factory defines a <code class="docutils literal notranslate"><span class="pre">timing_tween</span></code> tween and
returns it if <code class="docutils literal notranslate"><span class="pre">asbool(registry.settings.get('do_timing'))</span></code> is true.  It
otherwise simply returns the handler which it was given.  The
<code class="docutils literal notranslate"><span class="pre">registry.settings</span></code> attribute is a handle to the deployment settings provided
by the user (usually in an <code class="docutils literal notranslate"><span class="pre">.ini</span></code> file).  In this case, if the user has
defined a <code class="docutils literal notranslate"><span class="pre">do_timing</span></code> setting and that setting is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the user has said
they want to do timing, so the tween factory returns the timing tween; it
otherwise just returns the handler it has been provided, preventing any timing.</p>
<p>The example timing tween simply records the start time, calls the downstream
handler, logs the number of seconds consumed by the downstream handler, and
returns the response.</p>
</div>
<div class="section" id="registering-an-implicit-tween-factory">
<h3>Registering an Implicit Tween Factory<a class="headerlink" href="#registering-an-implicit-tween-factory" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Once you've created a tween factory, you can register it into the implicit
tween chain using the <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a> method
using its <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a>.</p>
<p>Here's an example of registering a tween factory as an &quot;implicit&quot; tween in a
Pyramid application:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tweens.timing_tween_factory&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Note that you must use a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a> as the first argument to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a>; this must point at a tween
factory.  You cannot pass the tween factory object itself to the method: it
must be <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a> that points to a globally importable object.
In the above example, we assume that a <code class="docutils literal notranslate"><span class="pre">timing_tween_factory</span></code> tween factory
was defined in a module named <code class="docutils literal notranslate"><span class="pre">myapp.tweens</span></code>, so the tween factory is
importable as <code class="docutils literal notranslate"><span class="pre">myapp.tweens.timing_tween_factory</span></code>.</p>
<p>When you use <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a>, you're instructing
the system to use your tween factory at startup time unless the user has
provided an explicit tween list in their configuration.  This is what's meant
by an &quot;implicit&quot; tween.  A user can always elect to supply an explicit tween
list, reordering or disincluding implicitly added tweens.  See
<a class="reference internal" href="#explicit-tween-ordering"><span class="std std-ref">Explicit Tween Ordering</span></a> for more information about explicit tween
ordering.</p>
<p>If more than one call to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a> is made
within a single application configuration, the tweens will be chained together
at application startup time.  The <em>first</em> tween factory added via <code class="docutils literal notranslate"><span class="pre">add_tween</span></code>
will be called with the Pyramid exception view tween factory as its <code class="docutils literal notranslate"><span class="pre">handler</span></code>
argument, then the tween factory added directly after that one will be called
with the result of the first tween factory as its <code class="docutils literal notranslate"><span class="pre">handler</span></code> argument, and so
on, ad infinitum until all tween factories have been called. The Pyramid router
will use the outermost tween produced by this chain (the tween generated by the
very last tween factory added) as its request handler function.  For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tween_factory1&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tween_factory2&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory2</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory1</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="suggesting-implicit-tween-ordering">
<h3>Suggesting Implicit Tween Ordering<a class="headerlink" href="#suggesting-implicit-tween-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By default, as described above, the ordering of the chain is controlled
entirely by the relative ordering of calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a>.  However, the caller of
<code class="docutils literal notranslate"><span class="pre">add_tween</span></code> can provide an optional hint that can influence the implicit
tween chain ordering by supplying <code class="docutils literal notranslate"><span class="pre">under</span></code> or <code class="docutils literal notranslate"><span class="pre">over</span></code> (or both) arguments to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tween()</span></code></a>.  These hints are only used when
an explicit tween ordering is not used. See <a class="reference internal" href="#explicit-tween-ordering"><span class="std std-ref">Explicit Tween Ordering</span></a> for
a description of how to set an explicit tween ordering.</p>
<p>Allowable values for <code class="docutils literal notranslate"><span class="pre">under</span></code> or <code class="docutils literal notranslate"><span class="pre">over</span></code> (or both) are:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">None</span></code> (the default),</li>
<li>a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a> to a tween factory: a string representing the
predicted dotted name of a tween factory added in a call to <code class="docutils literal notranslate"><span class="pre">add_tween</span></code> in
the same configuration session,</li>
<li>one of the constants <a class="reference internal" href="../api/tweens.html#pyramid.tweens.MAIN" title="pyramid.tweens.MAIN"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pyramid.tweens.MAIN</span></code></a>,
<a class="reference internal" href="../api/tweens.html#pyramid.tweens.INGRESS" title="pyramid.tweens.INGRESS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pyramid.tweens.INGRESS</span></code></a>, or <a class="reference internal" href="../api/tweens.html#pyramid.tweens.EXCVIEW" title="pyramid.tweens.EXCVIEW"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pyramid.tweens.EXCVIEW</span></code></a>, or</li>
<li>an iterable of any combination of the above. This allows the user to specify
fallbacks if the desired tween is not included, as well as compatibility
with multiple other tweens.</li>
</ul>
<p>Effectively, <code class="docutils literal notranslate"><span class="pre">over</span></code> means &quot;closer to the request ingress than&quot; and <code class="docutils literal notranslate"><span class="pre">under</span></code>
means &quot;closer to the main Pyramid application than&quot;. You can think of an onion
with outer layers over the inner layers, the application being under all the
layers at the center.</p>
<p>For example, the following call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tween()</span></code></a> will attempt to place the tween
factory represented by <code class="docutils literal notranslate"><span class="pre">myapp.tween_factory</span></code> directly &quot;above&quot; (in <code class="docutils literal notranslate"><span class="pre">ptweens</span></code>
order) the main Pyramid request handler.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyramid.tweens</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tween_factory&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, calling the following call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tween()</span></code></a> will attempt to place this tween
factory &quot;above&quot; the main handler but &quot;below&quot; a separately added tween factory:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyramid.tweens</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tween_factory1&#39;</span><span class="p">,</span>
                 <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_tween</span><span class="p">(</span><span class="s1">&#39;myapp.tween_factory2&#39;</span><span class="p">,</span>
                 <span class="n">over</span><span class="o">=</span><span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">MAIN</span><span class="p">,</span>
                 <span class="n">under</span><span class="o">=</span><span class="s1">&#39;myapp.tween_factory1&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The above example will generate an implicit tween chain that looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INGRESS</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">pyramid</span><span class="o">.</span><span class="n">tweens</span><span class="o">.</span><span class="n">excview_tween_factory</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory1</span>
<span class="n">myapp</span><span class="o">.</span><span class="n">tween_factory2</span>
<span class="n">MAIN</span> <span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
</pre></div>
</div>
<p>Specifying neither <code class="docutils literal notranslate"><span class="pre">over</span></code> nor <code class="docutils literal notranslate"><span class="pre">under</span></code> is equivalent to specifying
<code class="docutils literal notranslate"><span class="pre">under=INGRESS</span></code>.</p>
<p>If all options for <code class="docutils literal notranslate"><span class="pre">under</span></code> (or <code class="docutils literal notranslate"><span class="pre">over</span></code>) cannot be found in the current
configuration, it is an error. If some options are specified purely for
compatibilty with other tweens, just add a fallback of <code class="docutils literal notranslate"><span class="pre">MAIN</span></code> or <code class="docutils literal notranslate"><span class="pre">INGRESS</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">under=('someothertween',</span> <span class="pre">'someothertween2',</span> <span class="pre">INGRESS)</span></code>. This
constraint will require the tween to be located under the <code class="docutils literal notranslate"><span class="pre">someothertween</span></code>
tween, the <code class="docutils literal notranslate"><span class="pre">someothertween2</span></code> tween, and <code class="docutils literal notranslate"><span class="pre">INGRESS</span></code>. If any of these is not
in the current configuration, this constraint will only organize itself based
on the tweens that are present.</p>
</div>
<div class="section" id="explicit-tween-ordering">
<span id="id10"></span><h3>Explicit Tween Ordering<a class="headerlink" href="#explicit-tween-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Implicit tween ordering is obviously only best-effort.  Pyramid will attempt to
provide an implicit order of tweens as best it can using hints provided by
calls to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tween()</span></code></a>.  But because it's only
best-effort, if very precise tween ordering is required, the only surefire way
to get it is to use an explicit tween order.  The deploying user can override
the implicit tween inclusion and ordering implied by calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tween()</span></code></a> entirely by using the
<code class="docutils literal notranslate"><span class="pre">pyramid.tweens</span></code> settings value.  When used, this settings value must be a
list of Python dotted names which will override the ordering (and inclusion) of
tween factories in the implicit tween chain.  For example:</p>
<div class="highlight-ini notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">[app:main]</span>
<span class="na">use</span> <span class="o">=</span> <span class="s">egg:MyApp</span>
<span class="na">pyramid.reload_templates</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">pyramid.debug_authorization</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_notfound</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_routematch</span> <span class="o">=</span> <span class="s">false</span>
<span class="na">pyramid.debug_templates</span> <span class="o">=</span> <span class="s">true</span>
<span class="na">pyramid.tweens</span> <span class="o">=</span> <span class="s">myapp.my_cool_tween_factory</span>
<span class="s">                 pyramid.tweens.excview_tween_factory</span>
</pre></div>
</td></tr></table></div>
<p>In the above configuration, calls made during configuration to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a> are ignored, and the user is
telling the system to use the tween factories he has listed in the
<code class="docutils literal notranslate"><span class="pre">pyramid.tweens</span></code> configuration setting (each is a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted Python name</span></a>
which points to a tween factory) instead of any tween factories added via
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a>.  The <em>first</em> tween factory in
the <code class="docutils literal notranslate"><span class="pre">pyramid.tweens</span></code> list will be used as the producer of the effective
<span>Pyramid</span> request handling function; it will wrap the tween factory
declared directly &quot;below&quot; it, ad infinitum.  The &quot;main&quot; Pyramid request handler
is implicit, and always &quot;at the bottom&quot;.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Pyramid's own <a class="reference internal" href="../glossary.html#term-exception-view"><span class="xref std std-term">exception view</span></a> handling logic is implemented as a
tween factory function: <a class="reference internal" href="../api/tweens.html#pyramid.tweens.excview_tween_factory" title="pyramid.tweens.excview_tween_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyramid.tweens.excview_tween_factory()</span></code></a>.  If
Pyramid exception view handling is desired, and tween factories are
specified via the <code class="docutils literal notranslate"><span class="pre">pyramid.tweens</span></code> configuration setting, the
<a class="reference internal" href="../api/tweens.html#pyramid.tweens.excview_tween_factory" title="pyramid.tweens.excview_tween_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyramid.tweens.excview_tween_factory()</span></code></a> function must be added to the
<code class="docutils literal notranslate"><span class="pre">pyramid.tweens</span></code> configuration setting list explicitly.  If it is not
present, Pyramid will not perform exception view handling.</p>
</div>
</div>
<div class="section" id="tween-conflicts-and-ordering-cycles">
<h3>Tween Conflicts and Ordering Cycles<a class="headerlink" href="#tween-conflicts-and-ordering-cycles" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pyramid will prevent the same tween factory from being added to the tween chain
more than once using configuration conflict detection.  If you wish to add the
same tween factory more than once in a configuration, you should either: (a)
use a tween factory that is a separate globally importable instance object from
the factory that it conflicts with; (b) use a function or class as a tween
factory with the same logic as the other tween factory it conflicts with, but
with a different <code class="docutils literal notranslate"><span class="pre">__name__</span></code> attribute; or (c) call
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.commit" title="pyramid.config.Configurator.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.commit()</span></code></a> between calls to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_tween" title="pyramid.config.Configurator.add_tween"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_tween()</span></code></a>.</p>
<p>If a cycle is detected in implicit tween ordering when <code class="docutils literal notranslate"><span class="pre">over</span></code> and <code class="docutils literal notranslate"><span class="pre">under</span></code>
are used in any call to <code class="docutils literal notranslate"><span class="pre">add_tween</span></code>, an exception will be raised at startup
time.</p>
</div>
<div class="section" id="displaying-tween-ordering">
<h3>Displaying Tween Ordering<a class="headerlink" href="#displaying-tween-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ptweens</span></code> command-line utility can be used to report the current implict
and explicit tween chains used by an application.  See
<a class="reference internal" href="commandline.html#displaying-tweens"><span class="std std-ref">Displaying &quot;Tweens&quot;</span></a>.</p>
</div>
</div>
<div class="section" id="adding-a-third-party-view-route-or-subscriber-predicate">
<span id="registering-thirdparty-predicates"></span><h2>Adding a Third Party View, Route, or Subscriber Predicate<a class="headerlink" href="#adding-a-third-party-view-route-or-subscriber-predicate" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.4 で追加.</span></p>
</div>
<div class="section" id="view-and-route-predicates">
<span id="id11"></span><h3>View and Route Predicates<a class="headerlink" href="#view-and-route-predicates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>View and route predicates used during configuration allow you to narrow the set
of circumstances under which a view or route will match.  For example, the
<code class="docutils literal notranslate"><span class="pre">request_method</span></code> view predicate can be used to ensure a view callable is only
invoked when the request's method is <code class="docutils literal notranslate"><span class="pre">POST</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@view_config</span><span class="p">(</span><span class="n">request_method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">someview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Likewise, a similar predicate can be used as a <em>route</em> predicate:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;/foo&#39;</span><span class="p">,</span> <span class="n">request_method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Many other built-in predicates exists (<code class="docutils literal notranslate"><span class="pre">request_param</span></code>, and others).  You can
add third-party predicates to the list of available predicates by using one of
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view_predicate" title="pyramid.config.Configurator.add_view_predicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view_predicate()</span></code></a> or
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_route_predicate" title="pyramid.config.Configurator.add_route_predicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_route_predicate()</span></code></a>.  The former adds a
view predicate, the latter a route predicate.</p>
<p>When using one of those APIs, you pass a <em>name</em> and a <em>factory</em> to add a
predicate during Pyramid's configuration stage.  For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_view_predicate</span><span class="p">(</span><span class="s1">&#39;content_type&#39;</span><span class="p">,</span> <span class="n">ContentTypePredicate</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example adds a new predicate named <code class="docutils literal notranslate"><span class="pre">content_type</span></code> to the list of
available predicates for views.  This will allow the following view
configuration statement to work:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nd">@view_config</span><span class="p">(</span><span class="n">content_type</span><span class="o">=</span><span class="s1">&#39;File&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</td></tr></table></div>
<p>The first argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view_predicate" title="pyramid.config.Configurator.add_view_predicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view_predicate()</span></code></a>,
the name, is a string representing the name that is expected to be passed to
<code class="docutils literal notranslate"><span class="pre">view_config</span></code> (or its imperative analogue <code class="docutils literal notranslate"><span class="pre">add_view</span></code>).</p>
<p>The second argument is a view or route predicate factory, or a <a class="reference internal" href="../glossary.html#term-dotted-python-name"><span class="xref std std-term">dotted
Python name</span></a> which refers to a view or route predicate factory.  A view or
route predicate factory is most often a class with a constructor
(<code class="docutils literal notranslate"><span class="pre">__init__</span></code>), a <code class="docutils literal notranslate"><span class="pre">text</span></code> method, a <code class="docutils literal notranslate"><span class="pre">phash</span></code> method, and a <code class="docutils literal notranslate"><span class="pre">__call__</span></code>
method. For example:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ContentTypePredicate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;content_type = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,)</span>

    <span class="n">phash</span> <span class="o">=</span> <span class="n">text</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">content_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>
</pre></div>
</td></tr></table></div>
<p>The constructor of a predicate factory takes two arguments: <code class="docutils literal notranslate"><span class="pre">val</span></code> and
<code class="docutils literal notranslate"><span class="pre">config</span></code>.  The <code class="docutils literal notranslate"><span class="pre">val</span></code> argument will be the argument passed to
<code class="docutils literal notranslate"><span class="pre">view_config</span></code> (or <code class="docutils literal notranslate"><span class="pre">add_view</span></code>).  In the example above, it will be the string
<code class="docutils literal notranslate"><span class="pre">File</span></code>.  The second argument, <code class="docutils literal notranslate"><span class="pre">config</span></code>, will be the Configurator instance
at the time of configuration.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">text</span></code> method must return a string.  It should be useful to describe the
behavior of the predicate in error messages.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">phash</span></code> method must return a string or a sequence of strings.  It's most
often the same as <code class="docutils literal notranslate"><span class="pre">text</span></code>, as long as <code class="docutils literal notranslate"><span class="pre">text</span></code> uniquely describes the
predicate's name and the value passed to the constructor.  If <code class="docutils literal notranslate"><span class="pre">text</span></code> is more
general, or doesn't describe things that way, <code class="docutils literal notranslate"><span class="pre">phash</span></code> should return a string
with the name and the value serialized.  The result of <code class="docutils literal notranslate"><span class="pre">phash</span></code> is not seen in
output anywhere, it just informs the uniqueness constraints for view
configuration.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method differs depending on whether the predicate is used as
a <a class="reference internal" href="../glossary.html#term-view-predicate"><span class="xref std std-term">view predicate</span></a> or a <a class="reference internal" href="../glossary.html#term-route-predicate"><span class="xref std std-term">route predicate</span></a>:</p>
<ul class="simple">
<li>When used as a route predicate, the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> signature is
<code class="docutils literal notranslate"><span class="pre">(info,</span> <span class="pre">request)</span></code>. The <code class="docutils literal notranslate"><span class="pre">info</span></code> object is a dictionary containing two
keys: <code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">route</span></code>. <code class="docutils literal notranslate"><span class="pre">info['match']</span></code> is the matchdict containing
the patterns matched in the route pattern. <code class="docutils literal notranslate"><span class="pre">info['route']</span></code> is the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IRoute" title="pyramid.interfaces.IRoute"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IRoute</span></code></a> object for the current route.</li>
<li>When used as a view predicate, the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> signature is
<code class="docutils literal notranslate"><span class="pre">(context,</span> <span class="pre">request)</span></code>. The <code class="docutils literal notranslate"><span class="pre">context</span></code> is the result of <a class="reference internal" href="../glossary.html#term-traversal"><span class="xref std std-term">traversal</span></a>
performed using either the route's <a class="reference internal" href="../glossary.html#term-root-factory"><span class="xref std std-term">root factory</span></a> or the app's
<a class="reference internal" href="../glossary.html#term-default-root-factory"><span class="xref std std-term">default root factory</span></a>.</li>
</ul>
<p>In both cases the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method is expected to return <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>It is possible to use the same predicate factory as both a view predicate and
as a route predicate, but they'll need to handle the <code class="docutils literal notranslate"><span class="pre">info</span></code> or <code class="docutils literal notranslate"><span class="pre">context</span></code>
argument specially (many predicates do not need this argument) and you'll need
to call <code class="docutils literal notranslate"><span class="pre">add_view_predicate</span></code> and <code class="docutils literal notranslate"><span class="pre">add_route_predicate</span></code> separately with
the same factory.</p>
</div>
<div class="section" id="subscriber-predicates">
<span id="id12"></span><h3>Subscriber Predicates<a class="headerlink" href="#subscriber-predicates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Subscriber predicates work almost exactly like view and route predicates. They
narrow the set of circumstances in which a subscriber will be called. There are
several minor differences between a subscriber predicate and a view or route
predicate:</p>
<ul class="simple">
<li>There are no default subscriber predicates.  You must register one to use
one.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method of a subscriber predicate accepts a single <code class="docutils literal notranslate"><span class="pre">event</span></code>
object instead of a <code class="docutils literal notranslate"><span class="pre">context</span></code> and a <code class="docutils literal notranslate"><span class="pre">request</span></code>.</li>
<li>Not every subscriber predicate can be used with every event type.  Some
subscriber predicates will assume a certain event type.</li>
</ul>
<p>Here's an example of a subscriber predicate that can be used in conjunction
with a subscriber that subscribes to the <a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.NewRequest</span></code></a>
event type.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RequestPathStartsWith</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;path_startswith = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,)</span>

    <span class="n">phash</span> <span class="o">=</span> <span class="n">text</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Once you've created a subscriber predicate, it may be registered via
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_subscriber_predicate" title="pyramid.config.Configurator.add_subscriber_predicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_subscriber_predicate()</span></code></a>.  For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">add_subscriber_predicate</span><span class="p">(</span>
    <span class="s1">&#39;request_path_startswith&#39;</span><span class="p">,</span> <span class="n">RequestPathStartsWith</span><span class="p">)</span>
</pre></div>
</div>
<p>Once a subscriber predicate is registered, you can use it in a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_subscriber" title="pyramid.config.Configurator.add_subscriber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_subscriber()</span></code></a> or to
<a class="reference internal" href="../api/events.html#pyramid.events.subscriber" title="pyramid.events.subscriber"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.subscriber</span></code></a>.  Here's an example of using the previously
registered <code class="docutils literal notranslate"><span class="pre">request_path_startswith</span></code> predicate in a call to
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_subscriber" title="pyramid.config.Configurator.add_subscriber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_subscriber()</span></code></a>:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># define a subscriber in your code</span>

<span class="k">def</span> <span class="nf">yosubscriber</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="s1">&#39;YO!&#39;</span>

<span class="c1"># and at configuration time</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_subscriber</span><span class="p">(</span><span class="n">yosubscriber</span><span class="p">,</span> <span class="n">NewRequest</span><span class="p">,</span>
       <span class="n">request_path_startswith</span><span class="o">=</span><span class="s1">&#39;/add_yo&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Here's the same subscriber/predicate/event-type combination used via
<a class="reference internal" href="../api/events.html#pyramid.events.subscriber" title="pyramid.events.subscriber"><code class="xref py py-class docutils literal notranslate"><span class="pre">subscriber</span></code></a>.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.events</span> <span class="kn">import</span> <span class="n">subscriber</span>

<span class="nd">@subscriber</span><span class="p">(</span><span class="n">NewRequest</span><span class="p">,</span> <span class="n">request_path_startswith</span><span class="o">=</span><span class="s1">&#39;/add_yo&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">yosubscriber</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">event</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="s1">&#39;YO!&#39;</span>
</pre></div>
</td></tr></table></div>
<p>In either of the above configurations, the <code class="docutils literal notranslate"><span class="pre">yosubscriber</span></code> callable will only
be called if the request path starts with <code class="docutils literal notranslate"><span class="pre">/add_yo</span></code>.  Otherwise the event
subscriber will not be called.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">request_path_startswith</span></code> subscriber you defined can be used
with events that have a <code class="docutils literal notranslate"><span class="pre">request</span></code> attribute, but not ones that do not.  So,
for example, the predicate can be used with subscribers registered for
<a class="reference internal" href="../api/events.html#pyramid.events.NewRequest" title="pyramid.events.NewRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.NewRequest</span></code></a> and <a class="reference internal" href="../api/events.html#pyramid.events.ContextFound" title="pyramid.events.ContextFound"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.ContextFound</span></code></a>
events, but it cannot be used with subscribers registered for
<a class="reference internal" href="../api/events.html#pyramid.events.ApplicationCreated" title="pyramid.events.ApplicationCreated"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.events.ApplicationCreated</span></code></a> because the latter type of event has
no <code class="docutils literal notranslate"><span class="pre">request</span></code> attribute.  The point being, unlike route and view predicates,
not every type of subscriber predicate will necessarily be applicable for use
in every subscriber registration.  It is not the responsibility of the
predicate author to make every predicate make sense for every event type; it is
the responsibility of the predicate consumer to use predicates that make sense
for a particular event type registration.</p>
</div>
</div>
<div class="section" id="view-derivers">
<span id="index-13"></span><span id="id13"></span><h2>View Derivers<a class="headerlink" href="#view-derivers" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.7 で追加.</span></p>
</div>
<p>Every URL processed by <span>Pyramid</span> is matched against a custom view
pipeline. See <a class="reference internal" href="router.html#router-chapter"><span class="std std-ref">Request Processing</span></a> for how this works. The view pipeline
itself is built from the user-supplied <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>, which is then
composed with <a class="reference internal" href="../glossary.html#term-view-deriver"><span class="xref std std-term">view derivers</span></a>. A view deriver is a
composable element of the view pipeline which is used to wrap a view with
added functionality. View derivers are very similar to the <code class="docutils literal notranslate"><span class="pre">decorator</span></code>
argument to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view()</span></code></a>, except that they have
the option to execute for every view in the application.</p>
<p>It is helpful to think of a <a class="reference internal" href="../glossary.html#term-view-deriver"><span class="xref std std-term">view deriver</span></a> as middleware for views.
Unlike tweens or WSGI middleware which are scoped to the application itself,
a view deriver is invoked once per view in the application, and can use
configuration options from the view to customize its behavior.</p>
<div class="section" id="built-in-view-derivers">
<h3>Built-in View Derivers<a class="headerlink" href="#built-in-view-derivers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There are several built-in view derivers that <span>Pyramid</span> will automatically
apply to any view. Below they are defined in order from furthest to closest to
the user-defined <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>:</p>
<p><code class="docutils literal notranslate"><span class="pre">secured_view</span></code></p>
<blockquote>
<div><p>Enforce the <code class="docutils literal notranslate"><span class="pre">permission</span></code> defined on the view. This element is a no-op if no
permission is defined. Note there will always be a permission defined if a
default permission was assigned via
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_default_permission" title="pyramid.config.Configurator.set_default_permission"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.set_default_permission()</span></code></a> unless the
view is an <a class="reference internal" href="../glossary.html#term-exception-view"><span class="xref std std-term">exception view</span></a>.</p>
<p>This element will also output useful debugging information when
<code class="docutils literal notranslate"><span class="pre">pyramid.debug_authorization</span></code> is enabled.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">csrf_view</span></code></p>
<blockquote>
<div>Used to check the CSRF token provided in the request. This element is a
no-op if <code class="docutils literal notranslate"><span class="pre">require_csrf</span></code> view option is not <code class="docutils literal notranslate"><span class="pre">True</span></code>. Note there will
always be a <code class="docutils literal notranslate"><span class="pre">require_csrf</span></code> option if a default value was assigned via
<a class="reference internal" href="../api/config.html#pyramid.config.Configurator.set_default_csrf_options" title="pyramid.config.Configurator.set_default_csrf_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.set_default_csrf_options()</span></code></a> unless
the view is an <a class="reference internal" href="../glossary.html#term-exception-view"><span class="xref std std-term">exception view</span></a>.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">owrapped_view</span></code></p>
<blockquote>
<div>Invokes the wrapped view defined by the <code class="docutils literal notranslate"><span class="pre">wrapper</span></code> option.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">http_cached_view</span></code></p>
<blockquote>
<div>Applies cache control headers to the response defined by the <code class="docutils literal notranslate"><span class="pre">http_cache</span></code>
option. This element is a no-op if the <code class="docutils literal notranslate"><span class="pre">pyramid.prevent_http_cache</span></code> setting
is enabled or the <code class="docutils literal notranslate"><span class="pre">http_cache</span></code> option is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">decorated_view</span></code></p>
<blockquote>
<div>Wraps the view with the decorators from the <code class="docutils literal notranslate"><span class="pre">decorator</span></code> option.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">rendered_view</span></code></p>
<blockquote>
<div>Adapts the result of the <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a> into a <a class="reference internal" href="../glossary.html#term-response"><span class="xref std std-term">response</span></a>
object. Below this point the result may be any Python object.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">mapped_view</span></code></p>
<blockquote>
<div>Applies the <a class="reference internal" href="../glossary.html#term-view-mapper"><span class="xref std std-term">view mapper</span></a> defined by the <code class="docutils literal notranslate"><span class="pre">mapper</span></code> option or the
application's default view mapper to the <a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>. This
is always the closest deriver to the user-defined view and standardizes the
view pipeline interface to accept <code class="docutils literal notranslate"><span class="pre">(context,</span> <span class="pre">request)</span></code> from all previous
view derivers.</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Any view derivers defined <code class="docutils literal notranslate"><span class="pre">under</span></code> the <code class="docutils literal notranslate"><span class="pre">rendered_view</span></code> are not
guaranteed to receive a valid response object. Rather they will receive the
result from the <a class="reference internal" href="../glossary.html#term-view-mapper"><span class="xref std std-term">view mapper</span></a> which is likely the original response
returned from the view. This is possibly a dictionary for a renderer but it
may be any Python object that may be adapted into a response.</p>
</div>
</div>
<div class="section" id="custom-view-derivers">
<h3>Custom View Derivers<a class="headerlink" href="#custom-view-derivers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is possible to define custom view derivers which will affect all views in an
application. There are many uses for this, but most will likely be centered
around monitoring and security. In order to register a custom <a class="reference internal" href="../glossary.html#term-view-deriver"><span class="xref std std-term">view
deriver</span></a>, you should create a callable that conforms to the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IViewDeriver" title="pyramid.interfaces.IViewDeriver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IViewDeriver</span></code></a> interface, and then register it with
your application using <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view_deriver" title="pyramid.config.Configurator.add_view_deriver"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view_deriver()</span></code></a>.
The callable should accept the <code class="docutils literal notranslate"><span class="pre">view</span></code> to be wrapped and the <code class="docutils literal notranslate"><span class="pre">info</span></code> object
which is an instance of <a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IViewDeriverInfo" title="pyramid.interfaces.IViewDeriverInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IViewDeriverInfo</span></code></a>.
For example, below is a callable that can provide timing information for the
view pipeline:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">timing_view</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;timed&#39;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper_view</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">view</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;X-View-Performance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">response</span>
        <span class="k">return</span> <span class="n">wrapper_view</span>
    <span class="k">return</span> <span class="n">view</span>

<span class="n">timing_view</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;timed&#39;</span><span class="p">,)</span>

<span class="n">config</span><span class="o">.</span><span class="n">add_view_deriver</span><span class="p">(</span><span class="n">timing_view</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The setting of <code class="docutils literal notranslate"><span class="pre">timed</span></code> on the timing_view signifies to Pyramid that <code class="docutils literal notranslate"><span class="pre">timed</span></code>
is a valid <code class="docutils literal notranslate"><span class="pre">view_config</span></code> keyword argument now.  The <code class="docutils literal notranslate"><span class="pre">timing_view</span></code> custom
view deriver as registered above will only be active for any view defined with
a <code class="docutils literal notranslate"><span class="pre">timed=True</span></code> value passed as one of its <code class="docutils literal notranslate"><span class="pre">view_config</span></code> keywords.</p>
<p>For example, this view configuration will <em>not</em> be a timed view:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;home&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">home</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Home&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>But this view <em>will</em> have timing information added to the response headers:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nd">@view_config</span><span class="p">(</span><span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;home&#39;</span><span class="p">,</span> <span class="n">timed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">home</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Home&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>View derivers are unique in that they have access to most of the options
passed to <a class="reference internal" href="../api/config.html#pyramid.config.Configurator.add_view" title="pyramid.config.Configurator.add_view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyramid.config.Configurator.add_view()</span></code></a> in order to decide what
to do, and they have a chance to affect every view in the application.</p>
</div>
<div class="section" id="exception-views-and-view-derivers">
<span id="exception-view-derivers"></span><h3>Exception Views and View Derivers<a class="headerlink" href="#exception-views-and-view-derivers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A <a class="reference internal" href="../glossary.html#term-view-deriver"><span class="xref std std-term">view deriver</span></a> has the opportunity to wrap any view, including
an <a class="reference internal" href="../glossary.html#term-exception-view"><span class="xref std std-term">exception view</span></a>. In general this is fine, but certain view derivers
may wish to avoid doing certain things when handling exceptions. For example,
the <code class="docutils literal notranslate"><span class="pre">csrf_view</span></code> and <code class="docutils literal notranslate"><span class="pre">secured_view</span></code> built-in view derivers will not perform
security checks on exception views unless explicitly told to do so.</p>
<p>You can check for <code class="docutils literal notranslate"><span class="pre">info.exception_only</span></code> on the
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IViewDeriverInfo" title="pyramid.interfaces.IViewDeriverInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IViewDeriverInfo</span></code></a> object when wrapping the view
to determine whether you are wrapping an exception view or a normal view.</p>
</div>
<div class="section" id="ordering-view-derivers">
<h3>Ordering View Derivers<a class="headerlink" href="#ordering-view-derivers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By default, every new view deriver is added between the <code class="docutils literal notranslate"><span class="pre">decorated_view</span></code> and
<code class="docutils literal notranslate"><span class="pre">rendered_view</span></code> built-in derivers. It is possible to customize this ordering
using the <code class="docutils literal notranslate"><span class="pre">over</span></code> and <code class="docutils literal notranslate"><span class="pre">under</span></code> options. Each option can use the names of
other view derivers in order to specify an ordering. There should rarely be a
reason to worry about the ordering of the derivers except when the deriver
depends on other operations in the view pipeline.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">over</span></code> and <code class="docutils literal notranslate"><span class="pre">under</span></code> may also be iterables of constraints. For either
option, if one or more constraints was defined, at least one must be satisfied,
else a <a class="reference internal" href="../api/exceptions.html#pyramid.exceptions.ConfigurationError" title="pyramid.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.exceptions.ConfigurationError</span></code></a> will be raised. This may
be used to define fallback constraints if another deriver is missing.</p>
<p>Two sentinel values exist, <a class="reference internal" href="../api/viewderivers.html#pyramid.viewderivers.INGRESS" title="pyramid.viewderivers.INGRESS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pyramid.viewderivers.INGRESS</span></code></a> and
<a class="reference internal" href="../api/viewderivers.html#pyramid.viewderivers.VIEW" title="pyramid.viewderivers.VIEW"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pyramid.viewderivers.VIEW</span></code></a>, which may be used when specifying
constraints at the edges of the view pipeline. For example, to add a deriver
at the start of the pipeline you may use <code class="docutils literal notranslate"><span class="pre">under=INGRESS</span></code>.</p>
<p>It is not possible to add a view deriver under the <code class="docutils literal notranslate"><span class="pre">mapped_view</span></code> as the
<a class="reference internal" href="../glossary.html#term-view-mapper"><span class="xref std std-term">view mapper</span></a> is intimately tied to the signature of the user-defined
<a class="reference internal" href="../glossary.html#term-view-callable"><span class="xref std std-term">view callable</span></a>. If you simply need to know what the original view
callable was, it can be found as <code class="docutils literal notranslate"><span class="pre">info.original_view</span></code> on the provided
<a class="reference internal" href="../api/interfaces.html#pyramid.interfaces.IViewDeriverInfo" title="pyramid.interfaces.IViewDeriverInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyramid.interfaces.IViewDeriverInfo</span></code></a> object passed to every view
deriver.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The default constraints for any view deriver are <code class="docutils literal notranslate"><span class="pre">over='rendered_view'</span></code>
and <code class="docutils literal notranslate"><span class="pre">under='decorated_view'</span></code>. When escaping these constraints you must
take care to avoid cyclic dependencies between derivers. For example, if
you want to add a new view deriver before <code class="docutils literal notranslate"><span class="pre">secured_view</span></code> then
simply specifying <code class="docutils literal notranslate"><span class="pre">over='secured_view'</span></code> is not enough, because the
default is also under <code class="docutils literal notranslate"><span class="pre">decorated</span> <span class="pre">view</span></code> there will be an unsatisfiable
cycle. You must specify a valid <code class="docutils literal notranslate"><span class="pre">under</span></code> constraint as well, such as
<code class="docutils literal notranslate"><span class="pre">under=INGRESS</span></code> to fall between INGRESS and <code class="docutils literal notranslate"><span class="pre">secured_view</span></code> at the
beginning of the view pipeline.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using Hooks</a><ul>
<li><a class="reference internal" href="#changing-the-not-found-view">Changing the Not Found View</a></li>
<li><a class="reference internal" href="#changing-the-forbidden-view">Changing the Forbidden View</a></li>
<li><a class="reference internal" href="#changing-the-request-factory">Changing the Request Factory</a></li>
<li><a class="reference internal" href="#adding-methods-or-properties-to-a-request-object">Adding Methods or Properties to a Request Object</a></li>
<li><a class="reference internal" href="#changing-the-response-factory">Changing the Response Factory</a></li>
<li><a class="reference internal" href="#using-the-before-render-event">Using the Before Render Event</a></li>
<li><a class="reference internal" href="#using-response-callbacks">Using Response Callbacks</a></li>
<li><a class="reference internal" href="#using-finished-callbacks">Using Finished Callbacks</a></li>
<li><a class="reference internal" href="#changing-the-traverser">Changing the Traverser</a></li>
<li><a class="reference internal" href="#changing-how-pyramid-request-request-resource-url-generates-a-url">Changing How <code class="docutils literal notranslate"><span class="pre">pyramid.request.Request.resource_url()</span></code> Generates a URL</a></li>
<li><a class="reference internal" href="#changing-how-pyramid-treats-view-responses">Changing How Pyramid Treats View Responses</a></li>
<li><a class="reference internal" href="#using-a-view-mapper">Using a View Mapper</a></li>
<li><a class="reference internal" href="#registering-configuration-decorators">Registering Configuration Decorators</a></li>
<li><a class="reference internal" href="#registering-tweens">Registering Tweens</a><ul>
<li><a class="reference internal" href="#creating-a-tween">Creating a Tween</a></li>
<li><a class="reference internal" href="#registering-an-implicit-tween-factory">Registering an Implicit Tween Factory</a></li>
<li><a class="reference internal" href="#suggesting-implicit-tween-ordering">Suggesting Implicit Tween Ordering</a></li>
<li><a class="reference internal" href="#explicit-tween-ordering">Explicit Tween Ordering</a></li>
<li><a class="reference internal" href="#tween-conflicts-and-ordering-cycles">Tween Conflicts and Ordering Cycles</a></li>
<li><a class="reference internal" href="#displaying-tween-ordering">Displaying Tween Ordering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-a-third-party-view-route-or-subscriber-predicate">Adding a Third Party View, Route, or Subscriber Predicate</a><ul>
<li><a class="reference internal" href="#view-and-route-predicates">View and Route Predicates</a></li>
<li><a class="reference internal" href="#subscriber-predicates">Subscriber Predicates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#view-derivers">View Derivers</a><ul>
<li><a class="reference internal" href="#built-in-view-derivers">Built-in View Derivers</a></li>
<li><a class="reference internal" href="#custom-view-derivers">Custom View Derivers</a></li>
<li><a class="reference internal" href="#exception-views-and-view-derivers">Exception Views and View Derivers</a></li>
<li><a class="reference internal" href="#ordering-view-derivers">Ordering View Derivers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="subrequest.html"
                        title="前の章へ">Invoking a Subrequest</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="introspector.html"
                        title="次の章へ">Pyramid Configuration Introspection</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/narr/hooks.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="introspector.html" title="Pyramid Configuration Introspection"
             >次へ</a> |</li>
        <li class="right" >
          <a href="subrequest.html" title="Invoking a Subrequest"
             >前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 8月 13, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4 で生成しました。
    </div>
  </body>
</html>
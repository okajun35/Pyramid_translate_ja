# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../narr/configuration.rst:7
msgid "Application Configuration"
msgstr "(機械翻訳) アプリケーション構成"

#: ../../narr/configuration.rst:9
msgid ""
"Most people already understand \"configuration\" as settings that "
"influence the operation of an application.  For instance, it's easy to "
"think of the values in a ``.ini`` file parsed at application startup time"
" as \"configuration\". However, if you're reasonably open-minded, it's "
"easy to think of *code* as configuration too.  Since Pyramid, like most "
"other web application platforms, is a *framework*, it calls into code "
"that you write (as opposed to a *library*, which is code that exists "
"purely for you to call).  The act of plugging application code that "
"you've written into :app:`Pyramid` is also referred to within this "
"documentation as \"configuration\"; you are configuring :app:`Pyramid` to"
" call the code that makes up your application."
msgstr "ほとんどの人は、アプリケーションの動作に影響を与える設定として、すでに &quot;構成&quot;を理解しています。例えば、アプリケーションの起動時に\ &quot;configuration \&quot;として解析された `` .ini``ファイルの値を考えるのは簡単です。しかし、あなたが合理的にオープンであれば、設定として*コード*を考えるのは簡単です。 Pyramidは他のほとんどのWebアプリケーションプラットフォームと同様に、* framework *であるため、（あなたが呼び出すためのコードである*ライブラリ*とは対照的に）あなたが書くコードを呼び出します。あなたが書いたアプリケーションコードをapp： `Pyramid`に差し込む行為は、このドキュメント内では\&quot; configuration \ &quot;とも呼ばれます。あなたのアプリケーションを構成するコードを呼び出すために：app： `Pyramid`を設定しています。"

#: ../../narr/configuration.rst:21
msgid ""
"For information on ``.ini`` files for Pyramid applications see the "
":ref:`startup_chapter` chapter."
msgstr "Pyramidアプリケーションの `` .ini``ファイルについては、：ref： `startup_chapter`の章を参照してください。"

#: ../../narr/configuration.rst:24
msgid ""
"There are two ways to configure a :app:`Pyramid` application: "
":term:`imperative configuration` and :term:`declarative configuration`.  "
"Both are described below."
msgstr "app： `Pyramid`アプリケーション：：term：`必須の設定 `と：term：`宣言的な設定 &#39;の二つの方法があります。どちらも以下で説明します。"

#: ../../narr/configuration.rst:33
msgid "Imperative Configuration"
msgstr "指示的な構成"

#: ../../narr/configuration.rst:35
msgid ""
"\"Imperative configuration\" just means configuration done by Python "
"statements, one after the next.  Here's one of the simplest "
":app:`Pyramid` applications, configured imperatively:"
msgstr "\ &quot;命令的な設定\&quot;というのは、Pythonの文が次々に行う設定を意味します。ここでは、最も簡単なものの1つがapp： `Pyramid`アプリケーションです。"

#: ../../narr/configuration.rst:56
msgid ""
"We won't talk much about what this application does yet.  Just note that "
"the configuration statements take place underneath the ``if __name__ == "
"'__main__':`` stanza in the form of method calls on a "
":term:`Configurator` object (e.g., ``config.add_view(...)``).  These "
"statements take place one after the other, and are executed in order, so "
"the full power of Python, including conditionals, can be employed in this"
" mode of configuration."
msgstr "このアプリケーションが何をしているのかについてはまだ話しません。設定文は、 `：__name__ == &#39;__main __&#39;：` `スタンザの下で、：term：` Configurator`オブジェクト（例えば、 `` config.add_view ） ``）。これらのステートメントは順番に実行され、順番に実行されるため、条件を含むPythonの完全な機能をこの設定モードで使用できます。"

#: ../../narr/configuration.rst:71
msgid "Declarative Configuration"
msgstr "宣言的な構成"

#: ../../narr/configuration.rst:73
msgid ""
"It's sometimes painful to have all configuration done by imperative code,"
" because often the code for a single application may live in many files."
"  If the configuration is centralized in one place, you'll need to have "
"at least two files open at once to see the \"big picture\": the file that"
" represents the configuration, and the file that contains the "
"implementation objects referenced by the configuration.  To avoid this, "
":app:`Pyramid` allows you to insert :term:`configuration decoration` "
"statements very close to code that is referred to by the declaration "
"itself.  For example:"
msgstr "多くの場合、単一のアプリケーションのコードが多くのファイルに存在することがあるので、すべての設定を命令コードで行うのは苦しいことがあります。構成が1か所に集約されている場合は、少なくとも2つのファイルを一度に開いて「大きな画像」を表示する必要があります。構成を表すファイルと、そのファイルによって参照される実装オブジェクトを含むファイルです。構成。これを避けるために、：app： `Pyramid`は：宣言自体によって参照されるコードに非常に近い：term：` configuration decoration`ステートメントを挿入することを可能にします。例えば："

#: ../../narr/configuration.rst:92
msgid ""
"The mere existence of configuration decoration doesn't cause any "
"configuration registration to be performed.  Before it has any effect on "
"the configuration of a :app:`Pyramid` application, a configuration "
"decoration within application code must be found through a process known "
"as a :term:`scan`."
msgstr "構成デコレーションの存在だけでは、構成登録は実行されません。 a：app： `Pyramid`アプリケーションの設定に影響を与える前に、アプリケーションコード内の設定デコレーションをa：term：` scan`と呼ばれるプロセスを通して見つける必要があります。"

#: ../../narr/configuration.rst:97
msgid ""
"For example, the :class:`pyramid.view.view_config` decorator in the code "
"example above adds an attribute to the ``hello`` function, making it "
"available for a :term:`scan` to find it later."
msgstr "たとえば、上記のコード例の：class： `pyramid.view.view_config`デコレータは、` `hello``関数に属性を追加し、後でそれを見つけるために：term：` scan`で利用可能にします。"

#: ../../narr/configuration.rst:101
msgid ""
"A :term:`scan` of a :term:`module` or a :term:`package` and its "
"subpackages for decorations happens when the "
":meth:`pyramid.config.Configurator.scan` method is invoked: scanning "
"implies searching for configuration declarations in a package and its "
"subpackages.  For example:"
msgstr "：meth： `pyramid.config.Configurator.scan`メソッドが呼び出されると、term：` module`または `term：` package`のterm： `scan`が発生し、装飾のサブパッケージが発生します。パッケージとそのサブパッケージの構成宣言のためのものです。例えば："

#: ../../narr/configuration.rst:125
msgid ""
"The scanning machinery imports each module and subpackage in a package or"
" module recursively, looking for special attributes attached to objects "
"defined within a module.  These special attributes are typically attached"
" to code via the use of a :term:`decorator`.  For example, the "
":class:`~pyramid.view.view_config` decorator can be attached to a "
"function or instance method."
msgstr "スキャン機構は、パッケージまたはモジュール内の各モジュールおよびサブパッケージを再帰的にインポートし、モジュール内で定義されたオブジェクトに付加された特別な属性を探します。これらの特別な属性は、通常、：term： `decorator`を使用してコードに付加されます。たとえば、：class： `〜pyramid.view.view_config`デコレータは、関数またはインスタンスメソッドにアタッチすることができます。"

#: ../../narr/configuration.rst:132
msgid ""
"Once scanning is invoked, and :term:`configuration decoration` is found "
"by the scanner, a set of calls are made to a :term:`Configurator` on your"
" behalf. These calls replace the need to add imperative configuration "
"statements that don't live near the code being configured."
msgstr "スキャンが呼び出され、：term： `configuration decoration`がスキャナによって検出されると、あなたの代わりに：term：` Configurator`への一連の呼び出しが行われます。これらの呼び出しは、構成中のコードの近くには存在しない必須の構成ステートメントを追加する必要性を置き換えます。"

#: ../../narr/configuration.rst:137
msgid ""
"The combination of :term:`configuration decoration` and the invocation of"
" a :term:`scan` is collectively known as :term:`declarative "
"configuration`."
msgstr "term： `configuration decoration`とa：term：` scan`の呼び出しは、総称してterm： `declarative configuration`と呼ばれます。"

#: ../../narr/configuration.rst:140
msgid ""
"In the example above, the scanner translates the arguments to "
":class:`~pyramid.view.view_config` into a call to the "
":meth:`pyramid.config.Configurator.add_view` method, effectively:"
msgstr "上記の例では、スキャナは：class： `〜pyramid.view.view_config`の引数を：meth：` pyramid.config.Configurator.add_view`メソッドの呼び出しに変換して効果的に行います："

#: ../../narr/configuration.rst:149
msgid "Summary"
msgstr "概要"

#: ../../narr/configuration.rst:151
msgid ""
"There are two ways to configure a :app:`Pyramid` application: "
"declaratively and imperatively.  You can choose the mode with which "
"you're most comfortable; both are completely equivalent.  Examples in "
"this documentation will use both modes interchangeably."
msgstr "app： `Pyramid`アプリケーションを宣言的にかつ必須的に設定するには、2つの方法があります。最も快適なモードを選択できます。どちらも完全に同等です。このドキュメントの例では、両方のモードを同じ意味で使用します。"


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../narr/commandline.rst:4
msgid "Command-Line Pyramid"
msgstr "(機械翻訳) コマンドラインピラミッド"

#: ../../narr/commandline.rst:6
msgid ""
"Your :app:`Pyramid` application can be controlled and inspected using a "
"variety of command-line utilities.  These utilities are documented in "
"this chapter."
msgstr "Your：app： `Pyramid`アプリケーションは、さまざまなコマンドラインユーティリティを使用して制御および検査できます。これらのユーティリティは、この章で説明されています。"

#: ../../narr/commandline.rst:17
msgid "Displaying Matching Views for a Given URL"
msgstr "指定されたURLの一致するビューの表示"

#: ../../narr/commandline.rst:19
msgid "See also the output of :ref:`pviews --help <pviews_script>`."
msgstr "：ref： `pviews --helpの出力も参照してください。 <pviews_script> `。"

#: ../../narr/commandline.rst:21
msgid ""
"For a big application with several views, it can be hard to keep the view"
" configuration details in your head, even if you defined all the views "
"yourself. You can use the ``pviews`` command in a terminal window to "
"print a summary of matching routes and views for a given URL in your "
"application. The ``pviews`` command accepts two arguments. The first "
"argument to ``pviews`` is the path to your application's ``.ini`` file "
"and section name inside the ``.ini`` file which points to your "
"application.  This should be of the format ``config_file#section_name``. "
"The second argument is the URL to test for matching views.  The "
"``section_name`` may be omitted; if it is, it's considered to be "
"``main``."
msgstr "いくつかのビューを持つ大きなアプリケーションでは、すべてのビューを自分で定義したとしても、ビューの設定の詳細を頭に入れておくことは難しいでしょう。ターミナルウィンドウで `` pviews``コマンドを使うと、アプリケーション内の指定されたURLに対応するルートとビューの要約を表示できます。 `` pviews``コマンドは2つの引数を受け取ります。 `` pviews``の最初の引数はアプリケーションの `` .ini``ファイルへのパスで、 `.ini`ファイル内のセクション名はアプリケーションを指しています。これは、 `` config_file＃section_name``の形式でなければなりません。 2番目の引数は、一致するビューをテストするURLです。 `` section_name``は省略することができます。そうであれば、それは「主」とみなされます。"

#: ../../narr/commandline.rst:32
msgid ""
"Here is an example for a simple view configuration using "
":term:`traversal`:"
msgstr "以下は、単純なビュー設定の例です：term： `traversal`："

#: ../../narr/commandline.rst:49
msgid ""
"The output always has the requested URL at the top and below that all the"
" views that matched with their view configuration details. In this "
"example only one view matches, so there is just a single *View* section. "
"For each matching view, the full code path to the associated view "
"callable is shown, along with any permissions and predicates that are "
"part of that view configuration."
msgstr "出力には常に、要求されたURLがそのビュー構成の詳細と一致するすべてのビューの上部と下部に表示されます。この例では1つのビューのみが一致しているので、* View *セクションは1つだけです。一致するビューごとに、呼び出し可能な関連ビューへの完全なコードパスが、そのビュー設定の一部であるすべての権限と述部とともに表示されます。"

#: ../../narr/commandline.rst:55
msgid "A more complex configuration might generate something like this:"
msgstr "より複雑な設定では、次のようなものが生成される可能性があります。"

#: ../../narr/commandline.rst:101
msgid ""
"In this case, we are dealing with a :term:`URL dispatch` application. "
"This specific URL has two matching routes. The matching route information"
" is displayed first, followed by any views that are associated with that "
"route. As you can see from the second matching route output, a route can "
"be associated with more than one view."
msgstr "この例では、：term： `URL dispatch`アプリケーションを扱っています。この特定のURLには、2つの一致するルートがあります。一致するルート情報が最初に表示され、その後にそのルートに関連付けられたビューが表示されます。第2の一致するルート出力からわかるように、ルートは複数のビューに関連付けることができます。"

#: ../../narr/commandline.rst:107
msgid ""
"For a URL that doesn't match any views, ``pviews`` will simply print out "
"a *Not found* message."
msgstr "ビューと一致しないURLの場合、 `` pviews``は単に* Not found *メッセージを出力します。"

#: ../../narr/commandline.rst:118
msgid "The Interactive Shell"
msgstr "インタラクティブシェル"

#: ../../narr/commandline.rst:120
msgid "See also the output of :ref:`pshell --help <pshell_script>`."
msgstr "：ref： `pshell --helpの出力も参照してください。 <pshell_script> `。"

#: ../../narr/commandline.rst:122
msgid ""
"Once you've installed your program for development using ``pip install -e"
" .``, you can use an interactive Python shell to execute expressions in a"
" Python environment exactly like the one that will be used when your "
"application runs \"for real\".  To do so, use the ``pshell`` command line"
" utility."
msgstr "`` pip install -e .``を使って開発用にプログラムをインストールしたら、インタラクティブなPythonシェルを使ってPython環境で式を実行することができます\ &quot;これを行うには、 `` pshell``コマンドラインユーティリティを使用します。"

#: ../../narr/commandline.rst:127
msgid ""
"The argument to ``pshell`` follows the format "
"``config_file#section_name`` where ``config_file`` is the path to your "
"application's ``.ini`` file and ``section_name`` is the ``app`` section "
"name inside the ``.ini`` file which points to your application.  For "
"example, your application ``.ini`` file might have an ``[app:main]`` "
"section that looks like so:"
msgstr "`` pshell`の引数は `` config_file＃section_name``の形式に従います。 `` config_file``はアプリケーションの `` .ini``ファイルへのパスで、 `` section_name``は `` app``です。あなたのアプリケーションを指し示す `` .ini``ファイル内のセクション名。例えば、あなたのアプリケーションの `` .ini``ファイルには、次のような `` [app：main] ``セクションがあります："

#: ../../narr/commandline.rst:144
msgid ""
"If so, you can use the following command to invoke a debug shell using "
"the name ``main`` as a section name:"
msgstr "そのような場合は、次のコマンドを使用してセクション名として `` main``という名前を使用してデバッグシェルを呼び出すことができます："

#: ../../narr/commandline.rst:173
msgid ""
"The WSGI application that is loaded will be available in the shell as the"
" ``app`` global. Also, if the application that is loaded is the "
":app:`Pyramid` app with no surrounding :term:`middleware`, the ``root`` "
"object returned by the default :term:`root factory`, ``registry``, and "
"``request`` will be available."
msgstr "読み込まれたWSGIアプリケーションは、 `` app``グローバルとしてシェル内で利用可能になります。また、読み込まれたアプリケーションが：surrounding：term： `middleware`を持たない：app：` Pyramid`アプリケーションであれば、デフォルト：term： `ルートファクトリ`、 `` registry``によって返される ``ルート ``オブジェクト`と` `要求 &#39;&#39;が利用可能になります。"

#: ../../narr/commandline.rst:178
msgid ""
"You can also simply rely on the ``main`` default section name by omitting"
" any hash after the filename:"
msgstr "ファイル名の後にハッシュを省略することで、 `` main``のデフォルトのセクション名に頼ることもできます："

#: ../../narr/commandline.rst:185
msgid "Press ``Ctrl-D`` to exit the interactive shell (or ``Ctrl-Z`` on Windows)."
msgstr "対話シェルを終了するには `` Ctrl-D``を押します（Windowsでは `` Ctrl-Z``）。"

#: ../../narr/commandline.rst:194
msgid "Extending the Shell"
msgstr "シェルの拡張"

#: ../../narr/commandline.rst:196
msgid ""
"It is convenient when using the interactive shell often to have some "
"variables significant to your application already loaded as globals when "
"you start the ``pshell``. To facilitate this, ``pshell`` will look for a "
"special ``[pshell]`` section in your INI file and expose the subsequent "
"key/value pairs to the shell.  Each key is a variable name that will be "
"global within the pshell session; each value is a :term:`dotted Python "
"name`. If specified, the special key ``setup`` should be a :term:`dotted "
"Python name` pointing to a callable that accepts the dictionary of "
"globals that will be loaded into the shell. This allows for some custom "
"initializing code to be executed each time the ``pshell`` is run. The "
"``setup`` callable can also be specified from the commandline using the "
"``--setup`` option which will override the key in the INI file."
msgstr "`` pshell``を起動したときに、対話型シェルを使って、アプリケーションにとって重要な変数を既にグローバルとしてロードしている場合に便利です。これを容易にするために、 `` pshell``はINIファイル内の特別な `` [pshell] ``セクションを探し、後続のキーと値のペアをシェルに公開します。各キーは、pshellセッション内でグローバルになる変数名です。各値は：term： `点線のPython名`です。指定した場合、特殊キー `` setup``は：term： `ドット付きPython名`でなければなりません。シェルにロードされるグローバルの辞書を受け付ける呼び出し可能ファイルを指します。これにより、 `` pshell``が実行されるたびにカスタム初期化コードが実行されるようになります。 INIファイルのキーを上書きする `` --setup``オプションを使用して、コマンドラインから `` setup``呼び出し可能ファイルを指定することもできます。"

#: ../../narr/commandline.rst:209
msgid ""
"For example, you want to expose your model to the shell along with the "
"database session so that you can mutate the model on an actual database. "
"Here, we'll assume your model is stored in the ``myapp.models`` package."
msgstr "たとえば、実際のデータベースでモデルを変更できるように、モデルをシェルに公開してデータベースセッションとしたいとします。ここでは、モデルが `` myapp.models``パッケージに格納されていると仮定します。"

#: ../../narr/commandline.rst:222
msgid ""
"By defining the ``setup`` callable, we will create the module "
"``myapp.lib.pshell`` containing a callable named ``setup`` that will "
"receive the global environment before it is exposed to the shell. Here we"
" mutate the environment's request as well as add a new value containing a"
" WebTest version of the application to which we can easily submit "
"requests."
msgstr "`` setup``を呼び出し可能にすることで、シェルに公開される前に地球環境を受け取る `` setup``という名前の呼び出し可能モジュールを含む `` myapp.lib.pshell``モジュールを作成します。ここでは、環境の要求を変更し、要求を簡単に提出できるWebTestバージョンのアプリケーションを含む新しい値を追加します。"

#: ../../narr/commandline.rst:239
msgid ""
"When this INI file is loaded, the extra variables ``m``, ``session`` and "
"``t`` will be available for use immediately. Since a ``setup`` callable "
"was also specified, it is executed and a new variable ``testapp`` is "
"exposed, and the request is configured to generate urls from the host "
"``http://www.example.com``. For example:"
msgstr "このINIファイルがロードされると、余分な変数 `` m``、 `` session``、 `` t``がすぐに利用できるようになります。 `` setup``呼び出し可能関数も指定されているので、それが実行され、新しい変数 `` testapp``が公開され、リクエストはホスト `` http：// www.example.com``からURLを生成するように設定されます`。例えば："

#: ../../narr/commandline.rst:274
msgid "Alternative Shells"
msgstr "代替シェル"

#: ../../narr/commandline.rst:276
msgid ""
"The ``pshell`` command can be easily extended with alternate REPLs if the"
" default python REPL is not satisfactory. Assuming you have a binding "
"installed such as ``pyramid_ipython`` it will normally be auto-selected "
"and used. You may also specifically invoke your choice with the ``-p "
"choice`` or ``--python-shell choice`` option."
msgstr "`` pshell``コマンドは、デフォルトのpython REPLが満足のいくものでなければ、別のREPLで簡単に拡張できます。 `` pyramid_ipython``のようなバインディングがインストールされていると仮定すると、通常自動的に選択されて使用されます。また、 `` -p choice``や `` --python-shell choice``オプションを使って選択を呼び出すこともできます。"

#: ../../narr/commandline.rst:286
msgid "You may use the ``--list-shells`` option to see the available shells."
msgstr "使用可能なシェルを見るには、 `` --list-shells``オプションを使用してください。"

#: ../../narr/commandline.rst:296
msgid ""
"If you want to use a shell that isn't supported out of the box, you can "
"introduce a new shell by registering an entry point in your ``setup.py``:"
msgstr "箱の中でサポートされていないシェルを使いたい場合は、 `` setup.py``にエントリポイントを登録することで新しいシェルを導入できます："

#: ../../narr/commandline.rst:309
msgid ""
"And then your shell factory should return a function that accepts two "
"arguments, ``env`` and ``help``, which would look like this:"
msgstr "そして、あなたのシェルファクトリは `` env``と `` help``という2つの引数を受け付ける関数を返すべきです。"

#: ../../narr/commandline.rst:320
msgid ""
"User-defined shells may be registered using entry points. Prior to this "
"the only supported shells were ``ipython``, ``bpython`` and ``python``."
msgstr "エントリポイントを使用してユーザ定義のシェルを登録することができます。それ以前はサポートされていたシェルは `` ipython``、 `` bpython``、 `` python``でした。"

#: ../../narr/commandline.rst:324
msgid ""
"``ipython`` and ``bpython`` have been moved into their respective "
"packages ``pyramid_ipython`` and ``pyramid_bpython``."
msgstr "`` ipython``と `` bpython``はそれぞれのパッケージ `` ​​pyramid_ipython``と `` pyramid_bpython``に移されました。"

#: ../../narr/commandline.rst:329
msgid "Setting a Default Shell"
msgstr "デフォルトシェルの設定"

#: ../../narr/commandline.rst:331
msgid ""
"You may use the ``default_shell`` option in your ``[pshell]`` ini section"
" to specify a list of preferred shells."
msgstr "あなたの `` [pshell] `` iniセクションで `` default_shell``オプションを使って好みのシェルのリストを指定することができます。"

#: ../../narr/commandline.rst:350
msgid "Displaying All Application Routes"
msgstr "すべてのアプリケーションルートの表示"

#: ../../narr/commandline.rst:352
msgid "See also the output of :ref:`proutes --help <proutes_script>`."
msgstr "：ref： `proutes --helpの出力も参照してください。 <proutes_script> `。"

#: ../../narr/commandline.rst:354
msgid ""
"You can use the ``proutes`` command in a terminal window to print a "
"summary of routes related to your application.  Much like the ``pshell`` "
"command (see :ref:`interactive_shell`), the ``proutes`` command accepts "
"one argument with the format ``config_file#section_name``.  The "
"``config_file`` is the path to your application's ``.ini`` file, and "
"``section_name`` is the ``app`` section name inside the ``.ini`` file "
"which points to your application.  By default, the ``section_name`` is "
"``main`` and can be omitted."
msgstr "ターミナルウィンドウで `` proutes``コマンドを使うと、アプリケーションに関連するルートの要約を表示できます。 `` pshell`コマンド（ref： `interactive_shell`参照）と同様に、` `proutes``コマンドは、` `config_file＃section_name``という形式の引数を受け取ります。 `` config_file``はあなたのアプリケーションの `` .ini``ファイルへのパスです。 `` section_name``はあなたのアプリケーションを指し示す `` .ini``ファイル内の `` app``セクション名です。デフォルトでは、 `` section_name``は `` main``であり省略することができます。"

#: ../../narr/commandline.rst:362
msgid "For example:"
msgstr "例えば："

#: ../../narr/commandline.rst:381
msgid ""
"``proutes`` generates a table with four columns: *Name*, *Pattern*, "
"*View*, and *Method*.  The items listed in the Name column are route "
"names, the items listed in the Pattern column are route patterns, the "
"items listed in the View column are representations of the view callable "
"that will be invoked when a request matches the associated route pattern,"
" and the items listed in the Method column are the request methods that "
"are associated with the route name. The View column may show "
"``<unknown>`` if no associated view callable could be found.  The Method "
"column, for the route name, may show either ``<route mismatch>`` if the "
"view callable does not accept any of the route's request methods, or "
"``*`` if the view callable will accept any of the route's request "
"methods.  If no routes are configured within your application, nothing "
"will be printed to the console when ``proutes`` is executed."
msgstr "`` proutes``は* Name *、* Pattern *、* View *、* Method *の4つのカラムを持つテーブルを生成します。 「名前」列にリストされている項目はルート名、「パターン」列にリストされている項目はルート・パターン、「ビュー」列にリストされている項目は、要求が関連するルート・パターンと一致したときに呼び出される、 [メソッド]列にリストされている項目は、ルート名に関連付けられているリクエストメソッドです。 [表示]列には、 <unknown>関連するビュー呼び出し可能なものが見つからない場合は ``ルート名のMethodカラムには、 `` <route mismatch> ``呼び出し可能なビューがルートのリクエストメソッドのどれも受け入れない場合は `` ``、呼び出し可能なビューがルートのリクエストメソッドのいずれかを受け入れる場合は `` * ``アプリケーション内でルートが設定されていない場合、 `` proutes``が実行されるとコンソールに何も出力されません。"

#: ../../narr/commandline.rst:394
msgid ""
"It is convenient when using the ``proutes`` command often to configure "
"which columns and the order you would like to view them. To facilitate "
"this, ``proutes`` will look for a special ``[proutes]`` section in your "
"``.ini`` file and use those as defaults."
msgstr "`` proutes``コマンドを頻繁に使用して、表示する列や順序を設定すると便利です。これを容易にするため、 `` proutes``はあなたの `` .ini``ファイル中の特別な `` [proutes] ``セクションを探し、デフォルトとして使用します。"

#: ../../narr/commandline.rst:399
msgid "For example you may remove the request method and place the view first:"
msgstr "たとえば、リクエストメソッドを削除して、ビューを最初に配置することができます。"

#: ../../narr/commandline.rst:409
msgid "You can also separate the formats with commas or spaces:"
msgstr "コンマまたはスペースでフォーマットを区切ることもできます。"

#: ../../narr/commandline.rst:420
msgid ""
"If you want to temporarily configure the columns and order, there is the "
"argument ``--format``, which is a comma separated list of columns you "
"want to include. The current available formats are ``name``, ``pattern``,"
" ``view``, and ``method``."
msgstr "一時的に列と順序を設定したい場合は、 `` --format``という引数があります。これは、カンマ区切りの列のリストです。現在利用可能なフォーマットは ``名前 ``、 ``パターン ``、 ``ビュー ``、 ``メソッド ``です。"

#: ../../narr/commandline.rst:433
msgid "Displaying \"Tweens\""
msgstr "\ &quot;Tweens \"

#: ../../narr/commandline.rst:435
msgid "See also the output of :ref:`ptweens --help <ptweens_script>`."
msgstr "：ref： `ptweens --helpの出力も参照してください。 <ptweens_script> `。"

#: ../../narr/commandline.rst:437
msgid ""
"A :term:`tween` is a bit of code that sits between the main Pyramid "
"application request handler and the WSGI application which calls it.  A "
"user can get a representation of both the implicit tween ordering (the "
"ordering specified by calls to "
":meth:`pyramid.config.Configurator.add_tween`) and the explicit tween "
"ordering (specified by the ``pyramid.tweens`` configuration setting) "
"using the ``ptweens`` command.  Tween factories will show up represented "
"by their standard Python dotted name in the ``ptweens`` output."
msgstr "A：term： `tween`はPyramidの主なアプリケーションリクエストハンドラとそれを呼び出すWSGIアプリケーションの間にあるコードです。暗黙的なトゥイーンの順序（：meth： `pyramid.config.Configurator.add_tween`の呼び出しで指定された順序）と明示的なトゥイーンの順序（` `pyramid.tweens``設定の設定で指定された順序） `` ptweens``コマンドを使用します。 Tweenファクトリは、 `` ptweens``の出力に標準的なPythonの点線の名前で表されます。"

#: ../../narr/commandline.rst:445
msgid ""
"For example, here's the ``ptweens`` command run against a system "
"configured without any explicit tweens:"
msgstr "たとえば、明示的なtweensなしで設定されたシステムに対して `` ptweens``コマンドを実行すると、次のようになります。"

#: ../../narr/commandline.rst:463
msgid ""
"Here's the ``ptweens`` command run against a system configured *with* "
"explicit tweens defined in its ``development.ini`` file:"
msgstr "`` development.ini``ファイルで*明示的に定義されたtweensで設定されたシステムに対して実行される `` ptweens``コマンドは次のとおりです："

#: ../../narr/commandline.rst:491
msgid ""
"Here's the application configuration section of the ``development.ini`` "
"used by the above ``ptweens`` command which reports that the explicit "
"tween chain is used:"
msgstr "上記の `` ptweens``コマンドで使用される `` development.ini``のアプリケーション設定セクションは、明示的なトゥイーンチェーンが使用されていることを報告します："

#: ../../narr/commandline.rst:511
msgid "See :ref:`registering_tweens` for more information about tweens."
msgstr "トゥイーンの詳細については、ref： `registration_tweens`を参照してください。"

#: ../../narr/commandline.rst:521
msgid "Invoking a Request"
msgstr "リクエストの呼び出し"

#: ../../narr/commandline.rst:523
msgid "See also the output of :ref:`prequest --help <prequest_script>`."
msgstr "：ref： `prequest --helpの出力も参照してください。 <prequest_script> `。"

#: ../../narr/commandline.rst:525
msgid ""
"You can use the ``prequest`` command-line utility to send a request to "
"your application and see the response body without starting a server."
msgstr "`` prequest``コマンドラインユーティリティを使ってアプリケーションにリクエストを送信し、サーバを起動せずにレスポンスボディを見ることができます。"

#: ../../narr/commandline.rst:528
msgid "There are two required arguments to ``prequest``:"
msgstr "`` prequest``には二つの必須引数があります："

#: ../../narr/commandline.rst:530
msgid ""
"The config file/section: follows the format ``config_file#section_name``,"
" where ``config_file`` is the path to your application's ``.ini`` file "
"and ``section_name`` is the ``app`` section name inside the ``.ini`` "
"file.  The ``section_name`` is optional; it defaults to ``main``.  For "
"example: ``development.ini``."
msgstr "設定ファイル/セクションは `` config_file＃section_name``フォーマットに従います。 `` config_file``はアプリケーションの `` .ini``ファイルへのパスで、 `` section_name``は `` app``セクションです`` .ini``ファイルの中の名前。 `` section_name``はオプションです。デフォルトは `` main``です。例えば、 `` development.ini``です。"

#: ../../narr/commandline.rst:536
msgid ""
"The path: this should be the non-URL-quoted path element of the URL to "
"the resource you'd like to be rendered on the server.  For example, "
"``/``."
msgstr "パス：これは、サーバー上でレンダリングするリソースへのURLのURLで引用されていないパス要素です。たとえば、 `` / ``とします。"

#: ../../narr/commandline.rst:539
msgid "For example::"
msgstr "例えば：："

#: ../../narr/commandline.rst:543
msgid ""
"This will print the body of the response to the console on which it was "
"invoked."
msgstr "これにより、応答の本体が呼び出されたコンソールに表示されます。"

#: ../../narr/commandline.rst:546
msgid ""
"Several options are supported by ``prequest``.  These should precede any "
"config file name or URL."
msgstr "いくつかのオプションは `` prequest``でサポートされています。これらは、設定ファイル名またはURLの前に置く必要があります。"

#: ../../narr/commandline.rst:549
msgid ""
"``prequest`` has a ``-d`` (i.e., ``--display-headers``) option which "
"prints the status and headers returned by the server before the output::"
msgstr "`` prequest``には出力前にサーバから返されたステータスとヘッダを出力する `` -d``（つまり `` --display-headers``）オプションがあります："

#: ../../narr/commandline.rst:554
msgid ""
"This will print the status, headers, and the body of the response to the "
"console."
msgstr "これにより、コンソールへの応答のステータス、ヘッダー、および本文が出力されます。"

#: ../../narr/commandline.rst:557
msgid "You can add request header values by using the ``--header`` option::"
msgstr "`--header``オプションを使ってリクエストヘッダの値を追加することができます::"

#: ../../narr/commandline.rst:561
msgid ""
"Headers are added to the WSGI environment by converting them to their "
"CGI/WSGI equivalents (e.g., ``Host=example.com`` will insert the "
"``HTTP_HOST`` header variable as the value ``example.com``).  Multiple "
"``--header`` options can be supplied.  The special header value "
"``content-type`` sets the ``CONTENT_TYPE`` in the WSGI environment."
msgstr "ヘッダは、CGI / WSGIに相当するものに変換することでWSGI環境に追加されます（例えば `` Host = example.com``は `` example.com``の値として `` HTTP_HOST``ヘッダ変数を挿入します）。複数の `--header``オプションを指定できます。特別なヘッダ値 `` content-type``は、WSGI環境で `` CONTENT_TYPE``を設定します。"

#: ../../narr/commandline.rst:567
msgid ""
"By default, ``prequest`` sends a ``GET`` request.  You can change this by"
" using the ``-m`` (aka ``--method``) option.  ``GET``, ``HEAD``, "
"``POST``, and ``DELETE`` are currently supported.  When you use ``POST``,"
" the standard input of the ``prequest`` process is used as the ``POST`` "
"body::"
msgstr "デフォルトでは、 `` prequest``は `` GET``要求を送信します。これを変更するには、 `` -m``（別名 `` --method``）オプションを使用します。現在、 `` GET``、 `` HEAD``、 `` POST``、 `` DELETE``がサポートされています。 `` POST``を使うと `` prequest``プロセスの標準入力が `` POST``本体として使われます::"

#: ../../narr/commandline.rst:576
msgid "Using Custom Arguments to Python when Running ``p*`` Scripts"
msgstr "`` p * ``スクリプトを実行するときのPythonへのカスタム引数の使用"

#: ../../narr/commandline.rst:580
msgid ""
"Each of Pyramid's console scripts (``pserve``, ``pviews``, etc.) can be "
"run directly using ``python3 -m``, allowing custom arguments to be sent "
"to the Python interpreter at runtime. For example::"
msgstr "Pyramidのコンソールスクリプト（ `` pserve``、 `` pviews``など）は、 `` python3 -m``を使って直接実行でき、実行時にカスタム引数をPythonインタプリタに送ることができます。例えば：："

#: ../../narr/commandline.rst:595
msgid "Showing All Installed Distributions and Their Versions"
msgstr "インストールされているすべてのディストリビューションとそのバージョンの表示"

#: ../../narr/commandline.rst:599
msgid "See also the output of :ref:`pdistreport --help <pdistreport_script>`."
msgstr "：ref： `pdistreport --helpの出力も参照してください。 <pdistreport_script> `。"

#: ../../narr/commandline.rst:602
msgid ""
"You can use the ``pdistreport`` command to show the :app:`Pyramid` "
"version in use, the Python version in use, and all installed versions of "
"Python distributions in your Python environment::"
msgstr "`` pdistreport``コマンドを使って：app： `Pyramid`のバージョン、使用しているPythonのバージョン、Python環境のすべてのPythonディストリビューションのバージョンを表示することができます::"

#: ../../narr/commandline.rst:616
msgid ""
"``pdistreport`` takes no options.  Its output is useful to paste into a "
"pastebin when you are having problems and need someone with more "
"familiarity with Python packaging and distribution than you have to look "
"at your environment."
msgstr "`` pdistreport``オプションはありません。その出力は、問題を抱えているときにペーストビンに貼り付けるのに便利です。あなたの環境を見なければならないよりPythonのパッケージ化と配布に精通した人が必要です。"

#: ../../narr/commandline.rst:625
msgid "Writing a Script"
msgstr "スクリプトを書く"

#: ../../narr/commandline.rst:627
msgid ""
"All web applications are, at their hearts, systems which accept a request"
" and return a response.  When a request is accepted by a :app:`Pyramid` "
"application, the system receives state from the request which is later "
"relied on by your application code.  For example, one :term:`view "
"callable` may assume it's working against a request that has a "
"``request.matchdict`` of a particular composition, while another assumes "
"a different composition of the matchdict."
msgstr "すべてのWebアプリケーションは、要求を受け入れて応答を返すシステムです。 ：app： `Pyramid`アプリケーションによって要求が受け入れられると、システムは要求から状態を受け取ります。要求は、後でアプリケーションコードに依存します。たとえば、term： `view callable`は、特定のコンポジションの` `request.matchdict``を持つリクエストに対して動作していると仮定していますが、別のものはmatchdictの異なる構成を想定しています。"

#: ../../narr/commandline.rst:634
msgid ""
"In the meantime, it's convenient to be able to write a Python script that"
" can work \"in a Pyramid environment\", for instance to update database "
"tables used by your :app:`Pyramid` application.  But a \"real\" Pyramid "
"environment doesn't have a completely static state independent of a "
"request; your application (and Pyramid itself) is almost always reliant "
"on being able to obtain information from a request.  When you run a "
"Python script that simply imports code from your application and tries to"
" run it, there just is no request data, because there isn't any real web "
"request.  Therefore some parts of your application and some Pyramid APIs "
"will not work."
msgstr "それと同時に、：app： `Pyramid`アプリケーションで使用されるデータベーステーブルを更新するなど、Pyramid環境で動作するPythonスクリプトを書くことが便利です。しかし、\ &quot;実\&quot;ピラミッド環境は、要求に依存しない完全に静的な状態を持っていません。あなたのアプリケーション（とPyramid自体）は、ほとんどの場合、要求から情報を得ることに頼っています。アプリケーションからコードを単純にインポートして実行しようとするPythonスクリプトを実行すると、実際のWeb要求がないため、要求データはありません。したがって、アプリケーションのいくつかの部分といくつかのPyramid APIは動作しません。"

#: ../../narr/commandline.rst:644
msgid ""
"For this reason, :app:`Pyramid` makes it possible to run a script in an "
"environment much like the environment produced when a particular "
":term:`request` reaches your :app:`Pyramid` application.  This is "
"achieved by using the :func:`pyramid.paster.bootstrap` command in the "
"body of your script."
msgstr "このため、：app： `Pyramid`は、特定の：term：` request`があなたの：app： `Pyramid`アプリケーションに到達したときに生成される環境のような環境でスクリプトを実行することを可能にします。これは、スクリプト本体に：func： `pyramid.paster.bootstrap`コマンドを使用することで実現します。"

#: ../../narr/commandline.rst:649
msgid ":func:`pyramid.paster.bootstrap`"
msgstr "：func： `pyramid.paster.bootstrap`"

#: ../../narr/commandline.rst:652
msgid ""
"Added the ability for ``bootstrap`` to cleanup automatically via the "
"``with`` statement."
msgstr "`` boot```を `` with``文で自動的にクリーンアップする機能を追加しました。"

#: ../../narr/commandline.rst:656
msgid ""
"In the simplest case, :func:`pyramid.paster.bootstrap` can be used with a"
" single argument, which accepts the :term:`PasteDeploy` ``.ini`` file "
"representing your Pyramid application's configuration as a single "
"argument:"
msgstr "最も単純なケースでは、：func： `pyramid.paster.bootstrap`はPyramidアプリケーションの設定を単一の引数として表す：term：` PasteDeploy` `` .ini``ファイルを受け入れる単一の引数で使用できます："

#: ../../narr/commandline.rst:667
msgid ""
":func:`pyramid.paster.bootstrap` returns a dictionary containing "
"framework-related information.  This dictionary will always contain a "
":term:`request` object as its ``request`` key."
msgstr "：func： `pyramid.paster.bootstrap`は、フレームワーク関連の情報を含む辞書を返します。この辞書は常に：term： `request`オブジェクトを` `request``キーとして含んでいます。"

#: ../../narr/commandline.rst:671
msgid ""
"The following keys are available in the ``env`` dictionary returned by "
":func:`pyramid.paster.bootstrap`:"
msgstr "func： `pyramid.paster.bootstrap`：以下のキーは、` `env``ディクショナリで利用可能です。"

#: ../../narr/commandline.rst:674
msgid "request"
msgstr "要求"

#: ../../narr/commandline.rst:676
msgid ""
"A :class:`pyramid.request.Request` object implying the current request "
"state for your script."
msgstr "A：class： `pyramid.request.Request`オブジェクトはあなたのスクリプトの現在の要求状態を意味します。"

#: ../../narr/commandline.rst:679
msgid "app"
msgstr "アプリ"

#: ../../narr/commandline.rst:681
msgid "The :term:`WSGI` application object generated by bootstrapping."
msgstr "ブートストラップによって生成される：term： `WSGI`アプリケーションオブジェクト。"

#: ../../narr/commandline.rst:683
msgid "root"
msgstr "ルート"

#: ../../narr/commandline.rst:685
msgid ""
"The :term:`resource` root of your :app:`Pyramid` application.  This is an"
" object generated by the :term:`root factory` configured in your "
"application."
msgstr "あなたの：app： `Pyramid`アプリケーションの：term：` resource`ルートです。これは、アプリケーションで設定された：term： `ルートファクトリ &#39;によって生成されるオブジェクトです。"

#: ../../narr/commandline.rst:689
msgid "registry"
msgstr "レジストリ"

#: ../../narr/commandline.rst:691
msgid "The :term:`application registry` of your :app:`Pyramid` application."
msgstr "あなたの：app： `Pyramid`アプリケーションの：term：`アプリケーションレジストリ。"

#: ../../narr/commandline.rst:693
msgid "closer"
msgstr "クローザー"

#: ../../narr/commandline.rst:695
msgid ""
"A parameterless callable that can be used to pop an internal "
":app:`Pyramid` threadlocal stack (used by "
":func:`pyramid.threadlocal.get_current_registry` and "
":func:`pyramid.threadlocal.get_current_request`) when your scripting job "
"is finished."
msgstr "スクリプティングジョブが終了したときにinternal：app： `Pyramid`スレッドローカルスタックをポップするために使用できるパラメータなしの呼び出し可能ファイル（：func：` pyramid.threadlocal.get_current_registry`と：func： `pyramid.threadlocal.get_current_request`） 。"

#: ../../narr/commandline.rst:700
msgid ""
"Let's assume that the ``/path/to/my/development.ini`` file used in the "
"example above looks like so:"
msgstr "上記の例で使用されている `` / path / to / my / development.ini``ファイルが次のようになっていると仮定しましょう："

#: ../../narr/commandline.rst:717
msgid ""
"The configuration loaded by the above bootstrap example will use the "
"configuration implied by the ``[pipeline:main]`` section of your "
"configuration file by default.  Specifying "
"``/path/to/my/development.ini`` is logically equivalent to specifying "
"``/path/to/my/development.ini#main``.  In this case, we'll be using a "
"configuration that includes an ``app`` object which is wrapped in the "
"Paste \"translogger\" :term:`middleware` (which logs requests to the "
"console)."
msgstr "上記のブートストラップの例で読み込まれた設定は、デフォルトで設定ファイルの `` [pipeline：main] ``セクションが暗示する設定を使用します。 `` / path / to / my / development.ini``を指定することは、論理的には `` / path / to / my / development.ini＃main``を指定することと同じです。この場合、ペースト\ &quot;translogger \&quot;：term： `middleware`（リクエストをコンソールに記録する）にラップされた` `app``オブジェクトを含む設定を使用します。"

#: ../../narr/commandline.rst:725
msgid ""
"You can also specify a particular *section* of the PasteDeploy ``.ini`` "
"file to load instead of ``main``:"
msgstr "`` main``の代わりに読み込むPasteDeploy `` .ini``ファイルの特定の*セクション*を指定することもできます："

#: ../../narr/commandline.rst:735
msgid ""
"The above example specifies the ``another`` ``app``, ``pipeline``, or "
"``composite`` section of your PasteDeploy configuration file. The ``app``"
" object present in the ``env`` dictionary returned by "
":func:`pyramid.paster.bootstrap` will be a :app:`Pyramid` :term:`router`."
msgstr "上記の例では、PasteDeploy設定ファイルの `` app``、 `` pipeline``、または `` composite``セクションを指定しています。 ：func： `pyramid.paster.bootstrap`によって返される` `env``辞書にある` `app``オブジェクトは、：app：` Pyramid`：term： `router`になります。"

#: ../../narr/commandline.rst:742
msgid "Changing the Request"
msgstr "リクエストの変更"

#: ../../narr/commandline.rst:744
msgid ""
"By default, Pyramid will generate a request object in the ``env`` "
"dictionary for the URL ``http://localhost:80/``. This means that any URLs"
" generated by Pyramid during the execution of your script will be "
"anchored here. This is generally not what you want."
msgstr "デフォルトでは、Pyramidは `` env``ディクショナリに `` http：// localhost：80 / ``というURLのリクエストオブジェクトを生成します。つまり、スクリプトの実行中にPyramidによって生成されたURLは、ここに固定されます。これは一般的にあなたが望むものではありません。"

#: ../../narr/commandline.rst:749
msgid "So how do we make Pyramid generate the correct URLs?"
msgstr "それでは、ピラミッドに正しいURLを生成させるにはどうしたらいいですか？"

#: ../../narr/commandline.rst:751
msgid "Assuming that you have a route configured in your application like so:"
msgstr "あなたのアプリケーションで以下のようにルートを設定したと仮定します："

#: ../../narr/commandline.rst:757
msgid ""
"You need to inform the Pyramid environment that the WSGI application is "
"handling requests from a certain base. For example, we want to simulate "
"mounting our application at `https://example.com/prefix`, to ensure that "
"the generated URLs are correct for our deployment. This can be done by "
"either mutating the resulting request object, or more simply by "
"constructing the desired request and passing it into "
":func:`~pyramid.paster.bootstrap`:"
msgstr "WSGIアプリケーションが特定のベースからの要求を処理していることをPyramid環境に通知する必要があります。たとえば、アプリケーションを `https：// example.com / prefix`にマウントすることをシミュレートして、生成されたURLがGoogleのデプロイメントに適していることを確認します。これは、結果の要求オブジェクトを変更するか、または単に目的のリクエストを作成して、それをfunc： `〜pyramid.paster.bootstrap`に渡すことによって行うことができます："

#: ../../narr/commandline.rst:774
msgid "Now you can readily use Pyramid's APIs for generating URLs:"
msgstr "これで、PyramidのAPIを使用してURLを生成できます。"

#: ../../narr/commandline.rst:783
msgid "Cleanup"
msgstr "掃除"

#: ../../narr/commandline.rst:785
msgid ""
"If you're using the ``with``-statement variant then there's nothing to "
"worry about. However if you're using the returned environment directly "
"then when your scripting logic finishes, it's good manners to call the "
"``closer`` callback:"
msgstr "`` with``ステートメントバリアントを使用している場合、心配することはありません。しかし、スクリプトロジックが終了したときに返された環境を直接使用している場合は、 `` close``コールバックを呼び出すのがよいでしょう。"

#: ../../narr/commandline.rst:801
msgid "Setting Up Logging"
msgstr "ロギングの設定"

#: ../../narr/commandline.rst:803
msgid ""
"By default, :func:`pyramid.paster.bootstrap` does not configure logging "
"parameters present in the configuration file.  If you'd like to configure"
" logging based on ``[logger]`` and related sections in the configuration "
"file, use the following command:"
msgstr "デフォルトでは、：func： `pyramid.paster.bootstrap`は設定ファイルに存在するロギングパラメータを設定しません。 `` [logger] ``と設定ファイルの関連するセクションに基づいてロギングを設定するには、以下のコマンドを使用します："

#: ../../narr/commandline.rst:813
msgid ""
"See :ref:`logging_chapter` for more information on logging within "
":app:`Pyramid`."
msgstr "app： `Pyramid`の中でのロギングの詳細については：ref：` logging_chapter`を参照してください。"

#: ../../narr/commandline.rst:823
msgid "Making Your Script into a Console Script"
msgstr "スクリプトをコンソールスクリプトにする"

#: ../../narr/commandline.rst:825
msgid ""
"A \"console script\" is :term:`setuptools` terminology for a script that "
"gets installed into the ``bin`` directory of a Python :term:`virtual "
"environment` (or \"base\" Python environment) when a :term:`distribution`"
" which houses that script is installed. Because it's installed into the "
"``bin`` directory of a virtual environment when the distribution is "
"installed, it's a convenient way to package and distribute functionality "
"that you can call from the command-line. It's often more convenient to "
"create a console script than it is to create a ``.py`` script and "
"instruct people to call it with the \"right\" Python interpreter. A "
"console script generates a file that lives in ``bin``, and when it's "
"invoked it will always use the \"right\" Python environment, which means "
"it will always be invoked in an environment where all the libraries it "
"needs (such as Pyramid) are available."
msgstr "\ &quot;コンソールスクリプト\&quot;は次のようになります：term： `` setuptools`：Pythonの `` bin``ディレクトリにインストールされるスクリプトの用語です：term： `virtual environment`（または\&quot; base \ &quot;Python環境） a：そのスクリプトを格納しているterm： `distribution`がインストールされています。ディストリビューションのインストール時に仮想環境の `` bin``ディレクトリにインストールされるので、コマンドラインから呼び出せる機能をパッケージ化して配布するのに便利です。 `` .py``スクリプトを作成し、人々に\ &quot;右\&quot; Pythonインタプリタで呼び出すように指示するよりもコンソールスクリプトを作成するほうが便利です。コンソールスクリプトは `` bin``に​​存在するファイルを生成し、それが呼び出されると常に\ &quot;右\&quot; Python環境を使用します。つまり、必要なすべてのライブラリが必要な環境で常に呼び出されますピラミッドのように）利用可能です。"

#: ../../narr/commandline.rst:838
msgid ""
"In general, you can make your script into a console script by doing the "
"following:"
msgstr "一般に、次のようにしてスクリプトをコンソールスクリプトにすることができます。"

#: ../../narr/commandline.rst:841
msgid ""
"Use an existing distribution (such as one you've already created via "
"``cookiecutter``) or create a new distribution that possesses at least "
"one package or module.  It should, within any module within the "
"distribution, house a callable (usually a function) that takes no "
"arguments and which runs any of the code you wish to run."
msgstr "既存のディストリビューション（例えば、 `` cookiecutter``で既に作成したディストリビューション）を使用するか、少なくとも1つのパッケージやモジュールを持つ新しいディストリビューションを作成してください。ディストリビューション内のどのモジュールでも、引数をとらず、実行するコードを実行する呼び出し可能な関数（通常は関数）を格納する必要があります。"

#: ../../narr/commandline.rst:847
msgid ""
"Add a ``[console_scripts]`` section to the ``entry_points`` argument of "
"the distribution which creates a mapping between a script name and a "
"dotted name representing the callable you added to your distribution."
msgstr "スクリプト名と配布ファイルに追加した呼び出し可能ファイルを表すドット付きの名前の間のマッピングを作成する配布の `` entry_points``引数に `` [console_scripts] ``セクションを追加してください。"

#: ../../narr/commandline.rst:851
msgid ""
"Run ``pip install -e .`` or ``pip install .`` to get your distribution "
"reinstalled. When you reinstall your distribution, a file representing "
"the script that you named in the last step will be in the ``bin`` "
"directory of the virtual environment in which you installed the "
"distribution. It will be executable. Invoking it from a terminal will "
"execute your callable."
msgstr "あなたのディストリビューションを再インストールするには、 `` pip install -e .``または `` pip install .``を実行してください。ディストリビューションを再インストールすると、最後のステップで指定したスクリプトを表すファイルは、ディストリビューションをインストールした仮想環境の `` bin``ディレクトリにあります。実行可能になります。ターミナルから呼び出すと、あなたの呼び出し可能コードが実行されます。"

#: ../../narr/commandline.rst:857
msgid ""
"As an example, let's create some code that can be invoked by a console "
"script that prints the deployment settings of a Pyramid application.  To "
"do so, we'll pretend you have a distribution with a package in it named "
"``myproject``. Within this package, we'll pretend you've added a "
"``scripts.py`` module which contains the following code:"
msgstr "例として、Pyramidアプリケーションのデプロイメント設定を出力するコンソールスクリプトによって呼び出されるコードをいくつか作成しましょう。これを行うために、 `` myproject``という名前のパッケージを配布しているようです。このパッケージの中で、次のコードを含む `` scripts.py``モジュールを追加したようです。"

#: ../../narr/commandline.rst:909
msgid ""
"This script uses the Python ``optparse`` module to allow us to make sense"
" out of extra arguments passed to the script.  It uses the "
":func:`pyramid.paster.bootstrap` function to get information about the "
"application defined by a config file, and prints the deployment settings "
"defined in that config file."
msgstr "このスクリプトはPythonの `` optparse``モジュールを使って、スクリプトに渡された余分な引数を理解できるようにします。 ：func： `pyramid.paster.bootstrap`関数を使用して、設定ファイルで定義されたアプリケーションに関する情報を取得し、その設定ファイルに定義されているデプロイメント設定を出力します。"

#: ../../narr/commandline.rst:915
msgid ""
"After adding this script to the package, you'll need to tell your "
"distribution's ``setup.py`` about its existence.  Within your "
"distribution's top-level directory, your ``setup.py`` file will look "
"something like this:"
msgstr "このスクリプトをパッケージに追加したら、ディストリビューションの `` setup.py``にその存在を伝える必要があります。あなたのディストリビューションのトップレベルディレクトリ内で、 `` setup.py``ファイルは次のようになります："

#: ../../narr/commandline.rst:967
msgid ""
"We're going to change the ``setup.py`` file to add a "
"``[console_scripts]`` section within the ``entry_points`` string. Within "
"this section, you should specify a ``scriptname = "
"dotted.path.to:yourfunction`` line.  For example:"
msgstr "`` setup.py``ファイルを変更して、 `` entry_points``文字列に `` [console_scripts] ``セクションを追加します。このセクションでは、 `` scriptname = dotted.path.to：yourfunction``行を指定する必要があります。例えば："

#: ../../narr/commandline.rst:976
msgid ""
"The ``show_settings`` name will be the name of the script that is "
"installed into ``bin``.  The colon (``:``) between ``myproject.scripts`` "
"and ``settings_show`` above indicates that ``myproject.scripts`` is a "
"Python module, and ``settings_show`` is the function in that module which"
" contains the code you'd like to run as the result of someone invoking "
"the ``show_settings`` script from their command line."
msgstr "`` show_settings``の名前は、 `` bin``に​​インストールされているスクリプトの名前になります。上記の `` myproject.scripts``と `` settings_show``のコロン（ ``： ``）は `` myproject.scripts``がPythonモジュールであることを示し、 `` settings_show``はそのモジュールの関数ですコマンドラインから `` show_settings``スクリプトを起動した結果として実行したいコードが入っています。"

#: ../../narr/commandline.rst:983
msgid "The result will be something like:"
msgstr "結果は次のようになります。"

#: ../../narr/commandline.rst:1036
msgid ""
"Once you've done this, invoking ``$VENV/bin/pip install -e .`` will "
"install a file named ``show_settings`` into the ``$somevenv/bin`` "
"directory with a small bit of Python code that points to your entry "
"point. It will be executable. Running it without any arguments will print"
" an error and exit. Running it with a single argument that is the path of"
" a config file will print the settings. Running it with an ``--omit=foo``"
" argument will omit the settings that have keys that start with ``foo``. "
"Running it with two \"omit\" options (e.g., ``--omit=foo --omit=bar``) "
"will omit all settings that have keys that start with either ``foo`` or "
"``bar``:"
msgstr "これをやったら、 `` $ VENV / bin / pip install -e .``を実行すると `` $ somevenv / bin``ディレクトリに `` show_settings``という名前のファイルが小さなPythonコードでインストールされますあなたのエントリーポイントを指しています。実行可能になります。引数なしで実行すると、エラーが出力され、終了します。設定ファイルのパスである1つの引数を指定して実行すると、設定が出力されます。 `` --omit = foo``引数でそれを実行すると、 `` foo``で始まるキーを持つ設定は省略されます。 2つの &quot;省略&quot;オプション（例えば、 `` --omit = foo --omit = bar``）で実行すると、 `` foo``や `` bar``で始まるキーを持つ設定はすべて省略されます。 ："

#: ../../narr/commandline.rst:1060
msgid ""
"Pyramid's ``pserve``, ``pcreate``, ``pshell``, ``prequest``, ``ptweens``,"
" and other ``p*`` scripts are implemented as console scripts.  When you "
"invoke one of those, you are using a console script."
msgstr "Pythonの `` pserve``、 `` pcreate``、 `` pshell``、 `` prequest``、 `` ptweens``などの `` p * ``スクリプトはコンソールスクリプトとして実装されています。そのうちの1つを起動すると、コンソールスクリプトを使用しています。"


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../narr/assets.rst:8
msgid "Static Assets"
msgstr "(機械翻訳) 静的資産"

#: ../../narr/assets.rst:10
msgid ""
"An :term:`asset` is any file contained within a Python :term:`package` "
"which is *not* a Python source code file.  For example, each of the "
"following is an asset:"
msgstr "An：term： `asset`は、PythonソースコードファイルではないPython：term：` package`に含まれるファイルです。たとえば、以下はそれぞれ資産です。"

#: ../../narr/assets.rst:14
msgid ""
"a GIF image file contained within a Python package or contained within "
"any subdirectory of a Python package."
msgstr "Pythonパッケージに含まれるGIF画像ファイル、またはPythonパッケージのサブディレクトリに含まれるGIF画像ファイル。"

#: ../../narr/assets.rst:17
msgid ""
"a CSS file contained within a Python package or contained within any "
"subdirectory of a Python package."
msgstr "Pythonパッケージに含まれるCSSファイル、またはPythonパッケージのサブディレクトリに含まれるCSSファイル。"

#: ../../narr/assets.rst:20
msgid ""
"a JavaScript source file contained within a Python package or contained "
"within any subdirectory of a Python package."
msgstr "Pythonパッケージに含まれるか、Pythonパッケージのサブディレクトリに含まれるJavaScriptソースファイル。"

#: ../../narr/assets.rst:23
msgid ""
"A directory within a package that does not have an ``__init__.py`` in it "
"(if it possessed an ``__init__.py`` it would *be* a package)."
msgstr "それが `` __init __。py``を持たないパッケージ内のディレクトリ（パッケージである `` __init __。py``を持っている場合）です。"

#: ../../narr/assets.rst:26
msgid ""
"a :term:`Chameleon` or :term:`Mako` template file contained within a "
"Python package."
msgstr "a：term： `Chameleon`または：term：` Mako`テンプレートファイル（Pythonパッケージに含まれています）。"

#: ../../narr/assets.rst:29
msgid ""
"The use of assets is quite common in most web development projects.  For "
"example, when you create a :app:`Pyramid` application using one of the "
"available :term:`cookiecutter`\\ s, as described in "
":ref:`creating_a_project`, the directory representing the application "
"contains a Python :term:`package`. Within that Python package, there are "
"directories full of files which are static assets. For example, there's a"
" ``static`` directory which contains ``.css``, ``.js``, and ``.gif`` "
"files.  These asset files are delivered when a user visits an application"
" URL."
msgstr "ほとんどのWeb開発プロジェクトでは、資産の使用が非常に一般的です。たとえば、：ref： `creating_a_project`で説明されているように、：app：` Pyramid`アプリケーションを利用可能なterm： `cookiecutter` \\ sで作成すると、アプリケーションを表すディレクトリにPython：term： `パッケージ`。そのPythonパッケージ内には、静的資産であるファイルがいっぱいのディレクトリがあります。たとえば、 `` .css``、 `` .js``、および `.gif``ファイルを含む` `静的` `ディレクトリがあります。これらのアセットファイルは、ユーザーがアプリケーションURLにアクセスしたときに配信されます。"

#: ../../narr/assets.rst:44
msgid "Understanding Asset Specifications"
msgstr "資産の仕様の理解"

#: ../../narr/assets.rst:46
msgid ""
"Let's imagine you've created a :app:`Pyramid` application that uses a "
":term:`Chameleon` ZPT template via the "
":func:`pyramid.renderers.render_to_response` API.  For example, the "
"application might address the asset using the :term:`asset specification`"
" ``myapp:templates/some_template.pt`` using that API within a "
"``views.py`` file inside a ``myapp`` package:"
msgstr "：func： `pyramid.renderers.render_to_response` APIを使って：term：` Chameleon` ZPTテンプレートを使用する：app： `Pyramid`アプリケーションを作成したとします。例えば、アプリケーションは `` myapp``パッケージ内の `` views.py``ファイル内でそのAPIを使用して：term： `asset specification`` `myapp：templates / some_template.pt``を使ってアセットにアクセスするかもしれません："

#: ../../narr/assets.rst:59
msgid ""
"\"Under the hood\", when this API is called, :app:`Pyramid` attempts to "
"make sense out of the string ``myapp:templates/some_template.pt`` "
"provided by the developer.  This string is an :term:`asset "
"specification`.  It is composed of two parts:"
msgstr "\ &quot;Under the hood \&quot;、このAPIが呼び出されると、：app： `Pyramid`は、開発者によって提供された文字列` `myapp：templates / some_template.pt`の意味を理解しようとします。この文字列は：term： `asset specification`です。これは2つの部分で構成されています。"

#: ../../narr/assets.rst:64
msgid "The *package name* (``myapp``)"
msgstr "*パッケージ名*（ `` myapp``）"

#: ../../narr/assets.rst:66
msgid ""
"The *asset name* (``templates/some_template.pt``), relative to the "
"package directory."
msgstr "パッケージディレクトリに対する*アセット名*（ `` templates / some_template.pt``）。"

#: ../../narr/assets.rst:69
msgid "The two parts are separated by a colon ``:`` character."
msgstr "2つの部分はコロン ``： ``文字で区切られています。"

#: ../../narr/assets.rst:71
msgid ""
":app:`Pyramid` uses the Python :term:`pkg_resources` API to resolve the "
"package name and asset name to an absolute (operating system-specific) "
"file name.  It eventually passes this resolved absolute filesystem path "
"to the Chameleon templating engine, which then uses it to load, parse, "
"and execute the template file."
msgstr "：app： `Pyramid`は、Python：term：` pkg_resources` APIを使用して、パッケージ名とアセット名を絶対（オペレーティングシステム固有の）ファイル名に解決します。最終的には解決されたこの絶対ファイルシステムパスをChameleonテンプレートエンジンに渡し、テンプレートエンジンを使用してテンプレートファイルの読み込み、解析、実行を行います。"

#: ../../narr/assets.rst:77
msgid ""
"There is a second form of asset specification: a *relative* asset "
"specification.  Instead of using an \"absolute\" asset specification "
"which includes the package name, in certain circumstances you can omit "
"the package name from the specification.  For example, you might be able "
"to use ``templates/mytemplate.pt`` instead of "
"``myapp:templates/some_template.pt``. Such asset specifications are "
"usually relative to a \"current package\".  The \"current package\" is "
"usually the package which contains the code that *uses* the asset "
"specification.  :app:`Pyramid` APIs which accept relative asset "
"specifications typically describe to what the asset is relative in their "
"individual documentation."
msgstr "第二の形式の資産指定：相対*資産指定があります。特定の状況では、パッケージ名を含むアセット指定を\ &quot;絶対\&quot;の代わりに指定から省略することができます。たとえば、 `` myapp：templates / some_template.pt``の代わりに `` templates / mytemplate.pt``を使うことができます。このような資産の仕様は、通常、現在のパッケージとの相対的なものです。 \ &quot;現在のパッケージ\&quot;は通常、資産仕様を使用するコードを含むパッケージです。 ：app：ピラミッドAPIは、相対資産仕様を受け入れるもので、一般的に、個々の文書でその資産が相対的なものであることを表します。"

#: ../../narr/assets.rst:95
msgid "Serving Static Assets"
msgstr "静的資産の提供"

#: ../../narr/assets.rst:97
msgid ""
":app:`Pyramid` makes it possible to serve up static asset files from a "
"directory on a filesystem to an application user's browser.  Use the "
":meth:`pyramid.config.Configurator.add_static_view` to instruct "
":app:`Pyramid` to serve static assets, such as JavaScript and CSS files. "
"This mechanism makes a directory of static files available at a name "
"relative to the application root URL, e.g., ``/static``, or as an "
"external URL."
msgstr "：app： `Pyramid`は、ファイルシステム上のディレクトリから静的アセットファイルをアプリケーションユーザのブラウザに提供することを可能にします。 ：meth： `pyramid.config.Configurator.add_static_view`を使って、app：` Pyramid`にJavaScriptやCSSファイルなどの静的アセットを提供するよう指示します。このメカニズムは静的ファイルのディレクトリをアプリケーションのルートURLに関連する名前、例えば `` / static``や外部URLとして利用可能にします。"

#: ../../narr/assets.rst:106
msgid ""
":meth:`~pyramid.config.Configurator.add_static_view` cannot serve a "
"single file, nor can it serve a directory of static files directly "
"relative to the root URL of a :app:`Pyramid` application.  For these "
"features, see :ref:`advanced_static`."
msgstr "：meth： `〜pyramid.config.Configurator.add_static_view`は1つのファイルを提供することはできませんし、a：app：` Pyramid`アプリケーションのルートURLに対して直接静的ファイルのディレクトリを提供することもできません。これらの機能については、：ref： `advanced_static`を参照してください。"

#: ../../narr/assets.rst:111
msgid ""
"Here's an example of a use of "
":meth:`~pyramid.config.Configurator.add_static_view` that will serve "
"files up from the ``/var/www/static`` directory of the computer which "
"runs the :app:`Pyramid` application as URLs beneath the ``/static`` URL "
"prefix."
msgstr "以下は、：meth： `〜pyramid.config.Configurator.add_static_view`の使用例です。これは：app：` Pyramid`を実行するコンピュータの `` / var / www / static``ディレクトリからファイルを提供します。アプリケーションを `` / static`` URL接頭辞の下にURLとして追加します。"

#: ../../narr/assets.rst:122
msgid ""
"The ``name`` represents a URL *prefix*.  In order for files that live in "
"the ``path`` directory to be served, a URL that requests one of them must"
" begin with that prefix.  In the example above, ``name`` is ``static`` "
"and ``path`` is ``/var/www/static``.  In English this means that you wish"
" to serve the files that live in ``/var/www/static`` as sub-URLs of the "
"``/static`` URL prefix. Therefore, the file ``/var/www/static/foo.css`` "
"will be returned when the user visits your application's URL "
"``/static/foo.css``."
msgstr "`` name``はURL *プレフィックス*を表します。 `` path``ディレクトリにあるファイルが提供されるためには、それらのうちの1つを要求するURLがその接頭辞で始まらなければなりません。上記の例では、 `` name``は ``静的 ``で、 `` path``は `` / var / www / static``です。英語では、 `` / var / www / static``にあるファイルを `` / static`` URL接頭辞のサブURLとして提供したいと考えています。したがって、ユーザーがあなたのアプリケーションのURL「/ static / foo.css」を訪れたときに、ファイル `` / var / www / static / foo.css``が返されます。"

#: ../../narr/assets.rst:130
msgid ""
"A static directory named at ``path`` may contain subdirectories "
"recursively, and any subdirectories may hold files; these will be "
"resolved by the static view as you would expect.  The ``Content-Type`` "
"header returned by the static view for each particular type of file is "
"dependent upon its file extension."
msgstr "`` path``で指定された静的ディレクトリには、サブディレクトリが再帰的に含まれることがあります。また、サブディレクトリにはファイルが保存されます。これらは静的ビューによって解決されます。特定のファイルタイプごとに静的ビューから返される `` Content-Type``ヘッダーは、そのファイル拡張子に依存します。"

#: ../../narr/assets.rst:135
msgid ""
"By default, all files made available via "
":meth:`~pyramid.config.Configurator.add_static_view` are accessible by "
"completely anonymous users.  Simple authorization can be required, "
"however. To protect a set of static files using a permission, in addition"
" to passing the required ``name`` and ``path`` arguments, also pass the "
"``permission`` keyword argument to "
":meth:`~pyramid.config.Configurator.add_static_view`. The value of the "
"``permission`` argument represents the :term:`permission` that the user "
"must have relative to the current :term:`context` when the static view is"
" invoked.  A user will be required to possess this permission to view any"
" of the files represented by ``path`` of the static view.  If your static"
" assets must be protected by a more complex authorization scheme, see "
":ref:`advanced_static`."
msgstr "デフォルトでは、：meth： `〜pyramid.config.Configurator.add_static_view`で利用できるすべてのファイルは完全に匿名のユーザーがアクセスできます。ただし、単純な承認が必要な場合があります。パーミッションを使って静的ファイルのセットを保護するには、必要な `` name``と `` path``引数を渡すだけでなく、 `` permission``キーワード引数を：meth： `〜pyramid.configに渡します。 Configurator.add_static_view`。 `` permission``引数の値は、静的ビューが呼び出されたときにユーザがcurrent：term： `context`を基準にして持っていなければならない：term：` permission`を表します。ユーザは静的ビューの `` path``で表されるファイルを見るためにこの許可を持っている必要があります。静的資産をより複雑な認可スキームで保護する必要がある場合は、：ref： `advanced_static`を参照してください。"

#: ../../narr/assets.rst:148
msgid ""
"Here's another example that uses an :term:`asset specification` instead "
"of an absolute path as the ``path`` argument.  To convince "
":meth:`~pyramid.config.Configurator.add_static_view` to serve files up "
"under the ``/static`` URL from the ``a/b/c/static`` directory of the "
"Python package named ``some_package``, we can use a fully qualified "
":term:`asset specification` as the ``path``:"
msgstr "`` path``引数として絶対パスの代わりに：term： `asset specification`を使用する別の例を次に示します。確かめるには：meth： `〜pyramid.config.Configurator.add_static_view`は、` `some_packageというPythonパッケージの` `a / b / c / static``ディレクトリから` `/ static`` URLの下にファイルを提供する``、 `` path``として完全修飾：項：資産指定を使うことができます："

#: ../../narr/assets.rst:161
msgid ""
"The ``path`` provided to "
":meth:`~pyramid.config.Configurator.add_static_view` may be a fully "
"qualified :term:`asset specification` or an *absolute path*."
msgstr "：meth： `〜pyramid.config.Configurator.add_static_view`は、完全修飾語：用語：資産指定または*絶対パス*とすることができます。"

#: ../../narr/assets.rst:164
msgid ""
"Instead of representing a URL prefix, the ``name`` argument of a call to "
":meth:`~pyramid.config.Configurator.add_static_view` can alternately be a"
" *URL*.  Each of the examples we've seen so far have shown usage of the "
"``name`` argument as a URL prefix.  However, when ``name`` is a *URL*, "
"static assets can be served from an external webserver.  In this mode, "
"the ``name`` is used as the URL prefix when generating a URL using "
":meth:`pyramid.request.Request.static_url`."
msgstr "URL接頭辞を表す代わりに、：meth： `〜pyramid.config.Configurator.add_static_view`の呼び出しの` `name``引数は、代わりに* URL *にすることができます。これまでに見てきたそれぞれの例では、URL接頭辞として &quot;name&quot;引数を使用しています。ただし、 `` name``が* URL *の場合、静的アセットは外部Webサーバーから提供されます。このモードでは、：meth： `pyramid.request.Request.static_url`を使用してURLを生成するときに、` `name``がURLプレフィックスとして使用されます。"

#: ../../narr/assets.rst:172
msgid ""
"For example, :meth:`~pyramid.config.Configurator.add_static_view` may be "
"fed a ``name`` argument which is ``http://example.com/images``:"
msgstr "たとえば、：meth： `〜pyramid.config.Configurator.add_static_view`は、` `http：// example.com / images``という名前の` `name``引数を与えられます："

#: ../../narr/assets.rst:182
msgid ""
"Because :meth:`~pyramid.config.Configurator.add_static_view` is provided "
"with a ``name`` argument that is the URL ``http://example.com/images``, "
"subsequent calls to :meth:`~pyramid.request.Request.static_url` with "
"paths that start with the ``path`` argument passed to "
":meth:`~pyramid.config.Configurator.add_static_view` will generate a URL "
"something like ``http://example.com/images/logo.png``.  The external "
"webserver listening on ``example.com`` must be itself configured to "
"respond properly to such a request.  The "
":meth:`~pyramid.request.Request.static_url` API is discussed in more "
"detail later in this chapter."
msgstr "：meth： `〜pyramid.config.Configurator.add_static_view`は` `http：// example.com / images``のURLである` `name``引数で提供され、それ以降の：meth：`〜 pyramid.request.Request.static_url`に渡された `` path``引数で始まるパス：meth： `〜pyramid.config.Configurator.add_static_view`は、` `http://example.com &#39;のようなURLを生成します/ images / logo.png``。 `` example.com``をリッスンしている外部Webサーバーは、そのような要求に適切に応答するように構成されていなければなりません。 ：meth： `〜pyramid.request.Request.static_url` APIについては、この章の後半で詳しく説明します。"

#: ../../narr/assets.rst:200
msgid "Generating Static Asset URLs"
msgstr "静的資産URLの生成"

#: ../../narr/assets.rst:202
msgid ""
"When an :meth:`~pyramid.config.Configurator.add_static_view` method is "
"used to register a static asset directory, a special helper API named "
":meth:`pyramid.request.Request.static_url` can be used to generate the "
"appropriate URL for an asset that lives in one of the directories named "
"by the static registration ``path`` attribute."
msgstr "静的アセットディレクトリを登録するために：meth： `〜pyramid.config.Configurator.add_static_view`メソッドが使用された場合、適切なURLを生成するために：meth：` pyramid.request.Request.static_url`という名前の特殊ヘルパーAPIを使用できます静的登録 `` path``属性によって指定されたディレクトリの1つに存在するアセットのためのものです。"

#: ../../narr/assets.rst:208
msgid "For example, let's assume you create a set of static declarations like so:"
msgstr "たとえば、次のような静的宣言のセットを作成するとします。"

#: ../../narr/assets.rst:216
msgid ""
"These declarations create URL-accessible directories which have URLs that"
" begin with ``/static1`` and ``/static2``, respectively.  The assets in "
"the ``assets/1`` directory of the ``mypackage`` package are consulted "
"when a user visits a URL which begins with ``/static1``, and the assets "
"in the ``assets/2`` directory of the ``mypackage`` package are consulted "
"when a user visits a URL which begins with ``/static2``."
msgstr "これらの宣言は、それぞれが `` / static1``と `` / static2``で始まるURLを持つURLアクセス可能なディレクトリを作成します。ユーザーが `` / static1``で始まるURLを訪問し、 `` assets / 2``の資産を参照すると、 `` mypackage``パッケージの `` assets / 1``ディレクトリにある資産が参照されますユーザが `` / static2``で始まるURLにアクセスすると、 `` mypackage``パッケージのディレクトリが参照されます。"

#: ../../narr/assets.rst:223
msgid ""
"You needn't generate the URLs to static assets \"by hand\" in such a "
"configuration.  Instead, use the "
":meth:`~pyramid.request.Request.static_url` API to generate them for you."
"  For example:"
msgstr "このような構成では、静的アセットへのURLを手作業で生成する必要はありません。代わりに、：meth： `〜pyramid.request.Request.static_url` APIを使用してそれらを生成してください。例えば："

#: ../../narr/assets.rst:239
msgid ""
"If the request \"application URL\" of the running system is "
"``http://example.com``, the ``css_url`` generated above would be: "
"``http://example.com/static1/foo.css``.  The ``js_url`` generated above "
"would be ``http://example.com/static2/foo.js``."
msgstr "実行中のシステムのリクエスト &quot;アプリケーションURL&quot;が &quot;http：// example.com&quot;の場合、上記で生成された &quot;css_url&quot;は次のようになります： &quot;http://example.com/static1/foo .css``。上記で生成された `` js_url``は `` http：// example.com / static2 / foo.js``です。"

#: ../../narr/assets.rst:244
msgid ""
"One benefit of using the :meth:`~pyramid.request.Request.static_url` "
"function rather than constructing static URLs \"by hand\" is that if you "
"need to change the ``name`` of a static URL declaration, the generated "
"URLs will continue to resolve properly after the rename."
msgstr "静的URLを手作業で構築するのではなく、：meth： `〜pyramid.request.Request.static_url`関数を使う利点の1つは、静的URL宣言の` `name``を変更する必要がある場合、生成されたURLは名前の変更後も引き続き適切に解決されます。"

#: ../../narr/assets.rst:249
msgid ""
"URLs may also be generated by :meth:`~pyramid.request.Request.static_url`"
" to static assets that live *outside* the :app:`Pyramid` application.  "
"This will happen when the "
":meth:`~pyramid.config.Configurator.add_static_view` API associated with "
"the path fed to :meth:`~pyramid.request.Request.static_url` is a *URL* "
"instead of a view name.  For example, the ``name`` argument may be "
"``http://example.com`` while the ``path`` given may be "
"``mypackage:images``:"
msgstr "URL：：meth： `〜pyramid.request.Request.static_url`を使って：app：` Pyramid`アプリケーションの外部にある静的アセットにURLを生成することもできます。これは、：meth： `〜pyramid.config.Configurator.add_static_view` APIが、：meth：`〜pyramid.request.Request.static_url`に与えられたパスに関連付けられ、ビュー名の代わりに* URL *である場合に発生します。たとえば、 `` name``引数は `` http：// example.com``であり、 `` path``は `` mypackage：images``："

#: ../../narr/assets.rst:262
msgid ""
"Under such a configuration, the URL generated by ``static_url`` for "
"assets which begin with ``mypackage:images`` will be prefixed with "
"``http://example.com/images``:"
msgstr "このような設定では、 `` mypackage：images``で始まるアセットの `` static_url``で生成されるURLの先頭に `` http：// example.com / images``という接頭辞が付きます："

#: ../../narr/assets.rst:272
msgid ""
"Using :meth:`~pyramid.request.Request.static_url` in conjunction with a "
":meth:`~pyramid.config.Configurator.add_static_view` makes it possible to"
" put static media on a separate webserver during production (if the "
"``name`` argument to :meth:`~pyramid.config.Configurator.add_static_view`"
" is a URL), while keeping static media package-internal and served by the"
" development webserver during development (if the ``name`` argument to "
":meth:`~pyramid.config.Configurator.add_static_view` is a URL prefix)."
msgstr "：meth： `〜pyramid.request.Request.static_url`を：meth：`〜pyramid.config.Configurator.add_static_view`と組み合わせて使用​​すると、制作中に別のウェブサーバーに静的メディアを置くことができます（ ``名前開発中に開発中のWebサーバが静的メディアを内部的に保持しておきながら（meth： `〜pyramid.config.Configurator.add_static_view`はURLです）、` `meth：` ` `〜pyramid.config.Configurator.add_static_view`はURLプレフィックスです）。"

#: ../../narr/assets.rst:280
msgid ""
"For example, we may define a :ref:`custom setting "
"<adding_a_custom_setting>` named ``media_location`` which we can set to "
"an external URL in production when our assets are hosted on a CDN."
msgstr "たとえば、：ref： `カスタム設定を定義することができます<adding_a_custom_setting>私たちの資産がCDN上でホストされているときに、本番環境の外部URLに設定できる `media_location`という名前です。"

#: ../../narr/assets.rst:292
msgid "Now we can optionally define the setting in our ini file:"
msgstr "これで設定をiniファイルに定義することができます："

#: ../../narr/assets.rst:303
msgid ""
"It is also possible to serve assets that live outside of the source by "
"referring to an absolute path on the filesystem. There are two ways to "
"accomplish this."
msgstr "また、ファイルシステム上の絶対パスを参照することで、ソース外にある資産を提供することもできます。これを達成するには2つの方法があります。"

#: ../../narr/assets.rst:307
msgid ""
"First, :meth:`~pyramid.config.Configurator.add_static_view` supports "
"taking an absolute path directly instead of an asset spec. This works as "
"expected, looking in the file or folder of files and serving them up at "
"some URL within your application or externally. Unfortunately, this "
"technique has a drawback in that it is not possible to use the "
":meth:`~pyramid.request.Request.static_url` method to generate URLs, "
"since it works based on an asset specification."
msgstr "まず、：meth： `〜pyramid.config.Configurator.add_static_view`はアセット仕様の代わりに絶対パスを直接取ることをサポートしています。これは期待どおりに動作し、ファイルやファイルのフォルダを探し、アプリケーション内のあるURLや外部から提供します。残念ながら、このテクニックには、アセット仕様に基づいて動作するため、：meth： `〜pyramid.request.Request.static_url`メソッドを使用してURLを生成することができないという欠点があります。"

#: ../../narr/assets.rst:316
msgid ""
"The second approach, available in Pyramid 1.6+, uses the asset overriding"
" APIs described in the :ref:`overriding_assets_section` section. It is "
"then possible to configure a \"dummy\" package which then serves its file"
" or folder from an absolute path."
msgstr "Pyramid 1.6以降で利用可能な2番目のアプローチは、：ref： `overriding_assets_section`セクションで説明されているアセットオーバーライドAPIを使用しています。 \ &quot;ダミー\&quot;パッケージを構成して、そのファイルまたはフォルダを絶対パスから提供することは可能です。"

#: ../../narr/assets.rst:327
msgid ""
"From this configuration it is now possible to use "
":meth:`~pyramid.request.Request.static_url` to generate URLs to the data "
"in the folder by doing something like "
"``request.static_url('myapp:static_images/foo.png')``. While it is not "
"necessary that the ``static_images`` file or folder actually exist in the"
" ``myapp`` package, it is important that the ``myapp`` portion points to "
"a valid package. If the folder does exist, then the overriden folder is "
"given priority, if the file's name exists in both locations."
msgstr "この設定から、 `` request.static_url（ &#39;myapp：static_images / foo.png&#39;のようなことをして、フォルダ内のデータへのURLを生成するために：meth： `〜pyramid.request.Request.static_url`を使うことが可能になりました。 ） ``。 `` static_images``ファイルまたはフォルダが実際に `` myapp``パッケージに存在する必要はありませんが、 `` myapp``部分が有効なパッケージを指していることが重要です。フォルダーが存在する場合は、ファイルの名前が両方の場所に存在する場合は、オーバーライドされたフォルダーに優先順位が与えられます。"

#: ../../narr/assets.rst:342
msgid "Cache Busting"
msgstr "キャッシュバスト"

#: ../../narr/assets.rst:346
msgid ""
"In order to maximize performance of a web application, you generally want"
" to limit the number of times a particular client requests the same "
"static asset. Ideally a client would cache a particular static asset "
"\"forever\", requiring it to be sent to the client a single time.  The "
"HTTP protocol allows you to send headers with an HTTP response that can "
"instruct a client to cache a particular asset for an amount of time.  As "
"long as the client has a copy of the asset in its cache and that cache "
"hasn't expired, the client will use the cached copy rather than request a"
" new copy from the server.  The drawback to sending cache headers to the "
"client for a static asset is that at some point the static asset may "
"change, and then you'll want the client to load a new copy of the asset. "
"Under normal circumstances you'd just need to wait for the client's "
"cached copy to expire before they get the new version of the static "
"resource."
msgstr "Webアプリケーションのパフォーマンスを最大限にするには、一般に、特定のクライアントが同じ静的資産を要求する回数を制限する必要があります。理想的には、クライアントは特定の静的資産を永久にキャッシュし、クライアントに一度だけ送信する必要があります。 HTTPプロトコルを使用すると、特定のアセットを一定時間キャッシュするようにクライアントに指示できるHTTPレスポンスでヘッダーを送信できます。クライアントがキャッシュ内にアセットのコピーを持ち、そのキャッシュの有効期限が切れていない限り、クライアントはサーバーから新しいコピーを要求するのではなく、キャッシュされたコピーを使用します。静的アセットのクライアントへのキャッシュヘッダーの送信の欠点は、ある時点で静的アセットが変更される可能性があることです。クライアントはアセットの新しいコピーをロードする必要があります。通常の状況下では、クライアントのキャッシュされたコピーが期限切れになるのを待ってから、新しいバージョンの静的リソースを取得する必要があります。"

#: ../../narr/assets.rst:359
msgid ""
"A commonly used workaround to this problem is a technique known as "
":term:`cache busting`.  Cache busting schemes generally involve "
"generating a URL for a static asset that changes when the static asset "
"changes.  This way headers can be sent along with the static asset "
"instructing the client to cache the asset for a very long time.  When a "
"static asset is changed, the URL used to refer to it in a web page also "
"changes, so the client sees it as a new resource and requests the asset, "
"regardless of any caching policy set for the resource's old URL."
msgstr "この問題の一般的な回避策は、term： `cache busting`と呼ばれる手法です。キャッシュ無効化方式には、通常、静的資産が変更されたときに変更される静的資産のURLを生成することが含まれます。このようにして、クライアントに静的アセットを送信して、クライアントにアセットを非常に長時間キャッシュするように指示することができます。静的アセットが変更されると、Webページでそれを参照するために使用されるURLも変更されるため、クライアントは新しいリソースとして認識し、リソースの古いURLに設定されたキャッシュポリシーに関係なくアセットを要求します。"

#: ../../narr/assets.rst:368
msgid ""
":app:`Pyramid` can be configured to produce cache busting URLs for static"
" assets using :meth:`~pyramid.config.Configurator.add_cache_buster`:"
msgstr "：app： `Pyramid`は、以下を使って静的アセットのキャッシュ破棄URLを生成するように設定できます：meth：`〜pyramid.config.Configurator.add_cache_buster`："

#: ../../narr/assets.rst:383
msgid ""
"Adding the cachebuster instructs :app:`Pyramid` to add the current time "
"for a static asset to the query string in the asset's URL:"
msgstr "キャッシュバスターを追加すると：app： `Pyramid`は、資産のURLのクエリ文字列に静的アセットの現在の時刻を追加します："

#: ../../narr/assets.rst:392
msgid ""
"When the web server restarts, the time constant will change and therefore"
" so will its URL."
msgstr "Webサーバーが再起動すると、時定数が変更されるため、URLも変更されます。"

#: ../../narr/assets.rst:397
msgid ""
"Cache busting is an inherently complex topic as it integrates the asset "
"pipeline and the web application. It is expected and desired that "
"application authors will write their own cache buster implementations "
"conforming to the properties of their own asset pipelines. See "
":ref:`custom_cache_busters` for information on writing your own."
msgstr "キャッシュ・バスト処理は、資産パイプラインとWebアプリケーションを統合するため、本質的に複雑なトピックです。アプリケーション作成者は、独自のアセットパイプラインのプロパティに準拠した独自のキャッシュバスター実装を作成することが期待され、望まれています。独自の記述については、ref： `custom_cache_busters`を参照してください。"

#: ../../narr/assets.rst:404
msgid "Disabling the Cache Buster"
msgstr "キャッシュ・バスターの無効化"

#: ../../narr/assets.rst:406
msgid ""
"It can be useful in some situations (e.g., development) to globally "
"disable all configured cache busters without changing calls to "
":meth:`~pyramid.config.Configurator.add_cache_buster`.  To do this set "
"the ``PYRAMID_PREVENT_CACHEBUST`` environment variable or the "
"``pyramid.prevent_cachebust`` configuration value to a true value."
msgstr "：meth： `〜pyramid.config.Configurator.add_cache_buster`への呼び出しを変更することなく、設定されたすべてのキャッシュバスターをグローバルに無効にすることができます（開発など）。これを行うには、 `` PYRAMID_PREVENT_CACHEBUST``環境変数か `` pyramid.prevent_cachebust``設定値を真の値に設定します。"

#: ../../narr/assets.rst:415
msgid "Customizing the Cache Buster"
msgstr "キャッシュ・バスターのカスタマイズ"

#: ../../narr/assets.rst:417
msgid ""
"Calls to :meth:`~pyramid.config.Configurator.add_cache_buster` may use "
"any object that implements the interface "
":class:`~pyramid.interfaces.ICacheBuster`."
msgstr "：meth： `〜pyramid.config.Configurator.add_cache_buster`を呼び出すと、class：`〜pyramid.interfaces.ICacheBuster`というインターフェースを実装するオブジェクトを使用できます。"

#: ../../narr/assets.rst:421
msgid ""
":app:`Pyramid` ships with a very simplistic "
":class:`~pyramid.static.QueryStringConstantCacheBuster`, which adds an "
"arbitrary token you provide to the query string of the asset's URL. This "
"is almost never what you want in production as it does not allow fine-"
"grained busting of individual assets."
msgstr "：app： `Pyramid`は非常に単純化されています：class：`〜pyramid.static.QueryStringConstantCacheBuster`：アセットのURLのクエリ文字列にあなたが提供する任意のトークンを追加します。これは、個々の資産をきめ細かく破棄することができないため、プロダクションではほとんど望みません。"

#: ../../narr/assets.rst:427
msgid ""
"In order to implement your own cache buster, you can write your own class"
" from scratch which implements the "
":class:`~pyramid.interfaces.ICacheBuster` interface.  Alternatively you "
"may choose to subclass one of the existing implementations.  One of the "
"most likely scenarios is you'd want to change the way the asset token is "
"generated.  To do this just subclass "
":class:`~pyramid.static.QueryStringCacheBuster` and define a "
"``tokenize(pathspec)`` method. Here is an example which uses Git to get "
"the hash of the current commit:"
msgstr "独自のキャッシュ・バスターを実装するために、：class： `〜pyramid.interfaces.ICacheBuster`インターフェースを実装して独自のクラスを一から書くことができます。あるいは、既存の実装の1つをサブクラス化することもできます。最も可能性の高いシナリオの1つは、資産トークンの生成方法を変更することです。これを行うにはclass： `〜pyramid.static.QueryStringCacheBuster`をサブクラス化し、` `tokenize（pathspec）` `メソッドを定義してください。 Gitを使って現在のコミットのハッシュを取得する例を以下に示します："

#: ../../narr/assets.rst:460
msgid ""
"A simple cache buster that modifies the path segment can be constructed "
"as well:"
msgstr "パスセグメントを変更する簡単なキャッシュバスターも構築できます。"

#: ../../narr/assets.rst:477
msgid ""
"The caveat with this approach is that modifying the path segment changes "
"the file name, and thus must match what is actually on the filesystem in "
"order for :meth:`~pyramid.config.Configurator.add_static_view` to find "
"the file. It's better to use the "
":class:`~pyramid.static.ManifestCacheBuster` for these situations, as "
"described in the next section."
msgstr "このアプローチの注意点は、パスセグメントを変更するとファイル名が変更されるため、実際にファイルシステムにあるものと一致して、ファイルを見つけるために：meth： `〜pyramid.config.Configurator.add_static_view`が必要であるということです。次のセクションで説明するように、これらの状況には：class： `〜pyramid.static.ManifestCacheBuster`を使用する方が良いでしょう。"

#: ../../narr/assets.rst:487
msgid "Path Segments and Choosing a Cache Buster"
msgstr "パスセグメントとキャッシュバスターの選択"

#: ../../narr/assets.rst:489
msgid ""
"Many caching HTTP proxies will fail to cache a resource if the URL "
"contains a query string.  Therefore, in general, you should prefer a "
"cache busting strategy which modifies the path segment rather than "
"methods which add a token to the query string."
msgstr "多くのキャッシュHTTPプロキシは、URLにクエリ文字列が含まれている場合、リソースをキャッシュできません。したがって、一般に、トークンをクエリ文字列に追加する方法ではなく、パスセグメントを変更するキャッシュ破棄戦略を使用することをお勧めします。"

#: ../../narr/assets.rst:494
msgid ""
"You will need to consider whether the :app:`Pyramid` application will be "
"serving your static assets, whether you are using an external asset "
"pipeline to handle rewriting urls internal to the css/javascript, and how"
" fine-grained do you want the cache busting tokens to be."
msgstr "：app： `Pyramid`アプリケーションがあなたの静的資産を提供するかどうか、css / javascript内部の書き換えURLを処理するために外部の資産パイプラインを使用しているかどうか、キャッシュをどのように細かくしたいかを検討する必要がありますトークンを破る。"

#: ../../narr/assets.rst:499
msgid ""
"In many cases you will want to host the static assets on another web "
"server or externally on a CDN. In these cases your :app:`Pyramid` "
"application may not even have access to a copy of the static assets. In "
"order to cache bust these assets you will need some information about "
"them."
msgstr "多くの場合、静的資産を別のWebサーバーまたはCDNの外部にホストする必要があります。これらの場合、your：app： `Pyramid`アプリケーションは静的資産のコピーにアクセスすることさえできないことがあります。これらの資産をバストにキャッシュするには、それらに関するいくつかの情報が必要です。"

#: ../../narr/assets.rst:504
msgid ""
"If you are using an external asset pipeline to generate your static files"
" you should consider using the "
":class:`~pyramid.static.ManifestCacheBuster`. This cache buster can load "
"a standard JSON formatted file generated by your pipeline and use it to "
"cache bust the assets. This has many performance advantages as "
":app:`Pyramid` does not need to look at the files to generate any cache "
"busting tokens, but still supports fine-grained per-file tokens."
msgstr "静的ファイルを生成するために外部アセットパイプラインを使用する場合は、：class： `〜pyramid.static.ManifestCacheBuster`を使用することを検討する必要があります。このキャッシュ・バスターは、パイプラインによって生成された標準JSON形式のファイルをロードし、それを使用してアセットをバッシュ・キャッシュすることができます。 app： `Pyramid`は、キャッシュ破棄トークンを生成するためにファイルを見る必要はありませんが、ファイル単位の細かいトークンをサポートしています。"

#: ../../narr/assets.rst:511
msgid "Assuming an example ``manifest.json`` like:"
msgstr "例えば、 `` manifest.json``のような例を考えます："

#: ../../narr/assets.rst:520
msgid "The following code would set up a cachebuster:"
msgstr "次のコードはキャッシュバスターを設定します："

#: ../../narr/assets.rst:535
msgid ""
"It's important to note that the cache buster only handles generating "
"cache-busted URLs for static assets. It does **NOT** provide any "
"solutions for serving those assets. For example, if you generated a URL "
"for ``css/main-678b7c80.css`` then that URL needs to be valid either by "
"configuring ``add_static_view`` properly to point to the location of the "
"files or some other mechanism such as the files existing on your CDN or "
"rewriting the incoming URL to remove the cache bust tokens."
msgstr "キャッシュバスターは、静的アセットのキャッシュで破棄されたURLの生成のみを処理することに注意することが重要です。これらの資産を提供するためのソリューションは提供していません**。たとえば、 `` css / main-678b7c80.css``のURLを生成した場合、そのURLはファイルの場所を指すように `` add_static_view``を適切に設定するか、あなたのCDN上に存在するファイル、または着信URLを書き換えてキャッシュバストトークンを削除します。"

#: ../../narr/assets.rst:547
msgid "CSS and JavaScript source and cache busting"
msgstr "CSSとJavaScriptのソースとキャッシュの破棄"

#: ../../narr/assets.rst:549
msgid ""
"Often one needs to refer to images and other static assets inside CSS and"
" JavaScript files. If cache busting is active, the final static asset URL"
" is not available until the static assets have been assembled. These URLs"
" cannot be handwritten. Below is an example of how to integrate the cache"
" buster into the entire stack. Remember, it is just an example and should"
" be modified to fit your specific tools."
msgstr "多くの場合、CSSやJavaScriptファイル内のイメージやその他の静的なアセットを参照する必要があります。キャッシュ無効化が有効な場合、最終的な静的アセットURLは、静的アセットがアセンブルされるまで使用できません。これらのURLは手書きできません。以下は、キャッシュバスターをスタック全体に統合する方法の例です。これは単なる例であり、特定のツールに合わせて修正する必要があることを覚えておいてください。"

#: ../../narr/assets.rst:556
msgid ""
"First, process the files by using a precompiler which rewrites URLs to "
"their final cache-busted form. Then, you can use the "
":class:`~pyramid.static.ManifestCacheBuster` to synchronize your asset "
"pipeline with :app:`Pyramid`, allowing the pipeline to have full control "
"over the final URLs of your assets."
msgstr "最初に、URLを最終的なキャッシュ・バスト・フォームに書き換えるプリコンパイラを使用してファイルを処理します。次に、：class： `〜pyramid.static.ManifestCacheBuster`を使用してアセットパイプラインを：app：` Pyramid`と同期させることができます。パイプラインはアセットの最終URLを完全に制御できます。"

#: ../../narr/assets.rst:562
msgid ""
"Now that you are able to generate static URLs within :app:`Pyramid`, "
"you'll need to handle URLs that are out of our control. To do this you "
"may use some of the following options to get started:"
msgstr "これで、：app： `Pyramid`内で静的URLを生成できるようになったので、あなたがコントロールできないURLを処理する必要があります。これを行うには、以下のオプションのいくつかを使用して開始してください。"

#: ../../narr/assets.rst:566
msgid ""
"Configure your asset pipeline to rewrite URL references inline in CSS and"
" JavaScript. This is the best approach because then the files may be "
"hosted by :app:`Pyramid` or an external CDN without having to change "
"anything. They really are static."
msgstr "アセットパイプラインを設定して、CSSおよびJavaScriptでURL参照をインラインで書き直すようにします。これは、ファイルをapp： `Pyramid`または外部のCDNで変更することなくホストすることができるため、最良の方法です。彼らは本当に静的です。"

#: ../../narr/assets.rst:571
msgid ""
"Templatize JS and CSS, and call ``request.static_url()`` inside their "
"template code. While this approach may work in certain scenarios, it is "
"not recommended because your static assets will not really be static and "
"are now dependent on :app:`Pyramid` to be served correctly. See "
":ref:`advanced_static` for more information on this approach."
msgstr "JSとCSSをTemplatizeし、テンプレートコードの中で `` request.static_url（） ``を呼び出します。このアプローチは特定のシナリオではうまくいくかもしれませんが、静的資産は実際には静的ではなく、app： `Pyramid`が正しく提供されるため、推奨されません。このアプローチの詳細については：ref： `advanced_static`を参照してください。"

#: ../../narr/assets.rst:577
msgid ""
"If your CSS and JavaScript assets use URLs to reference other assets it "
"is recommended that you implement an external asset pipeline that can "
"rewrite the generated static files with new URLs containing cache busting"
" tokens. The machinery inside :app:`Pyramid` will not help with this step"
" as it has very little knowledge of the asset types your application may "
"use. The integration into :app:`Pyramid` is simply for linking those "
"assets into your HTML and other dynamic content."
msgstr "CSSおよびJavaScriptアセットでURLを使用して他のアセットを参照する場合、生成された静的ファイルをキャッシュ破棄トークンを含む新しいURLに書き換えることができる外部アセットパイプラインを実装することをお勧めします。内部の機械：app： `Pyramid`は、アプリケーションが使用する資産の種類についての知識がほとんどないため、このステップを助けません。 ：app： `Pyramid`への統合は、単にそれらのアセットをHTMLや他の動的コンテンツにリンクするためだけです。"

#: ../../narr/assets.rst:588
msgid "Advanced: Serving Static Assets Using a View Callable"
msgstr "上級者：ビューコールバックを使用した静的資産の処理"

#: ../../narr/assets.rst:590
msgid ""
"For more flexibility, static assets can be served by a :term:`view "
"callable` which you register manually.  For example, if you're using "
":term:`URL dispatch`, you may want static assets to only be available as "
"a fallback if no previous route matches.  Alternatively, you might like "
"to serve a particular static asset manually, because its download "
"requires authentication."
msgstr "柔軟性を高めるために、静的資産は：term： `view callable`によって提供され、手動で登録します。たとえば、：term： `URL dispatch`を使用している場合、以前のルートが一致しない場合にのみ静的資産をフォールバックとして使用できるようにすることができます。あるいは、ダウンロードに認証が必要なため、特定の静的資産を手動で提供することもできます。"

#: ../../narr/assets.rst:596
msgid ""
"Note that you cannot use the :meth:`~pyramid.request.Request.static_url` "
"API to generate URLs against assets made accessible by registering a "
"custom static view."
msgstr "：meth： `〜pyramid.request.Request.static_url` APIを使用して、カスタム静的ビューを登録してアクセス可能にしたアセットに対するURLを生成することはできません。"

#: ../../narr/assets.rst:601
msgid "Root-Relative Custom Static View (URL Dispatch Only)"
msgstr "ルート関連のカスタムスタティックビュー（URLディスパッチのみ）"

#: ../../narr/assets.rst:603
msgid ""
"The :class:`pyramid.static.static_view` helper class generates a Pyramid "
"view callable.  This view callable can serve static assets from a "
"directory.  An instance of this class is actually used by the "
":meth:`~pyramid.config.Configurator.add_static_view` configuration "
"method, so its behavior is almost exactly the same once it's configured."
msgstr "：class： `pyramid.static.static_view`ヘルパークラスは、呼び出し可能なピラミッドビューを生成します。このビュー呼び出し可能は、ディレクトリから静的資産を提供することができます。このクラスのインスタンスは：meth： `〜pyramid.config.Configurator.add_static_view`設定メソッドによって実際に使用されるため、設定された動作はほぼ同じになります。"

#: ../../narr/assets.rst:611
msgid ""
"The following example *will not work* for applications that use "
":term:`traversal`; it will only work if you use :term:`URL dispatch` "
"exclusively.  The root-relative route we'll be registering will always be"
" matched before traversal takes place, subverting any views registered "
"via ``add_view`` (at least those without a ``route_name``).  A "
":class:`~pyramid.static.static_view` static view cannot be made root-"
"relative when you use traversal unless it's registered as a :term:`Not "
"Found View`."
msgstr "次の例では、term： `traversal`を使用するアプリケーションで*動作しません。 term： `URL dispatch`を排他的に使用すると動作します。登録するルート相対ルートは、トラバーサルが発生する前に常に一致し、 `` add_view``（少なくとも `` route_name``がないもの）によって登録されたビューを覆します。 A：class： `〜pyramid.static.static_view`静的ビューは：term：` Not Found View`として登録されていない限り、トラバーサルを使用するとroot相対にすることはできません。"

#: ../../narr/assets.rst:620
msgid ""
"To serve files within a directory located on your filesystem at "
"``/path/to/static/dir`` as the result of a \"catchall\" route hanging "
"from the root that exists at the end of your routing table, create an "
"instance of the :class:`~pyramid.static.static_view` class inside a "
"``static.py`` file in your application root as below."
msgstr "ルーティングテーブルの最後にあるルートからハングする\ &quot;catchall \&quot;ルートの結果として、ファイルシステム上にあるディレクトリ内のファイルを `` / path / to / static / dir``に提供するには、あなたのアプリケーションルートの `` static.py``ファイルの中で：class： `〜pyramid.static.static_view`クラスのインスタンスを作成します。"

#: ../../narr/assets.rst:634
msgid ""
"For better cross-system flexibility, use an :term:`asset specification` "
"as the argument to :class:`~pyramid.static.static_view` instead of a "
"physical absolute filesystem path, e.g., ``mypackage:static``, instead of"
" ``/path/to/mypackage/static``."
msgstr "クロスシステムの柔軟性を高めるために、物理的な絶対ファイルシステムパスの代わりに：class： `〜pyramid.static.static_view`の引数として：term：` asset specification`を使用してください。たとえば、 `` mypackage：static``の代わりに`` / path / to / mypackage / static``のようなものです。"

#: ../../narr/assets.rst:639
msgid ""
"Subsequently, you may wire the files that are served by this view up to "
"be accessible as ``/<filename>`` using a configuration method in your "
"application's startup code."
msgstr "その後、このビューで提供されるファイルを `` / <filename> ``あなたのアプリケーションのスタートアップコードで設定メソッドを使います。"

#: ../../narr/assets.rst:652
msgid ""
"The special name ``*subpath`` above is used by the "
":class:`~pyramid.static.static_view` view callable to signify the path of"
" the file relative to the directory you're serving."
msgstr "上の特別な名前 `` * subpath``は：class： `〜pyramid.static.static_view`ビューによって呼び出され、あなたが提供しているディレクトリを基準にファイルのパスを指定します。"

#: ../../narr/assets.rst:657
msgid "Registering a View Callable to Serve a \"Static\" Asset"
msgstr "\ &quot;スタティック\&quot;アセットを表示するためのビュー呼び出し可能の登録"

#: ../../narr/assets.rst:659
msgid ""
"You can register a simple view callable to serve a single static asset.  "
"To do so, do things \"by hand\".  First define the view callable."
msgstr "単一の静的資産を提供するために呼び出し可能な単純ビューを登録することができます。そうするには、手で\ &quot;手で行います。まず、呼び出し可能なビューを定義します。"

#: ../../narr/assets.rst:673
msgid ""
"The above bit of code within ``favicon_view`` computes \"here\", which is"
" a path relative to the Python file in which the function is defined.  It"
" then creates a :class:`pyramid.response.FileResponse` using the file "
"path as the response's ``path`` argument and the request as the "
"response's ``request`` argument. :class:`pyramid.response.FileResponse` "
"will serve the file as quickly as possible when it's used this way.  It "
"makes sure to set the right content length and content_type, too, based "
"on the file extension of the file you pass."
msgstr "`` favicon_view``内の上記のコードは\ &quot;here \&quot;を計算します。これは関数が定義されているPythonファイルを基準とした相対パスです。次に、レスポンスの `` path``引数としてファイルパスを使用し、レスポンスの `` request``引数として要求を使用して：class： `pyramid.response.FileResponse`を作成します。 ：class： `pyramid.response.FileResponse`は、このように使用されたときにできるだけ早くファイルを提供します。渡すファイルのファイル拡張子に基づいて、正しいコンテンツの長さとcontent_typeを設定します。"

#: ../../narr/assets.rst:681
msgid ""
"You might register such a view via configuration as a view callable that "
"should be called as the result of a traversal:"
msgstr "このようなビューは、トラバーサルの結果として呼び出されるビュー呼び出し可能として構成によって登録することができます。"

#: ../../narr/assets.rst:689
msgid "Or you might register it to be the view callable for a particular route:"
msgstr "または、特定のルートで呼び出し可能なビューに登録することもできます。"

#: ../../narr/assets.rst:697
msgid ""
"Because this is a simple view callable, it can be protected with a "
":term:`permission` or can be configured to respond under different "
"circumstances using :term:`view predicate` arguments."
msgstr "これは呼び出し可能な単純なビューなので、：term： `permission`で保護することも、term：` view predicate`引数を使って異なる状況下で応答するように設定することもできます。"

#: ../../narr/assets.rst:708
msgid "Overriding Assets"
msgstr "アセットのオーバーライド"

#: ../../narr/assets.rst:710
msgid ""
"It can often be useful to override specific assets from \"outside\" a "
"given :app:`Pyramid` application.  For example, you may wish to reuse an "
"existing :app:`Pyramid` application more or less unchanged.  However, "
"some specific template file owned by the application might have "
"inappropriate HTML, or some static asset (such as a logo file or some CSS"
" file) might not be appropriate. You *could* just fork the application "
"entirely, but it's often more convenient to just override the assets that"
" are inappropriate and reuse the application \"as is\".  This is "
"particularly true when you reuse some \"core\" application over and over "
"again for some set of customers (such as a CMS application, or some bug "
"tracking application), and you want to make arbitrary visual "
"modifications to a particular application deployment without forking the "
"underlying code."
msgstr "特定の資産をapp： `Pyramid`アプリケーションの外から上書きすると便利なことがよくあります。たとえば、既存の：app： `Pyramid`アプリケーションを多かれ少なかれ変更せずに再利用することができます。ただし、アプリケーションが所有する特定のテンプレートファイルの中に不適切なHTMLが含まれている場合や、スタティックアセット（ロゴファイルやCSSファイルなど）が適切でない場合があります。アプリケーションを完全にフォークすることはできますが、不適切なアセットをオーバーライドしてアプリケーションをそのまま使用すると便利です。これは、いくつかの顧客（CMSアプリケーションやバグ追跡アプリケーションなど）のためにいくつかの\ &quot;コア\&quot;アプリケーションを何度も何度も何度も再利用し、特定のアプリケーションデプロイメントに対して任意の視覚的な変更を加えたい場合に特に当てはまります基礎となるコードをフォークすることなく。"

#: ../../narr/assets.rst:722
msgid ""
"To this end, :app:`Pyramid` contains a feature that makes it possible to "
"\"override\" one asset with one or more other assets.  In support of this"
" feature, a :term:`Configurator` API exists named "
":meth:`pyramid.config.Configurator.override_asset`.  This API allows you "
"to *override* the following kinds of assets defined in any Python "
"package:"
msgstr "この目的のために、：app： `Pyramid`には、ある資産を1つ以上の他の資産と&quot;上書き &quot;する機能を含みます。この機能をサポートするために、a：term： `Configurator` APIが存在します：meth：` pyramid.config.Configurator.override_asset`。このAPIを使用すると、任意のPythonパッケージで定義された次の種類のアセットをオーバーライドできます。"

#: ../../narr/assets.rst:728
msgid "Individual template files."
msgstr "個々のテンプレートファイル。"

#: ../../narr/assets.rst:730
msgid "A directory containing multiple template files."
msgstr "複数のテンプレートファイルを含むディレクトリ。"

#: ../../narr/assets.rst:732
msgid ""
"Individual static files served up by an instance of the "
"``pyramid.static.static_view`` helper class."
msgstr "個々の静的ファイルは、 `` pyramid.static.static_view``ヘルパークラスのインスタンスによって提供されます。"

#: ../../narr/assets.rst:735
msgid ""
"A directory of static files served up by an instance of the "
"``pyramid.static.static_view`` helper class."
msgstr "静的ファイルのディレクトリで、 `` pyramid.static.static_view``ヘルパークラスのインスタンスによって提供されます。"

#: ../../narr/assets.rst:738
msgid ""
"Any other asset (or set of assets) addressed by code that uses the "
"setuptools :term:`pkg_resources` API."
msgstr "setuptools：term： `pkg_resources` APIを使用するコードで扱われるその他のアセット（またはアセットのセット）。"

#: ../../narr/assets.rst:747
msgid "The ``override_asset`` API"
msgstr "`` override_asset`` API"

#: ../../narr/assets.rst:749
msgid ""
"An individual call to :meth:`~pyramid.config.Configurator.override_asset`"
" can override a single asset.  For example:"
msgstr "：meth： `〜pyramid.config.Configurator.override_asset`を個別に呼び出すと、単一のアセットをオーバーライドできます。例えば："

#: ../../narr/assets.rst:759
msgid ""
"The string value passed to both ``to_override`` and ``override_with`` "
"sent to the ``override_asset`` API is called an :term:`asset "
"specification`.  The colon separator in a specification separates the "
"*package name* from the *asset name*.  The colon and the following asset "
"name are optional.  If they are not specified, the override attempts to "
"resolve every lookup into a package from the directory of another "
"package.  For example:"
msgstr "`` override_asset`` APIに送られる `` to_override``と `` override_with``の両方に渡される文字列値は：term： `asset specification`と呼ばれます。仕様のコロン区切り記号は、*パッケージ名*を*資産名*から分離します。コロンと次のアセット名はオプションです。それらが指定されていない場合、オーバーライドは別のパッケージのディレクトリからパッケージへのすべてのルックアップを解決しようとします。例えば："

#: ../../narr/assets.rst:772
msgid "Individual subdirectories within a package can also be overridden:"
msgstr "パッケージ内の個々のサブディレクトリも上書きできます。"

#: ../../narr/assets.rst:780
msgid ""
"If you wish to override a directory with another directory, you *must* "
"make sure to attach the slash to the end of both the ``to_override`` "
"specification and the ``override_with`` specification.  If you fail to "
"attach a slash to the end of a specification that points to a directory, "
"you will get unexpected results."
msgstr "ディレクトリを別のディレクトリで上書きする場合は、スラッシュを `` to_override``仕様と `` override_with``仕様の両方の末尾に付ける必要があります。ディレクトリを指す指定の最後にスラッシュを付けると、予期しない結果が発生します。"

#: ../../narr/assets.rst:786
msgid ""
"You cannot override a directory specification with a file specification, "
"and vice versa; a startup error will occur if you try.  You cannot "
"override an asset with itself; a startup error will occur if you try."
msgstr "ディレクトリ指定をファイル指定で上書きすることはできません。逆もできません。試してみると起動エラーが発生します。アセット自体をオーバーライドすることはできません。試してみると起動エラーが発生します。"

#: ../../narr/assets.rst:790
msgid ""
"Only individual *package* assets may be overridden.  Overrides will not "
"traverse through subpackages within an overridden package.  This means "
"that if you want to override assets for both ``some.package:templates``, "
"and ``some.package.views:templates``, you will need to register two "
"overrides."
msgstr "個々の* package *アセットだけがオーバーライドされます。オーバーライドは、オーバーライドされたパッケージ内のサブパッケージを通過しません。これは、 `` some.package：templates``と `` some.package.views：templates``の両方のアセットをオーバーライドする場合、2つのオーバーライドを登録する必要があることを意味します。"

#: ../../narr/assets.rst:795
msgid ""
"The package name in a specification may start with a dot, meaning that "
"the package is relative to the package in which the configuration "
"construction file resides (or the ``package`` argument to the "
":class:`~pyramid.config.Configurator` class construction). For example:"
msgstr "仕様のパッケージ名は、ドットで始まることがあります。これは、パッケージがコンフィギュレーション構築ファイルが存在するパッケージ（または：class： `〜pyramid.config.Configurator`の` `package``引数）に相対的であることを意味します。クラス構造）。例えば："

#: ../../narr/assets.rst:806
msgid ""
"Multiple calls to ``override_asset`` which name a shared ``to_override`` "
"but a different ``override_with`` specification can be \"stacked\" to "
"form a search path.  The first asset that exists in the search path will "
"be used; if no asset exists in the override path, the original asset is "
"used."
msgstr "共有された `` to_override``を指定するが、別の `` override_with``を指定する `` override_asset``への複数の呼び出しは、検索パスを形成するためにスタックされます。検索パスに存在する最初のアセットが使用されます。上書きパスに資産が存在しない場合は、元の資産が使用されます。"

#: ../../narr/assets.rst:811
msgid ""
"Asset overrides can actually override assets other than templates and "
"static files.  Any software which uses the "
":func:`pkg_resources.get_resource_filename`, "
":func:`pkg_resources.get_resource_stream`, or "
":func:`pkg_resources.get_resource_string` APIs will obtain an overridden "
"file when an override is used."
msgstr "資産オーバーライドは、テンプレートや静的ファイル以外の資産を実際にオーバーライドできます。 ：func： `pkg_resources.get_resource_filename`、：func：` pkg_resources.get_resource_stream`、または：func： `pkg_resources.get_resource_string` APIを使用するソフトウェアは、オーバーライドが使用されるときにオーバーライドされたファイルを取得します。"

#: ../../narr/assets.rst:818
msgid ""
"As of Pyramid 1.6, it is also possible to override an asset by supplying "
"an absolute path to a file or directory. This may be useful if the assets"
" are not distributed as part of a Python package."
msgstr "Pyramid 1.6以降では、ファイルまたはディレクトリへの絶対パスを指定することでアセットをオーバーライドすることもできます。これは、アセットがPythonパッケージの一部として配布されていない場合に便利です。"

#: ../../narr/assets.rst:824
msgid "Cache Busting and Asset Overrides"
msgstr "キャッシュバストと資産のオーバーライド"

#: ../../narr/assets.rst:826
msgid ""
"Overriding static assets that are being hosted using "
":meth:`pyramid.config.Configurator.add_static_view` can affect your cache"
" busting strategy when using any cache busters that are asset-aware such "
"as :class:`pyramid.static.ManifestCacheBuster`. What sets asset-aware "
"cache busters apart is that they have logic tied to specific assets. For "
"example, a manifest is only generated for a specific set of pre-defined "
"assets. Now, imagine you have overridden an asset defined in this "
"manifest with a new, unknown version. By default, the cache buster will "
"be invoked for an asset it has never seen before and will likely end up "
"returning a cache busting token for the original asset rather than the "
"asset that will actually end up being served! In order to get around this"
" issue, it's possible to attach a different "
":class:`pyramid.interfaces.ICacheBuster` implementation to the new "
"assets. This would cause the original assets to be served by their "
"manifest, and the new assets served by their own cache buster. To do "
"this, :meth:`pyramid.config.Configurator.add_cache_buster` supports an "
"``explicit`` option. For example:"
msgstr "：meth： `pyramid.config.Configurator.add_static_view`を使用してホストされている静的アセットをオーバーライドすると、class：` pyramid.static.ManifestCacheBuster`のようなアセット対応のキャッシュバスターを使用するときのキャッシュ破棄戦略に影響を与える可能性があります。アセット・アウェア・キャッシュ・バスターは、ロジックを特定のアセットに結び付けている点で違いがあります。たとえば、マニフェストは、事前定義された特定のアセットのセットに対してのみ生成されます。今、このマニフェストで定義されたアセットを、新しい未知のバージョンで上書きしたとします。デフォルトでは、これまでに見たことがないアセットに対してキャッシュバスターが呼び出され、実際に配信されるアセットではなく、元のアセットのキャッシュ破棄トークンが返される可能性があります。この問題を回避するために、異なる：class： `pyramid.interfaces.ICacheBuster`実装を新しいアセットに付加することが可能です。これにより、元のアセットはマニフェストによって提供され、新しいアセットは独自のキャッシュ・バスターによって提供されます。これを行うには：meth： `pyramid.config.Configurator.add_cache_buster`は` `explicit``オプションをサポートしています。例えば："

#: ../../narr/assets.rst:864
msgid ""
"In the above example there is a default cache buster, ``my_cb``, for all "
"assets served from the ``myapp:static`` folder. This would also affect "
"``theme:static/background.png`` when generating URLs via "
"``request.static_url('myapp:static/background.png')``."
msgstr "上記の例では、 `` myapp：static``フォルダから提供されるすべてのアセットに対して、デフォルトのキャッシュ・バスター、 `` my_cb``があります。これは、 `` request.static_url（ &#39;myapp：static / background.png&#39;） ``でURLを生成するときに `` theme：static / background.png``にも影響します。"

#: ../../narr/assets.rst:869
msgid ""
"The ``theme_cb`` is defined explicitly for any assets loaded from the "
"``theme:static`` folder. Explicit cache busters have priority and thus "
"``theme_cb`` would be invoked for "
"``request.static_url('myapp:static/background.png')``, but ``my_cb`` "
"would be used for any other assets like "
"``request.static_url('myapp:static/favicon.ico')``."
msgstr "`` theme_cb``は `` theme：static``フォルダから読み込まれたアセットに対して明示的に定義されています。明示的なキャッシュバスターは優先順位があり、 `` request.static_url（ &#39;myapp：static / background.png&#39;） ``に対して `` theme_cb``が呼び出されますが、 `` my_cb``は ` `request.static_url（ &#39;myapp：static / favicon.ico&#39;）` `です。"


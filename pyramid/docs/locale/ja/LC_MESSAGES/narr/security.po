# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../narr/security.rst:7
msgid "Security"
msgstr "(機械翻訳) セキュリティ"

#: ../../narr/security.rst:9
msgid ""
":app:`Pyramid` provides an optional, declarative, security system. "
"Security in :app:`Pyramid` is separated into authentication and "
"authorization. The two systems communicate via :term:`principal` "
"identifiers. Authentication is merely the mechanism by which credentials "
"provided in the :term:`request` are resolved to one or more "
":term:`principal` identifiers. These identifiers represent the users and "
"groups that are in effect during the request. Authorization then "
"determines access based on the :term:`principal` identifiers, the "
"requested :term:`permission`, and a :term:`context`."
msgstr "：app： `Pyramid`はオプションで宣言的なセキュリティシステムを提供します。セキュリティで：app： `Pyramid`は認証と認可に分かれています。 2つのシステムはterm： `principal`識別子で通信します。認証は単に：term： `request`で提供された資格証明が1つ以上の：term：` principal`識別子に解決されるメカニズムです。これらの識別子は、要求時に有効なユーザーとグループを表します。承認は：term： `principal`識別子、要求された：term：` permission`、およびa：term： `context`に基づいてアクセスを決定します。"

#: ../../narr/security.rst:18
msgid ""
"The :app:`Pyramid` authorization system can prevent a :term:`view` from "
"being invoked based on an :term:`authorization policy`. Before a view is "
"invoked, the authorization system can use the credentials in the "
":term:`request` along with the :term:`context` resource to determine if "
"access will be allowed.  Here's how it works at a high level:"
msgstr "：app： `Pyramid`認可システムは：term：`認可ポリシー `に基づいてa：term：` view`が呼び出されるのを防ぐことができます。ビューが呼び出される前に、認証システムは：term： `context`リソースとともに、：term：` request`の資格情報を使用して、アクセスが許可されるかどうかを判断することができます。どのように高いレベルで動作するかは次のとおりです。"

#: ../../narr/security.rst:24
msgid ""
"A user may or may not have previously visited the application and "
"supplied authentication credentials, including a :term:`userid`.  If so, "
"the application may have called :func:`pyramid.security.remember` to "
"remember these."
msgstr "ユーザーは以前にアプリケーションを訪れていてもいなくてもかまいませんし、：term： `userid`を含む認証資格情報を提供しているかもしれません。もしそうなら、アプリケーションはfunc： `pyramid.security.remember`を呼び出してこれらを覚えているかもしれません。"

#: ../../narr/security.rst:29
msgid "A :term:`request` is generated when a user visits the application."
msgstr "A：term： `request`は、ユーザがアプリケーションを訪れたときに生成されます。"

#: ../../narr/security.rst:31
msgid ""
"Based on the request, a :term:`context` resource is located through "
":term:`resource location`.  A context is located differently depending on"
" whether the application uses :term:`traversal` or :term:`URL dispatch`, "
"but a context is ultimately found in either case.  See the "
":ref:`urldispatch_chapter` chapter for more information."
msgstr "この要求に基づいて、a：term： `context`リソースは：term：` resource location`によって配置されます。コンテキストは、アプリケーションがterm： `traversal`または：term：` URL dispatch`を使用するかどうかによって異なって位置付けられますが、どちらの場合でもコンテキストは最終的に見つかります。詳細は、：ref： `urldispatch_chapter`の章を参照してください。"

#: ../../narr/security.rst:37
msgid ""
"A :term:`view callable` is located by :term:`view lookup` using the "
"context as well as other attributes of the request."
msgstr "A：term： `view callable`は：term：` view lookup`によってコンテキストのほかにリクエストの他の属性を使用しています。"

#: ../../narr/security.rst:40
msgid ""
"If an :term:`authentication policy` is in effect, it is passed the "
"request. It will return some number of :term:`principal` identifiers. To "
"do this, the policy would need to determine the authenticated "
":term:`userid` present in the request."
msgstr "：term： `認証ポリシー`が有効な場合、要求に渡されます。いくつかの：term： `principal`識別子を返します。これを行うには、ポリシーは、リクエストに存在するauthenticated：term： `userid`を判断する必要があります。"

#: ../../narr/security.rst:45
msgid ""
"If an :term:`authorization policy` is in effect and the :term:`view "
"configuration` associated with the view callable that was found has a "
":term:`permission` associated with it, the authorization policy is passed"
" the :term:`context`, some number of :term:`principal` identifiers "
"returned by the authentication policy, and the :term:`permission` "
"associated with the view; it will allow or deny access."
msgstr "：term： `認可ポリシー`が有効であり、見つかったビューcallableに関連付けられた：term： `view configuration`に：term：` permission`が関連付けられている場合、認可ポリシーは次のように渡されます：term： `context`、認証ポリシーによって返されるterm：` principal`識別子、ビューに関連する：term： `permission`です。アクセスを許可または拒否します。"

#: ../../narr/security.rst:52
msgid "If the authorization policy allows access, the view callable is invoked."
msgstr "権限ポリシーがアクセスを許可する場合、呼び出し可能なビューが呼び出されます。"

#: ../../narr/security.rst:54
msgid ""
"If the authorization policy denies access, the view callable is not "
"invoked. Instead the :term:`forbidden view` is invoked."
msgstr "認可ポリシーがアクセスを拒否した場合、呼び出し可能なビューは呼び出されません。代わりに：term： `禁止されたビュー &#39;が呼び出されます。"

#: ../../narr/security.rst:57
msgid ""
"Authorization is enabled by modifying your application to include an "
":term:`authentication policy` and :term:`authorization policy`. "
":app:`Pyramid` comes with a variety of implementations of these policies."
"  To provide maximal flexibility, :app:`Pyramid` also allows you to "
"create custom authentication policies and authorization policies."
msgstr "承認は、アプリケーションを変更して：term： `認証ポリシー`と：term： `認証ポリシー`を含むようにすることで可能になります。 ：app： `Pyramid`には、これらのポリシーのさまざまな実装が付属しています。最大限の柔軟性を提供するために、：app： `Pyramid`ではカスタム認証ポリシーと認証ポリシーを作成することもできます。"

#: ../../narr/security.rst:69
msgid "Enabling an Authorization Policy"
msgstr "承認ポリシーの有効化"

#: ../../narr/security.rst:71
msgid ""
":app:`Pyramid` does not enable any authorization policy by default.  All "
"views are accessible by completely anonymous users.  In order to begin "
"protecting views from execution based on security settings, you need to "
"enable an authorization policy."
msgstr "：app： `Pyramid`は、デフォルトでは、どの認可ポリシーも有効にしていません。すべてのビューには、完全に匿名のユーザーがアクセスできます。セキュリティ設定に基づいてビューを実行から保護するには、認可ポリシーを有効にする必要があります。"

#: ../../narr/security.rst:77
msgid "Enabling an Authorization Policy Imperatively"
msgstr "権限付きポリシーを必然的に有効にする"

#: ../../narr/security.rst:79
msgid ""
"Use the :meth:`~pyramid.config.Configurator.set_authorization_policy` "
"method of the :class:`~pyramid.config.Configurator` to enable an "
"authorization policy."
msgstr "権限ポリシーを有効にするには、：class： `〜pyramid.config.Configurator`の：meth：`〜pyramid.config.Configurator.set_authorization_policy`メソッドを使用します。"

#: ../../narr/security.rst:82
msgid ""
"You must also enable an :term:`authentication policy` in order to enable "
"the authorization policy.  This is because authorization, in general, "
"depends upon authentication.  Use the "
":meth:`~pyramid.config.Configurator.set_authentication_policy` method "
"during application setup to specify the authentication policy."
msgstr "権限ポリシーを有効にするには、：term： `認証ポリシー &#39;も有効にする必要があります。これは、認証は一般に認証に依存するためです。アプリケーション設定中に：meth： `〜pyramid.config.Configurator.set_authentication_policy`メソッドを使用して、認証ポリシーを指定します。"

#: ../../narr/security.rst:88 ../../narr/security.rst:797
msgid "For example:"
msgstr "例えば："

#: ../../narr/security.rst:102
msgid ""
"The ``authentication_policy`` and ``authorization_policy`` arguments may "
"also be passed to their respective methods mentioned above as "
":term:`dotted Python name` values, each representing the dotted name path"
" to a suitable implementation global defined at Python module scope."
msgstr "`` authentication_policy``と `` authorization_policy``引数は上記のそれぞれのメソッドに渡すこともできます：term：Pythonモジュールスコープで定義された適切な実装グローバルへの点線の名前パスを表す `dotted Python name`値。"

#: ../../narr/security.rst:107
msgid ""
"The above configuration enables a policy which compares the value of an "
"\"auth ticket\" cookie passed in the request's environment which contains"
" a reference to a single :term:`userid`, and matches that userid's "
":term:`principals <principal>` against the principals present in any "
":term:`ACL` found in the resource tree when attempting to call some "
":term:`view`."
msgstr "上記の設定では、要求の環境で渡された\ &quot;auth ticket \&quot;クッキーの値をsingle：term： `userid`への参照を含むポリシーと比較し、そのuseridの：term：` principals <principal> &#39;：term： `view`を呼び出そうとしたときに、リソースツリーに見つかったany：term：` ACL`に存在するプリンシパルに対して。"

#: ../../narr/security.rst:113
msgid ""
"While it is possible to mix and match different authentication and "
"authorization policies, it is an error to configure a Pyramid application"
" with an authentication policy but without the authorization policy or "
"vice versa. If you do this, you'll receive an error at application "
"startup time."
msgstr "さまざまな認証ポリシーと認証ポリシーを混在させることは可能ですが、Pyramidアプリケーションを認証ポリシーを使用して設定することはできますが、許可ポリシーは設定しないでください。これを行うと、アプリケーションの起動時にエラーが発生します。"

#: ../../narr/security.rst:120
msgid ""
"See also the :mod:`pyramid.authorization` and "
":mod:`pyramid.authentication` modules for alternative implementations of "
"authorization and authentication policies."
msgstr "認証と認証ポリシーの代替実装については：mod： `pyramid.authorization`と：mod：` pyramid.authentication`モジュールも参照してください。"

#: ../../narr/security.rst:131
msgid "Protecting Views with Permissions"
msgstr "アクセス権によるビューの保護"

#: ../../narr/security.rst:133
msgid ""
"To protect a :term:`view callable` from invocation based on a user's "
"security settings when a particular type of resource becomes the "
":term:`context`, you must pass a :term:`permission` to :term:`view "
"configuration`.  Permissions are usually just strings, and they have no "
"required composition: you can name permissions whatever you like."
msgstr "特定のタイプのリソースが：term： `context`になったときに、ユーザのセキュリティ設定に基づいて呼び出しから` view callable`を保護するには、：term： `permission`を：term：` view configuration `。パーミッションは通常文字列であり、必要なコンポジションはありません。あなたが好きなようにパーミッションを指定することができます。"

#: ../../narr/security.rst:139
msgid ""
"For example, the following view declaration protects the view named "
"``add_entry.html`` when the context resource is of type ``Blog`` with the"
" ``add`` permission using the "
":meth:`pyramid.config.Configurator.add_view` API:"
msgstr "たとえば、次のビュー宣言は、コンテキストリソースが：meth： `pyramid.config.Configuratorを使用して` `add``パーミッションを持つ` `Blog``型である場合、` `add_entry.html``という名前のビューを保護します。 add_view` API："

#: ../../narr/security.rst:153
msgid ""
"The equivalent view registration including the ``add`` permission name "
"may be performed via the ``@view_config`` decorator:"
msgstr "`` add``許可名を含む等価なビューの登録は、 `` @ view_config``デコレータを使って行うことができます："

#: ../../narr/security.rst:167
msgid ""
"As a result of any of these various view configuration statements, if an "
"authorization policy is in place when the view callable is found during "
"normal application operations, the requesting user will need to possess "
"the ``add`` permission against the :term:`context` resource in order to "
"be able to invoke the ``blog_entry_add_view`` view.  If they do not, the "
":term:`Forbidden view` will be invoked."
msgstr "これらの様々なビュー構成ステートメントの結果、通常のアプリケーション操作中にビュー呼び出し可能なものが見つかったときに認証ポリシーが設定されている場合、要求側ユーザーは：term： `に対して` `add``アクセス権を持っている必要があります`` blog_entry_add_view``ビューを呼び出せるようにするために `` context``リソースを使います。そうでない場合、：term： `禁止されたビュー &#39;が呼び出されます。"

#: ../../narr/security.rst:180
msgid "Setting a Default Permission"
msgstr "既定のアクセス許可の設定"

#: ../../narr/security.rst:182
msgid ""
"If a permission is not supplied to a view configuration, the registered "
"view will always be executable by entirely anonymous users: any "
"authorization policy in effect is ignored."
msgstr "ビュー構成に権限が与えられていない場合、登録ビューは常に完全に匿名ユーザーによって実行可能になります。有効な権限ポリシーはすべて無視されます。"

#: ../../narr/security.rst:186
msgid ""
"In support of making it easier to configure applications which are "
"\"secure by default\", :app:`Pyramid` allows you to configure a *default*"
" permission.  If supplied, the default permission is used as the "
"permission string to all view registrations which don't otherwise name a "
"``permission`` argument."
msgstr "\ &quot;デフォルトでセキュリティで保護されている\&quot;というアプリケーションを簡単に設定できるようにするため、：app： `Pyramid`では*デフォルトの権限を設定することができます。指定されていれば、デフォルトの許可は、それ以外の場合は `` permission``引数に名前を付けないすべてのビュー登録に対する許可文字列として使用されます。"

#: ../../narr/security.rst:191
msgid ""
"The :meth:`pyramid.config.Configurator.set_default_permission` method "
"supports configuring a default permission for an application."
msgstr "：meth： `pyramid.config.Configurator.set_default_permission`メソッドは、アプリケーションのデフォルトパーミッションの設定をサポートしています。"

#: ../../narr/security.rst:194
msgid "When a default permission is registered:"
msgstr "既定のアクセス許可が登録されている場合："

#: ../../narr/security.rst:196
msgid ""
"If a view configuration names an explicit ``permission``, the default "
"permission is ignored for that view registration, and the view-"
"configuration-named permission is used."
msgstr "ビュー構成が明示的に `` permission``という名前を付けると、そのビューの登録ではデフォルトの権限は無視され、view-configuration-namedの権限が使用されます。"

#: ../../narr/security.rst:200
msgid ""
"If a view configuration names the permission "
":data:`pyramid.security.NO_PERMISSION_REQUIRED`, the default permission "
"is ignored, and the view is registered *without* a permission (making it "
"available to all callers regardless of their credentials)."
msgstr "ビューの設定でpermission：data： `pyramid.security.NO_PERMISSION_REQUIRED`という名前が付けられた場合、デフォルトの権限は無視され、ビューは権限なしで*登録されます（資格に関係なくすべての発信者が利用できるようになります）。"

#: ../../narr/security.rst:207
msgid ""
"When you register a default permission, *all* views (even "
":term:`exception view` views) are protected by a permission.  For all "
"views which are truly meant to be anonymously accessible, you will need "
"to associate the view's configuration with the "
":data:`pyramid.security.NO_PERMISSION_REQUIRED` permission."
msgstr "デフォルトのパーミッションを登録すると、* all *ビュー（term： `例外ビュー`ビュー）もパーミッションで保護されます。真に匿名でアクセスできるすべてのビューについて、ビューの設定を：data： `pyramid.security.NO_PERMISSION_REQUIRED`パーミッションに関連付ける必要があります。"

#: ../../narr/security.rst:221
msgid "Assigning ACLs to Your Resource Objects"
msgstr "リソースオブジェクトへのACLの割り当て"

#: ../../narr/security.rst:223
msgid ""
"When the default :app:`Pyramid` :term:`authorization policy` determines "
"whether a user possesses a particular permission with respect to a "
"resource, it examines the :term:`ACL` associated with the resource.  An "
"ACL is associated with a resource by adding an ``__acl__`` attribute to "
"the resource object. This attribute can be defined on the resource "
"*instance* if you need instance-level security, or it can be defined on "
"the resource *class* if you just need type-level security."
msgstr "デフォルト：app： `Pyramid`：term：`認可ポリシー &#39;が、ユーザーがリソースに関して特定の許可を持っているかどうかを判断するとき、リソースに関連付けられた：term： `ACL`を検査します。 ACLは、リソースオブジェクトに `` __acl__``属性を追加することによってリソースに関連付けられます。この属性は、インスタンスレベルのセキュリティが必要な場合はリソース*インスタンス*で定義でき、タイプレベルのセキュリティが必要な場合はリソース*クラス*で定義できます。"

#: ../../narr/security.rst:231
msgid ""
"For example, an ACL might be attached to the resource for a blog via its "
"class:"
msgstr "たとえば、ブログのリソースにクラスを介してACLを添付することができます。"

#: ../../narr/security.rst:246
msgid ""
"Or, if your resources are persistent, an ACL might be specified via the "
"``__acl__`` attribute of an *instance* of a resource:"
msgstr "また、リソースが永続的である場合、ACLはリソースの*インスタンス*の `` __acl__``属性で指定することができます："

#: ../../narr/security.rst:266
msgid ""
"Whether an ACL is attached to a resource's class or an instance of the "
"resource itself, the effect is the same.  It is useful to decorate "
"individual resource instances with an ACL (as opposed to just decorating "
"their class) in applications such as content management systems where "
"fine-grained access is required on an object-by-object basis."
msgstr "ACLがリソースのクラスにアタッチされているか、リソース自体のインスタンスにアタッチされているかにかかわらず、その効果は同じです。オブジェクト単位できめ細かなアクセスが必要なコンテンツ管理システムなどのアプリケーションでは、個々のリソースインスタンスをACLで修飾すると便利です（クラスを装飾するのではなく）。"

#: ../../narr/security.rst:272
msgid ""
"Dynamic ACLs are also possible by turning the ACL into a callable on the "
"resource. This may allow the ACL to dynamically generate rules based on "
"properties of the instance."
msgstr "動的ACLは、ACLをリソース上の呼び出し可能にすることによっても可能です。これにより、ACLはインスタンスのプロパティに基づいてルールを動的に生成できます。"

#: ../../narr/security.rst:295
msgid ""
"Writing ``__acl__`` as properties is discouraged because an "
"``AttributeError`` occurring in ``fget`` or ``fset`` will be silently "
"dismissed (this is consistent with Python ``getattr`` and ``hasattr`` "
"behaviors). For dynamic ACLs, simply use callables, as documented above."
msgstr "`` __acl__``をプロパティとして書くのは、 `` fget``や `` fset``で起こっている `` AttributeError``が黙って解消されるので、お勧めしません（これはPythonの `` getattr``と `` hasattr`` `行動）。ダイナミックACLの場合は、上記のとおり、単にコールアーブルを使用します。"

#: ../../narr/security.rst:306
msgid "Elements of an ACL"
msgstr "ACLの要素"

#: ../../narr/security.rst:308
msgid "Here's an example ACL:"
msgstr "次に、ACLの例を示します。"

#: ../../narr/security.rst:322
msgid ""
"The example ACL indicates that the :data:`pyramid.security.Everyone` "
"principal—a special system-defined principal indicating, literally, "
"everyone—is allowed to view the blog, and the ``group:editors`` principal"
" is allowed to add to and edit the blog."
msgstr "ACLの例は、：data： `pyramid.security.Everyone`プリンシパル（文字通り全員を示す特別なシステム定義プリンシパル）がブログを閲覧することを許可され、` `group：editors``プリンシパルがブログに追加して編集する。"

#: ../../narr/security.rst:327
msgid ""
"Each element of an ACL is an :term:`ACE`, or access control entry. For "
"example, in the above code block, there are three ACEs: ``(Allow, "
"Everyone, 'view')``, ``(Allow, 'group:editors', 'add')``, and ``(Allow, "
"'group:editors', 'edit')``."
msgstr "ACLの各要素は：term： `ACE`またはアクセス制御エントリです。例えば、上記のコードブロックには、 ``（許可、全員、 &#39;ビュー&#39;）、 ``（許可、 &#39;グループ：編集者&#39;、 &#39;追加&#39;）、 ``許可： &#39;グループ：編集者&#39;、 &#39;編集&#39;） ``。"

#: ../../narr/security.rst:331
msgid ""
"The first element of any ACE is either :data:`pyramid.security.Allow`, or"
" :data:`pyramid.security.Deny`, representing the action to take when the "
"ACE matches.  The second element is a :term:`principal`.  The third "
"argument is a permission or sequence of permission names."
msgstr "ACEの最初の要素は、data： `pyramid.security.Allow`、または：data：` pyramid.security.Deny`です。これは、ACEが一致したときに取るアクションを表します。 2番目の要素は：term： `principal`です。 3番目の引数は、パーミッション名のパーミッションまたはシーケンスです。"

#: ../../narr/security.rst:336
msgid ""
"A principal is usually a user id, however it also may be a group id if "
"your authentication system provides group information and the effective "
":term:`authentication policy` policy is written to respect group "
"information. See :ref:`extending_default_authentication_policies`."
msgstr "プリンシパルは通常はユーザーIDですが、認証システムがグループ情報を提供し、有効：term： `認証ポリシー`ポリシーがグループ情報を考慮して記述されている場合は、グループIDでもかまいません。参照：ref： `extend_default_authentication_policies`を参照してください。"

#: ../../narr/security.rst:341
msgid ""
"Each ACE in an ACL is processed by an authorization policy *in the order "
"dictated by the ACL*.  So if you have an ACL like this:"
msgstr "ACL内の各ACEは、ACL *で指定された順序で認可ポリシー*によって処理されます。したがって、次のようなACLがあるとします。"

#: ../../narr/security.rst:356
msgid ""
"The default authorization policy will *allow* everyone the view "
"permission, even though later in the ACL you have an ACE that denies "
"everyone the view permission.  On the other hand, if you have an ACL like"
" this:"
msgstr "既定の認可ポリシーでは、後でACLにすべてのユーザーにビューのアクセス許可を拒否するACEがあっても、すべてのユーザーに表示許可が許可されます。一方、次のようなACLがある場合は、"

#: ../../narr/security.rst:372
msgid ""
"The authorization policy will deny everyone the view permission, even "
"though later in the ACL, there is an ACE that allows everyone."
msgstr "認可ポリシーは、後でACLにも、すべての人を許可するACEが存在するにもかかわらず、すべての人に表示許可を拒否します。"

#: ../../narr/security.rst:375
msgid ""
"The third argument in an ACE can also be a sequence of permission names "
"instead of a single permission name.  So instead of creating multiple "
"ACEs representing a number of different permission grants to a single "
"``group:editors`` group, we can collapse this into a single ACE, as "
"below."
msgstr "ACEの3番目の引数は、1つのアクセス権名の代わりに一連のアクセス権名にすることもできます。したがって、単一の `` group：editors``グループにいくつかの異なる許可許可を表す複数のACEを作成するのではなく、これを以下のように単一のACEにすることができます。"

#: ../../narr/security.rst:397
msgid "Special Principal Names"
msgstr "特別なプリンシパル名"

#: ../../narr/security.rst:399
msgid ""
"Special principal names exist in the :mod:`pyramid.security` module.  "
"They can be imported for use in your own code to populate ACLs, e.g., "
":data:`pyramid.security.Everyone`."
msgstr "特殊なプリンシパル名は：mod： `pyramid.security`モジュールにあります。あなた自身のコードで使用するためにインポートすることができます（例：：data： `pyramid.security.Everyone`）。"

#: ../../narr/security.rst:403
msgid ":data:`pyramid.security.Everyone`"
msgstr "：データ： `pyramid.security.Everyone`"

#: ../../narr/security.rst:405
msgid ""
"Literally, everyone, no matter what.  This object is actually a string "
"under the hood (``system.Everyone``).  Every user *is* the principal "
"named \"Everyone\" during every request, even if a security policy is not"
" in use."
msgstr "文字どおり、誰でも、何でも。このオブジェクトは実際にはフードの下の文字列です（ `` system.Everyone``）。すべてのユーザー*は、セキュリティポリシーが使用されていなくても、すべての要求中に\ &quot;Everyone \&quot;という名前のプリンシパルです。"

#: ../../narr/security.rst:409
msgid ":data:`pyramid.security.Authenticated`"
msgstr "：データ： `pyramid.security.Authenticated`"

#: ../../narr/security.rst:411
msgid ""
"Any user with credentials as determined by the current security policy.  "
"You might think of it as any user that is \"logged in\".  This object is "
"actually a string under the hood (``system.Authenticated``)."
msgstr "現在のセキュリティポリシーによって決定された資格情報を持つすべてのユーザー。あなたは\ &quot;ログインしている\&quot;というユーザーと考えるかもしれません。このオブジェクトは実際にはフードの下にある文字列です（ `` system.Authenticated``）。"

#: ../../narr/security.rst:420
msgid "Special Permissions"
msgstr "特別な許可"

#: ../../narr/security.rst:422
msgid ""
"Special permission names exist in the :mod:`pyramid.security` module.  "
"These can be imported for use in ACLs."
msgstr "特殊なパーミッション名は：mod： `pyramid.security`モジュールにあります。これらは、ACLで使用するためにインポートできます。"

#: ../../narr/security.rst:427
msgid ":data:`pyramid.security.ALL_PERMISSIONS`"
msgstr "：データ： `pyramid.security.ALL_PERMISSIONS`"

#: ../../narr/security.rst:429
msgid ""
"An object representing, literally, *all* permissions.  Useful in an ACL "
"like so: ``(Allow, 'fred', ALL_PERMISSIONS)``.  The ``ALL_PERMISSIONS`` "
"object is actually a stand-in object that has a ``__contains__`` method "
"that always returns ``True``, which, for all known authorization "
"policies, has the effect of indicating that a given principal has any "
"permission asked for by the system."
msgstr "文字通り* all *権限を表すオブジェクト。 ``（許可、 &#39;fred&#39;、ALL_PERMISSIONS） ``のようなACLで役に立ちます。 `` ALL_PERMISSIONS``オブジェクトは、実際には、常に `` True``を返す `` __contains__``メソッドを持つスタンドインオブジェクトです。既知のすべての認可ポリシーに対して、与えられたプリンシパルが持っていることを示す効果がありますシステムによって要求されたすべての許可。"

#: ../../narr/security.rst:441
msgid "Special ACEs"
msgstr "特別なACE"

#: ../../narr/security.rst:443
msgid ""
"A convenience :term:`ACE` is defined representing a deny to everyone of "
"all permissions in :data:`pyramid.security.DENY_ALL`.  This ACE is often "
"used as the *last* ACE of an ACL to explicitly cause inheriting "
"authorization policies to \"stop looking up the traversal tree\" "
"(effectively breaking any inheritance). For example, an ACL which allows "
"*only* ``fred`` the view permission for a particular resource, despite "
"what inherited ACLs may say when the default authorization policy is in "
"effect, might look like so:"
msgstr "便宜上、用語： `ACE`は：data：` pyramid.security.DENY_ALL`のすべてのパーミッションの拒否を表すように定義されています。このACEは、ACLの* last * ACEとして使用され、継承された認可ポリシーが\ &quot;トラバーサルツリーの検索を中止する\&quot;（事実上すべての継承を破棄）するようにしばしば使用されます。例えば、デフォルトの認可ポリシーが有効なときに継承されたACLがどのようなことを言うかもしれないにもかかわらず、特定のリソースに対するビューのアクセス権のみを `` fred``で許可するACLは、次のようになります："

#: ../../narr/security.rst:459
msgid ""
"Under the hood, the :data:`pyramid.security.DENY_ALL` ACE equals the "
"following:"
msgstr "フードの下では、：data： `pyramid.security.DENY_ALL` ACEは以下のようになります："

#: ../../narr/security.rst:473
msgid "ACL Inheritance and Location-Awareness"
msgstr "ACLの継承とロケーション認識"

#: ../../narr/security.rst:475
msgid ""
"While the default :term:`authorization policy` is in place, if a resource"
" object does not have an ACL when it is the context, its *parent* is "
"consulted for an ACL.  If that object does not have an ACL, *its* parent "
"is consulted for an ACL, ad infinitum, until we've reached the root and "
"there are no more parents left."
msgstr "default：term： `authorization policy`が設定されていますが、リソースオブジェクトがコンテキストのときにACLを持たない場合は、ACLの* parent *が参照されます。そのオブジェクトにACLがない場合、ルートに達して親がなくなるまで* its * parentはACL、ad infinitumについて調べられます。"

#: ../../narr/security.rst:481
msgid ""
"In order to allow the security machinery to perform ACL inheritance, "
"resource objects must provide *location-awareness*.  Providing *location-"
"awareness* means two things: the root object in the resource tree must "
"have a ``__name__`` attribute and a ``__parent__`` attribute."
msgstr "セキュリティ機構がACL継承を実行できるようにするには、リソースオブジェクトは* location-awareness *を提供する必要があります。 * location-awareness *を指定するとは、リソースツリーのルートオブジェクトに `` __name__``属性と `` __parent__``属性が必要です。"

#: ../../narr/security.rst:493
msgid ""
"An object with a ``__parent__`` attribute and a ``__name__`` attribute is"
" said to be *location-aware*.  Location-aware objects define a "
"``__parent__`` attribute which points at their parent object.  The root "
"object's ``__parent__`` is ``None``."
msgstr "`` __parent__``属性と `` __name__``属性を持つオブジェクトは* location-aware *と言います。位置認識オブジェクトは親オブジェクトを指す `` __parent__``属性を定義します。ルートオブジェクトの `` __parent__``は `` None``です。"

#: ../../narr/security.rst:500
msgid ""
"See also :ref:`location_module` for documentations of functions which use"
" location-awareness."
msgstr "ロケーション認識を使用する関数のドキュメントについては、：ref： `location_module`も参照してください。"

#: ../../narr/security.rst:505
msgid "See also :ref:`location_aware`."
msgstr "参照：ref： `location_aware`も参照してください。"

#: ../../narr/security.rst:511
msgid "Changing the Forbidden View"
msgstr "禁止されたビューの変更"

#: ../../narr/security.rst:513
msgid ""
"When :app:`Pyramid` denies a view invocation due to an authorization "
"denial, the special ``forbidden`` view is invoked.  Out of the box, this "
"forbidden view is very plain.  See :ref:`changing_the_forbidden_view` "
"within :ref:`hooks_chapter` for instructions on how to create a custom "
"forbidden view and arrange for it to be called when view authorization is"
" denied."
msgstr "：app： `Pyramid`が許可拒否のためにビューの呼び出しを拒否したとき、特別な` `禁じられた` `ビューが呼び出されます。箱の外では、この禁止された表示は非常に明白です。ビューの許可が拒否されたときに呼び出されるように、カスタム禁止ビューを作成する方法については、ref： `hooks_chapter`を参照してください：ref：` changing_the_forbidden_​​view`：ref： `hooks_chapter`を参照してください。"

#: ../../narr/security.rst:525
msgid "Debugging View Authorization Failures"
msgstr "ビュー認証エラーのデバッグ"

#: ../../narr/security.rst:527
msgid ""
"If your application in your judgment is allowing or denying view access "
"inappropriately, start your application under a shell using the "
"``PYRAMID_DEBUG_AUTHORIZATION`` environment variable set to ``1``.  For "
"example:"
msgstr "あなたの判断でアプリケーションがビューのアクセスを不適切に許可または拒否している場合は、 `` PYRAMID_DEBUG_AUTHORIZATION``環境変数を `` 1``に設定してシェルの下でアプリケーションを起動してください。例えば："

#: ../../narr/security.rst:536
msgid ""
"When any authorization takes place during a top-level view rendering, a "
"message will be logged to the console (to stderr) about what ACE in which"
" ACL permitted or denied the authorization based on authentication "
"information."
msgstr "トップレベルのビューレンダリング中に何らかの認可が行われると、認証情報に基づいて認可を許可または拒否されたACEのACEについてコンソール（stderr）にログが記録されます。"

#: ../../narr/security.rst:540
msgid ""
"This behavior can also be turned on in the application ``.ini`` file by "
"setting the ``pyramid.debug_authorization`` key to ``true`` within the "
"application's configuration section, e.g.:"
msgstr "この動作は、アプリケーションの設定セクション内で `` pyramid.debug_authorization``キーを `` true``に設定することで、アプリケーションの `` .ini``ファイルで有効にすることもできます。"

#: ../../narr/security.rst:551
msgid ""
"With this debug flag turned on, the response sent to the browser will "
"also contain security debugging information in its body."
msgstr "このデバッグフラグをオンにすると、ブラウザに送信されるレスポンスにはセキュリティデバッグ情報も含まれます。"

#: ../../narr/security.rst:555
msgid "Debugging Imperative Authorization Failures"
msgstr "強制的な認証失敗のデバッグ"

#: ../../narr/security.rst:557
msgid ""
"The :meth:`pyramid.request.Request.has_permission` API is used to check "
"security within view functions imperatively.  It returns instances of "
"objects that are effectively booleans.  But these objects are not raw "
"``True`` or ``False`` objects, and have information attached to them "
"about why the permission was allowed or denied.  The object will be one "
"of :data:`pyramid.security.ACLAllowed`, "
":data:`pyramid.security.ACLDenied`, :data:`pyramid.security.Allowed`, or "
":data:`pyramid.security.Denied`, as documented in :ref:`security_module`."
"  At the very minimum, these objects will have a ``msg`` attribute, which"
" is a string indicating why the permission was denied or allowed.  "
"Introspecting this information in the debugger or via print statements "
"when a call to :meth:`~pyramid.request.Request.has_permission` fails is "
"often useful."
msgstr "：meth： `pyramid.request.Request.has_permission` APIは、ビュー関数内のセキュリティを必須にチェックするために使用されます。実質的にブーリアンであるオブジェクトのインスタンスを返します。しかし、これらのオブジェクトは生の `` True``や `False``オブジェクトではなく、許可が拒否された理由についての情報が添付されています。オブジェクトは、data： `pyramid.security.ACLAllowed`、：data：` pyramid.security.ACLDenied`、：data： `pyramid.security.Allowed`、または：data：` pyramid.security.Denied`のいずれかです。 ：ref： `security_module`に記述されています。最小限でも、これらのオブジェクトは `` msg``属性を持ちます。これは、なぜパーミッションが拒否されたのかを示す文字列です。 ：meth： `〜pyramid.request.Request.has_permission`への呼び出しが失敗したときに、デバッガやprint文でこの情報を調べることはしばしば役に立ちます。"

#: ../../narr/security.rst:576
msgid "Extending Default Authentication Policies"
msgstr "デフォルトの認証ポリシーの拡張"

#: ../../narr/security.rst:578
msgid ""
"Pyramid ships with some built in authentication policies for use in your "
"applications. See :mod:`pyramid.authentication` for the available "
"policies. They differ on their mechanisms for tracking authentication "
"credentials between requests, however they all interface with your "
"application in mostly the same way."
msgstr "Pyramidには、アプリケーションで使用するためのいくつかの認証ポリシーが組み込まれています。利用可能なポリシーについては、mod： `pyramid.authentication`を参照してください。要求間で認証資格情報を追跡するメカニズムは異なりますが、アプリケーションとのインターフェイスはほとんど同じです。"

#: ../../narr/security.rst:584
msgid ""
"Above you learned about :ref:`assigning_acls`. Each :term:`principal` "
"used in the :term:`ACL` is matched against the list returned from "
":meth:`pyramid.interfaces.IAuthenticationPolicy.effective_principals`. "
"Similarly, :meth:`pyramid.request.Request.authenticated_userid` maps to "
":meth:`pyramid.interfaces.IAuthenticationPolicy.authenticated_userid`."
msgstr "あなたの上で学んだ：ref： `assigning_acls`。それぞれ：term： `principal`は：term：` ACL`で使用され、：meth： `pyramid.interfaces.IAuthenticationPolicy.effective_principals`から返されたリストと照合されます。同様に、：meth： `pyramid.request.Request.authenticated_userid`は：meth：` pyramid.interfaces.IAuthenticationPolicy.authenticated_userid`にマップします。"

#: ../../narr/security.rst:590
msgid ""
"You may control these values by subclassing the default authentication "
"policies. For example, below we subclass the "
":class:`pyramid.authentication.AuthTktAuthenticationPolicy` and define "
"extra functionality to query our database before confirming that the "
":term:`userid` is valid in order to avoid blindly trusting the value in "
"the cookie (what if the cookie is still valid, but the user has deleted "
"their account?).  We then use that :term:`userid` to augment the "
"``effective_principals`` with information about groups and other state "
"for that user."
msgstr "これらの値は、デフォルトの認証ポリシーをサブクラス化することで制御できます。例えば：class： `pyramid.authentication.AuthTktAuthenticationPolicy`をサブクラス化し、クッキーの値を盲目的に信頼することを避けるために：term：` userid`が有効であることを確認する前に、データベースに問い合わせる特別な機能を定義します。クッキーがまだ有効だが、ユーザーがアカウントを削除した場合）次に、その：term： `userid`を使って、` `effective_principals``を、そのユーザのグループや他の状態に関する情報で補強します。"

#: ../../narr/security.rst:618
msgid ""
"In most instances ``authenticated_userid`` and ``effective_principals`` "
"are application-specific, whereas ``unauthenticated_userid``, "
"``remember``, and ``forget`` are generic and focused on transport and "
"serialization of data between consecutive requests."
msgstr "ほとんどの場合、 `` authenticated_userid``と `` effective_principals``はアプリケーション固有ですが、 `` unauthenticated_userid``、 `` remember``、 `` forget``は一般的であり、連続したリクエスト。"

#: ../../narr/security.rst:629
msgid "Creating Your Own Authentication Policy"
msgstr "独自の認証ポリシーの作成"

#: ../../narr/security.rst:631
msgid ""
":app:`Pyramid` ships with a number of useful out-of-the-box security "
"policies (see :mod:`pyramid.authentication`).  However, creating your own"
" authentication policy is often necessary when you want to control the "
"\"horizontal and vertical\" of how your users authenticate.  Doing so is "
"a matter of creating an instance of something that implements the "
"following interface:"
msgstr "：app： `Pyramid`には、いくつかの便利なセキュリティポリシーが付属しています（mod：` pyramid.authentication`参照）。ただし、ユーザーの認証方法の「水平および垂直」を制御する場合は、独自の認証ポリシーを作成する必要があります。そうすることは、次のインターフェースを実装するもののインスタンスを作成することです。"

#: ../../narr/security.rst:692
msgid ""
"After you do so, you can pass an instance of such a class into the "
":class:`~pyramid.config.Configurator.set_authentication_policy` method at"
" configuration time to use it."
msgstr "その後、そのクラスのインスタンスを設定時に：class： `〜pyramid.config.Configurator.set_authentication_policy`メソッドに渡して使用することができます。"

#: ../../narr/security.rst:702
msgid "Creating Your Own Authorization Policy"
msgstr "独自の認証ポリシーの作成"

#: ../../narr/security.rst:704
msgid ""
"An authorization policy is a policy that allows or denies access after a "
"user has been authenticated.  Most :app:`Pyramid` applications will use "
"the default :class:`pyramid.authorization.ACLAuthorizationPolicy`."
msgstr "認可ポリシーは、ユーザーが認証された後にアクセスを許可または拒否するポリシーです。 Most：app： `Pyramid`アプリケーションはデフォルト：class：` pyramid.authorization.ACLAuthorizationPolicy`を使用します。"

#: ../../narr/security.rst:708
msgid ""
"However, in some cases, it's useful to be able to use a different "
"authorization policy than the default "
":class:`~pyramid.authorization.ACLAuthorizationPolicy`. For example, it "
"might be desirable to construct an alternate authorization policy which "
"allows the application to use an authorization mechanism that does not "
"involve :term:`ACL` objects."
msgstr "しかし、場合によっては、デフォルト：class： `〜pyramid.authorization.ACLAuthorizationPolicy`以外の別の認証ポリシーを使用できるようにすると便利です。例えば、アプリケーションがterm： `ACL`オブジェクトに関係しない認証機構を使用することを可能にする代替の認証ポリシーを構築することが望ましいかもしれません。"

#: ../../narr/security.rst:714
msgid ""
":app:`Pyramid` ships with only a single default authorization policy, so "
"you'll need to create your own if you'd like to use a different one.  "
"Creating and using your own authorization policy is a matter of creating "
"an instance of an object that implements the following interface:"
msgstr "：app： `Pyramid`はデフォルトの認証ポリシーが1つしかないので、別のものを使用するには独自のものを作成する必要があります。独自の認可ポリシーを作成して使用することは、次のインターフェースを実装するオブジェクトのインスタンスを作成することです。"

#: ../../narr/security.rst:738
msgid ""
"After you do so, you can pass an instance of such a class into the "
":class:`~pyramid.config.Configurator.set_authorization_policy` method at "
"configuration time to use it."
msgstr "その後、このクラスのインスタンスを構成時に：class： `〜pyramid.config.Configurator.set_authorization_policy`メソッドに渡して使用することができます。"

#: ../../narr/security.rst:745
msgid "Admonishment Against Secret-Sharing"
msgstr "シークレット・シェアリングに対する警戒"

#: ../../narr/security.rst:747
msgid ""
"A \"secret\" is required by various components of Pyramid.  For example, "
"the :term:`authentication policy` below uses a secret value ``seekrit``::"
msgstr "\ &quot;秘密\&quot;は、Pyramidのさまざまなコンポーネントによって必要とされます。たとえば、以下の：term： `認証ポリシー`は秘密の値 `` seekrit`` ::を使用します。"

#: ../../narr/security.rst:752
msgid "A :term:`session factory` also requires a secret::"
msgstr "A：term： `session factory`には秘密が必要です::"

#: ../../narr/security.rst:756
msgid ""
"It is tempting to use the same secret for multiple Pyramid subsystems.  "
"For example, you might be tempted to use the value ``seekrit`` as the "
"secret for both the authentication policy and the session factory defined"
" above.  This is a bad idea, because in both cases, these secrets are "
"used to sign the payload of the data."
msgstr "複数のPyramidサブシステムに同じ秘密を使用するのは魅力的です。たとえば、上記で定義した認証ポリシーとセッションファクトリの両方の秘密として、 `` seekrit``という値を使うことができます。どちらの場合も、これらの秘密はデータのペイロードに署名するために使用されるため、これは悪い考えです。"

#: ../../narr/security.rst:762
msgid ""
"If you use the same secret for two different parts of your application "
"for signing purposes, it may allow an attacker to get his chosen "
"plaintext signed, which would allow the attacker to control the content "
"of the payload.  Re-using a secret across two different subsystems might "
"drop the security of signing to zero. Keys should not be re-used across "
"different contexts where an attacker has the possibility of providing a "
"chosen plaintext."
msgstr "署名の目的でアプリケーションの2つの異なる部分に同じ秘密を使用すると、攻撃者が選択した平文を署名することが可能になり、攻撃者がペイロードの内容を制御できるようになります。 2つの異なるサブシステムにわたって秘密を再使用すると、署名のセキュリティがゼロになる可能性があります。鍵は、攻撃者が選択した平文を提供する可能性のある別のコンテキストで再使用しないでください。"

#: ../../narr/security.rst:774
msgid "Preventing Cross-Site Request Forgery Attacks"
msgstr "クロスサイトリクエスト偽造攻撃の防止"

#: ../../narr/security.rst:776
msgid ""
"`Cross-site request forgery <https://en.wikipedia.org/wiki/Cross-"
"site_request_forgery>`_ attacks are a phenomenon whereby a user who is "
"logged in to your website might inadvertantly load a URL because it is "
"linked from, or embedded in, an attacker's website. If the URL is one "
"that may modify or delete data, the consequences can be dire."
msgstr "`クロスサイトリクエスト偽造<https://en.wikipedia.org/wiki/Cross-site_request_forgery>攻撃は、攻撃者のウェブサイトからリンクされているか、またはウェブサイトに埋め込まれているため、ウェブサイトにログインしているユーザーが誤ってURLを読み込んでしまう現象です。 URLがデータを変更または削除するURLである場合、その結果は致命的となる可能性があります。"

#: ../../narr/security.rst:782
msgid ""
"You can avoid most of these attacks by issuing a unique token to the "
"browser and then requiring that it be present in all potentially unsafe "
"requests. :app:`Pyramid` provides facilities to create and check CSRF "
"tokens."
msgstr "これらの攻撃のほとんどは、ブラウザに一意のトークンを発行してから、安全でない可能性があるすべての要求にそのトークンが存在することを要求することで回避できます。 ：app： `Pyramid`は、CSRFトークンを作成して確認するための機能を提供します。"

#: ../../narr/security.rst:786
msgid ""
"By default :app:`Pyramid` comes with a session-based CSRF implementation "
":class:`pyramid.csrf.SessionCSRFStoragePolicy`. To use it, you must first"
" enable a :term:`session factory` as described in "
":ref:`using_the_default_session_factory` or "
":ref:`using_alternate_session_factories`. Alternatively, you can use a "
"cookie-based implementation :class:`pyramid.csrf.CookieCSRFStoragePolicy`"
" which gives some additional flexibility as it does not require a session"
" for each user. You can also define your own implementation of "
":class:`pyramid.interfaces.ICSRFStoragePolicy` and register it with the "
":meth:`pyramid.config.Configurator.set_csrf_storage_policy` directive."
msgstr "デフォルトでは、app： `Pyramid`には、セッションベースのCSRF実装であるclass：` pyramid.csrf.SessionCSRFStoragePolicy`があります。それを使用するには、：ref： `using_the_default_session_factory`または：ref：` using_alternate_session_factories`で説明されているように、まず：term： `session factory`を有効にする必要があります。代わりに、cookieベースの実装を使用することもできます：class： `pyramid.csrf.CookieCSRFStoragePolicy`これは、各ユーザにセッションを必要としないため、いくつかの柔軟性を提供します。独自の：class： `pyramid.interfaces.ICSRFStoragePolicy`の実装を定義し、：meth：` pyramid.config.Configurator.set_csrf_storage_policy`ディレクティブで登録することもできます。"

#: ../../narr/security.rst:810
msgid "Using the ``csrf.get_csrf_token`` Method"
msgstr "`` csrf.get_csrf_token``メソッドの使用"

#: ../../narr/security.rst:812
msgid ""
"To get the current CSRF token, use the "
":data:`pyramid.csrf.get_csrf_token` method."
msgstr "現在のCSRFトークンを取得するには、：data： `pyramid.csrf.get_csrf_token`メソッドを使用します。"

#: ../../narr/security.rst:820
msgid ""
"The ``get_csrf_token()`` method accepts a single argument: the request. "
"It returns a CSRF *token* string. If ``get_csrf_token()`` or "
"``new_csrf_token()`` was invoked previously for this user, then the "
"existing token will be returned. If no CSRF token previously existed for "
"this user, then a new token will be set into the session and returned. "
"The newly created token will be opaque and randomized."
msgstr "`` get_csrf_token（） ``メソッドは単一の引数、つまり要求を受け入れます。 CSRF * token *文字列を返します。 `` get_csrf_token（） ``または `` new_csrf_token（） ``が以前にこのユーザに対して呼び出された場合、既存のトークンが返されます。以前にこのユーザーに対してCSRFトークンが存在しなかった場合、新しいトークンがセッションに設定され、返されます。新しく作成されたトークンは不透明でランダム化されます。"

#: ../../narr/security.rst:830
msgid "Using the ``get_csrf_token`` global in templates"
msgstr "テンプレートで `` get_csrf_token``グローバルを使う"

#: ../../narr/security.rst:832
msgid ""
"Templates have a ``get_csrf_token()`` method inserted into their globals,"
" which allows you to get the current token without modifying the view "
"code. This method takes no arguments and returns a CSRF token string. You"
" can use the returned token as the value of a hidden field in a form that"
" posts to a method that requires elevated privileges, or supply it as a "
"request header in AJAX requests."
msgstr "テンプレートには、グローバルに挿入された `` get_csrf_token（） ``メソッドがあり、ビューコードを変更せずに現在のトークンを取得できます。このメソッドは引数を取らず、CSRFトークン文字列を返します。返されたトークンは、昇格された特権を必要とするメソッドに投稿するフォームの隠しフィールドの値として使用することも、AJAX要求の要求ヘッダーとして供給することもできます。"

#: ../../narr/security.rst:839
msgid "For example, include the CSRF token as a hidden field:"
msgstr "たとえば、CSRFトークンを隠しフィールドとして含めます。"

#: ../../narr/security.rst:848
msgid "Or include it as a header in a jQuery AJAX request:"
msgstr "または、これをjQuery AJAXリクエストのヘッダーとしてインクルードします。"

#: ../../narr/security.rst:861
msgid ""
"The handler for the URL that receives the request should then require "
"that the correct CSRF token is supplied."
msgstr "要求を受け取るURLのハンドラは、正しいCSRFトークンが供給されることを要求する必要があります。"

#: ../../narr/security.rst:868
msgid "Using the ``csrf.new_csrf_token`` Method"
msgstr "`` csrf.new_csrf_token``メソッドの使用"

#: ../../narr/security.rst:870
msgid ""
"To explicitly create a new CSRF token, use the ``csrf.new_csrf_token()`` "
"method.  This differs only from ``csrf.get_csrf_token()`` inasmuch as it "
"clears any existing CSRF token, creates a new CSRF token, sets the token "
"into the user, and returns the token."
msgstr "明示的に新しいCSRFトークンを作成するには、 `` csrf.new_csrf_token（） ``メソッドを使用します。これは、既存のCSRFトークンをクリアし、新しいCSRFトークンを作成し、トークンをユーザに設定し、トークンを返すだけで、 `` csrf.get_csrf_token（） ``とだけ異なります。"

#: ../../narr/security.rst:882
msgid ""
"It is not possible to force a new CSRF token from a template. If you want"
" to regenerate your CSRF token then do it in the view code and return the"
" new token as part of the context."
msgstr "テンプレートから新しいCSRFトークンを強制することはできません。 CSRFトークンを再生成する場合は、ビューコードでそれを行い、新しいトークンをコンテキストの一部として返します。"

#: ../../narr/security.rst:887
msgid "Checking CSRF Tokens Manually"
msgstr "CSRFトークンを手動で確認する"

#: ../../narr/security.rst:889
msgid ""
"In request handling code, you can check the presence and validity of a "
"CSRF token with :func:`pyramid.csrf.check_csrf_token`. If the token is "
"valid, it will return ``True``, otherwise it will raise "
"``HTTPBadRequest``. Optionally, you can specify ``raises=False`` to have "
"the check return ``False`` instead of raising an exception."
msgstr "リクエスト処理コードでは、：func： `pyramid.csrf.check_csrf_token`を使用して、CSRFトークンの存在と有効性をチェックできます。トークンが有効であれば `` True``を返し、そうでなければ `` HTTPBadRequest``を送出します。オプションで、 `` raises = False``を指定すると、例外を発生させる代わりにチェックが `` False``を返すようにすることができます。"

#: ../../narr/security.rst:895
msgid ""
"By default, it checks for a POST parameter named ``csrf_token`` or a "
"header named ``X-CSRF-Token``."
msgstr "デフォルトでは、 `` csrf_token``という名前のPOSTパラメータか `` X-CSRF-Token``というヘッダがあるかどうかを調べます。"

#: ../../narr/security.rst:911
msgid "Checking CSRF Tokens Automatically"
msgstr "CSRFトークンの自動確認"

#: ../../narr/security.rst:915
msgid ""
":app:`Pyramid` supports automatically checking CSRF tokens on requests "
"with an unsafe method as defined by RFC2616. Any other request may be "
"checked manually. This feature can be turned on globally for an "
"application using the "
":meth:`pyramid.config.Configurator.set_default_csrf_options` directive. "
"For example:"
msgstr "：app： `Pyramid`は、RFC2616で定義されているような安全でないメソッドで、CSRFトークンを自動的にチェックします。他の要求は手動でチェックすることができます。この機能は、：meth： `pyramid.config.Configurator.set_default_csrf_options`指示文を使用してアプリケーションに対してグローバルにオンにすることができます。例えば："

#: ../../narr/security.rst:928
msgid ""
"CSRF checking may be explicitly enabled or disabled on a per-view basis "
"using the ``require_csrf`` view option. A value of ``True`` or ``False`` "
"will override the default set by ``set_default_csrf_options``. For "
"example:"
msgstr "CSRF検査は、 `` require_csrf``ビューオプションを使用してビュー単位で明示的に有効または無効にすることができます。 `` True``または `` False``の値は、 `` set_default_csrf_options``で設定されたデフォルトを上書きします。例えば："

#: ../../narr/security.rst:938
msgid ""
"When CSRF checking is active, the token and header used to find the "
"supplied CSRF token will be ``csrf_token`` and ``X-CSRF-Token``, "
"respectively, unless otherwise overridden by "
"``set_default_csrf_options``. The token is checked against the value in "
"``request.POST`` which is the submitted form body. If this value is not "
"present, then the header will be checked."
msgstr "CSRFチェックがアクティブな場合、 `` set_default_csrf_options``によってオーバーライドされない限り、提供されたCSRFトークンを見つけるために使用されるトークンとヘッダは、それぞれ `` csrf_token``と `` X-CSRF-Token``です。トークンは、送信されたフォーム本体である `` request.POST``の値と照合されます。この値が存在しない場合、ヘッダーがチェックされます。"

#: ../../narr/security.rst:944
msgid ""
"In addition to token based CSRF checks, if the request is using HTTPS "
"then the automatic CSRF checking will also check the referrer of the "
"request to ensure that it matches one of the trusted origins. By default "
"the only trusted origin is the current host, however additional origins "
"may be configured by setting ``pyramid.csrf_trusted_origins`` to a list "
"of domain names (and ports if they are non-standard). If a host in the "
"list of domains starts with a ``.`` then that will allow all subdomains "
"as well as the domain without the ``.``."
msgstr "トークンベースのCSRFチェックに加えて、リクエストがHTTPSを使用している場合、自動CSRFチェックはリクエストのリファラーをチェックして、信頼できる発信元の1つに一致することを確認します。デフォルトでは、信頼できる唯一の原点は現在のホストですが、 `` pyramid.csrf_trusted_origins``をドメイン名のリスト（およびそれらが非標準の場合はポート）に設定することによって、追加の起点を設定することができます。ドメインのリストのホストが `` .``で始まっている場合、 `` .``のないドメインと同様に、すべてのサブドメインが許可されます。"

#: ../../narr/security.rst:952
msgid ""
"If CSRF checks fail then a :class:`pyramid.exceptions.BadCSRFToken` or "
":class:`pyramid.exceptions.BadCSRFOrigin` exception will be raised. This "
"exception may be caught and handled by an :term:`exception view` but, by "
"default, will result in a ``400 Bad Request`` response being sent to the "
"client."
msgstr "CSRFチェックが失敗した場合、class： `pyramid.exceptions.BadCSRFToken`または：class：` pyramid.exceptions.BadCSRFOrigin`例外が送出されます。この例外は：term： `exception view`によって捕捉され、処理されるかもしれませんが、デフォルトでは、` `400 Bad Request``応答がクライアントに送られます。"

#: ../../narr/security.rst:959
msgid "Checking CSRF Tokens with a View Predicate"
msgstr "ビュー・プレディケートによるCSRFトークンのチェック"

#: ../../narr/security.rst:961
msgid ""
"Use the ``require_csrf`` option or read :ref:`auto_csrf_checking` instead"
" to have :class:`pyramid.exceptions.BadCSRFToken` exceptions raised."
msgstr "`` require_csrf``オプションを使うか、：ref： `auto_csrf_checking`を読んで：class：` pyramid.exceptions.BadCSRFToken`例外を発生させてください。"

#: ../../narr/security.rst:965
msgid ""
"A convenient way to require a valid CSRF token for a particular view is "
"to include ``check_csrf=True`` as a view predicate. See "
":meth:`pyramid.config.Configurator.add_view`."
msgstr "特定のビューに対して有効なCSRFトークンを要求する便利な方法は、ビューの述語として `` check_csrf = True``を含めることです。参照：meth： `pyramid.config.Configurator.add_view`。"

#: ../../narr/security.rst:976
msgid ""
"A mismatch of a CSRF token is treated like any other predicate miss, and "
"the predicate system, when it doesn't find a view, raises "
"``HTTPNotFound`` instead of ``HTTPBadRequest``, so ``check_csrf=True`` "
"behavior is different from calling :func:`pyramid.csrf.check_csrf_token`."
msgstr "CSRFトークンの不一致は、他の述語ミスのように扱われ、ビューを見つけられない場合、述語システムは `` HTTPBadRequest``の代わりに `` HTTPNotFound``を発生させるので、 `` check_csrf = True``振る舞いは：func： `pyramid.csrf.check_csrf_token`とは異なります。"


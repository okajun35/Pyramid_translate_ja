# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web
# Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Pyramid Web Framework 1.9.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-02 00:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"


#: ../../tutorials/wiki2/basiclayout.rst:5
msgid "Basic Layout"
msgstr "基本レイアウト(Basic Layout)"

#: ../../tutorials/wiki2/basiclayout.rst:7
msgid ""
"The starter files generated by the ``alchemy`` cookiecutter are very "
"basic, but they provide a good orientation for the high-level patterns "
"common to most :term:`URL dispatch`-based :app:`Pyramid` projects."
msgstr ""
"「alchemy」cookiecutterで生成されたスターターファイルは非常に"
"基本的ですがほとんどの :term:`URL dispatch` ベースの:app:`Pyramid` プ"
"ロジェクトに共通する高水準のパターンに適しています。"

#: ../../tutorials/wiki2/basiclayout.rst:13
msgid "Application configuration with ``__init__.py``"
msgstr "「__init __.py」によるアプリケーション構成（ Application configuration with ``__init__.py`` ）"

#: ../../tutorials/wiki2/basiclayout.rst:15
msgid ""
"A directory on disk can be turned into a Python :term:`package` by "
"containing an ``__init__.py`` file.  Even if empty, this marks a "
"directory as a Python package.  We use ``__init__.py`` both as a marker, "
"indicating the directory in which it's contained is a package, and to "
"contain application configuration code."
msgstr ""
"ディスク上のディレクトリは「__init__.py」ファイルを含むことで、Pythonの "
" :term:`package` に変換できます。たとえ空であってもディレクトリをPython"
"パッケージとしてマークします。「__init__.py」はパッケージのディレク"
"トリを示すマーカーとして、そしてアプリケーションの設定コードを格納するためのマーカーとして使われます。"

#: ../../tutorials/wiki2/basiclayout.rst:21
msgid "Open ``tutorial/__init__.py``.  It should already contain the following:"
msgstr "「tutorial/__init__.py」を開きます。それはすでに以下を含んでいるはずです："

#: ../../tutorials/wiki2/basiclayout.rst:27
msgid ""
"Let's go over this piece-by-piece. First we need some imports to support "
"later code:"
msgstr "この記事を見て行きましょう。まず、後のコードをサポートするためにいくつかのインポートが必要です。"

#: ../../tutorials/wiki2/basiclayout.rst:35
msgid ""
"``__init__.py`` defines a function named ``main``.  Here is the entirety "
"of the ``main`` function we've defined in our ``__init__.py``:"
msgstr ""
"「__init__.py」は 「main」という名前の関数を定義します。"
"ここでは「__init__.py」で定義した 「main」関数の全体を表示します："

#: ../../tutorials/wiki2/basiclayout.rst:43
msgid ""
"When you invoke the ``pserve development.ini`` command, the ``main`` "
"function above is executed.  It accepts some settings and returns a "
":term:`WSGI` application.  (See :ref:`startup_chapter` for more about "
"``pserve``.)"
msgstr ""
"「pserve development.ini」コマンドを実行すると、上記の 「main」関数が実行されます。"
"これはいくつかの設定を受け入れて :term:`WSGI` アプリケーションを返却します。"
" （ 「pserve」の詳細については :ref:`startup_chapter` を参照してください。）"

#: ../../tutorials/wiki2/basiclayout.rst:47
msgid "Next in ``main``, construct a :term:`Configurator` object:"
msgstr "次に「main」の中に :term:`Configurator` オブジェクトを作成します："

#: ../../tutorials/wiki2/basiclayout.rst:54
msgid ""
"``settings`` is passed to the ``Configurator`` as a keyword argument with"
" the dictionary values passed as the ``**settings`` argument. This will "
"be a dictionary of settings parsed from the ``.ini`` file, which contains"
" deployment-related values, such as ``pyramid.reload_templates``, "
"``sqlalchemy.url``, and so on."
msgstr ""
"「settings」は 「Configurator」にキーワード引数として渡され、"
"辞書の値は 「** settings」引数として渡されます。これは 「.ini」ファイルで設定した"
"辞書型の値で、 「pyramid.reload_templates」、 「sqlalchemy.url」などの"
"デプロイメント関連の値を含んでいます。"

#: ../../tutorials/wiki2/basiclayout.rst:60
msgid ""
"Next include :term:`Jinja2` templating bindings so that we can use "
"renderers with the ``.jinja2`` extension within our project."
msgstr ""
"次に、プロジェクト内で「.jinja2」拡張子を持つレンダラーを使用できるように、"
":term:`Jinja2` テンプレートバインディングをインクルードします。"

#: ../../tutorials/wiki2/basiclayout.rst:68
msgid ""
"Next include the the package ``models`` using a dotted Python path. The "
"exact setup of the models will be covered later."
msgstr ""
"次にドットのPythonパスを使って 「models」パッケージをインクルードします。"
"モデルの正確な設定については後で説明します。"

#: ../../tutorials/wiki2/basiclayout.rst:76
msgid ""
"Next include the ``routes`` module using a dotted Python path. This "
"module will be explained in the next section."
msgstr ""
"次にドットのPythonパスを使って「routes」モジュールをインクルードします。"
"このモジュールについては、次のセクションで説明します。"

#: ../../tutorials/wiki2/basiclayout.rst:86
msgid ""
"Pyramid's :meth:`pyramid.config.Configurator.include` method is the "
"primary mechanism for extending the configurator and breaking your code "
"into feature-focused modules."
msgstr ""
"Pyramidの :meth:`pyramid.config.Configurator.include` メソッドは、"
"コンフィグレータを拡張して、コードを機能に焦点を当てたモジュールに分割するための主なメカニズムです。"

#: ../../tutorials/wiki2/basiclayout.rst:90
msgid ""
"``main`` next calls the ``scan`` method of the configurator "
"(:meth:`pyramid.config.Configurator.scan`), which will recursively scan "
"our ``tutorial`` package, looking for ``@view_config`` and other special "
"decorators. When it finds a ``@view_config`` decorator, a view "
"configuration will be registered, allowing one of our application URLs to"
" be mapped to some code."
msgstr ""
"「main」はコンフィギュレータ（ :meth:`pyramid.config.Configurator.scan` ）の"
"「scan」メソッドを呼び出します。このメソッドは「tutorial」パッケージを再帰的にスキャンして、"
"「@view_config」と他の特別なデコレータを探します。 「@ view_config」デコレータが見つかると、"
"ビューの設定が登録され、アプリケーションのURLの1つがいくつかのコードにマッピングされます。"

#: ../../tutorials/wiki2/basiclayout.rst:102
msgid ""
"Finally ``main`` is finished configuring things, so it uses the "
":meth:`pyramid.config.Configurator.make_wsgi_app` method to return a "
":term:`WSGI` application:"
msgstr ""
"最後に「main」が物事を設定し終わったので、 "
":meth:`pyramid.config.Configurator.make_wsgi_app` メソッドを使って "
":term:`WSGI` アプリケーションを返します："

#: ../../tutorials/wiki2/basiclayout.rst:113
msgid "Route declarations"
msgstr "ルート宣言(Route declarations)"

#: ../../tutorials/wiki2/basiclayout.rst:115
msgid ""
"Open the ``tutorial/routes.py`` file. It should already contain the "
"following:"
msgstr "「tutorial/routes.py」ファイルを開いてみてると、以下がすでに記載されているはずです："

#: ../../tutorials/wiki2/basiclayout.rst:121
msgid ""
"On line 2, we call :meth:`pyramid.config.Configurator.add_static_view` "
"with three arguments: ``static`` (the name), ``static`` (the path), and "
"``cache_max_age`` (a keyword argument)."
msgstr ""
"2行目では、 「static」（名前）、 「static」（パス）、 「cache_max_age」（a）"
"の3つの引数を持つ :meth:`pyramid.config.Configurator.add_static_view` を呼び出します。キーワード引数）。"

#: ../../tutorials/wiki2/basiclayout.rst:125
msgid ""
"This registers a static resource view which will match any URL that "
"starts with the prefix ``/static`` (by virtue of the first argument to "
"``add_static_view``). This will serve up static resources for us from "
"within the ``static`` directory of our ``tutorial`` package, in this case"
" via ``http://localhost:6543/static/`` and below (by virtue of the second"
" argument to ``add_static_view``).  With this declaration, we're saying "
"that any URL that starts with ``/static`` should go to the static view; "
"any remainder of its path (e.g., the ``/foo`` in ``/static/foo``) will be"
" used to compose a path to a static file resource, such as a CSS file."
msgstr ""
"これは静的リソースビューを登録します。これは「/static」いう接頭辞で始まるURL"
"にマッチします（ 「add_static_view」の最初の引数によって）。これは「tutorial」パッケージの"
"「static」ディレクトリから静的リソースを提供します。"
"この場合、 「 http://localhost:6543/static/ 」以下で「add_static_view」の2番目の引数）。"
"この宣言では、 「/static」で始まるURLはすべて静的ビューに移動する必要があります。"
" CSSファイルのような静的なファイルリソースへのパスを構成するために、パスの残りの部分"
"（ 「/foo」、 「/static/foo」など）が使われます。"

#: ../../tutorials/wiki2/basiclayout.rst:135
msgid ""
"On line 3, the module registers a :term:`route configuration` via the "
":meth:`pyramid.config.Configurator.add_route` method that will be used "
"when the URL is ``/``. Since this route has a ``pattern`` equaling ``/``,"
" it is the route that will be matched when the URL ``/`` is visited, "
"e.g., ``http://localhost:6543/``."
msgstr ""
"3行目では、:term:`route configuration` メソッドを使って "
":meth:`pyramid.config.Configurator.add_route` を登録します。"
"このメソッドは、URLが 「/」のときに使用されます。"
"このルートは 「/」と同じ「パターン」を持っているので、URL「/」が訪れたときにマッチす"
"るルートです。例えば 「 http://localhost:6543/ 」。"

#: ../../tutorials/wiki2/basiclayout.rst:143
msgid "View declarations via the ``views`` package"
msgstr "「views」パッケージを使って宣言を表示する( View declarations via the ``views`` package )"

#: ../../tutorials/wiki2/basiclayout.rst:145
msgid ""
"The main function of a web framework is mapping each URL pattern to code "
"(a :term:`view callable`) that is executed when the requested URL matches"
" the corresponding :term:`route`. Our application uses the "
":meth:`pyramid.view.view_config` decorator to perform this mapping."
msgstr ""
"Webフレームワークの主な機能は、リクエストされたURLが対応する :term:`route` "
"と一致するときに実行されるコード（ :term:`view callable` ）への各URLパターン"
"のマッピングです。アプリケーションは :meth:`pyramid.view.view_config` デコ"
"レータを使ってこのマッピングを行います。"

#: ../../tutorials/wiki2/basiclayout.rst:150
msgid ""
"Open ``tutorial/views/default.py`` in the ``views`` package.  It should "
"already contain the following:"
msgstr ""
"「views」パッケージの「tutorial/views/default.py」を開きます。"
"それはすでに以下が含まれています："

#: ../../tutorials/wiki2/basiclayout.rst:157
msgid ""
"The important part here is that the ``@view_config`` decorator associates"
" the function it decorates (``my_view``) with a :term:`view "
"configuration`, consisting of:"
msgstr ""
"ここで重要な部分は、 「@view_config」デコレータが、装飾する関数（「my_view」）"
"を :term:`view configuration` と関連付けることです。"


#: ../../tutorials/wiki2/basiclayout.rst:161
msgid "a ``route_name`` (``home``)"
msgstr "``route_name`` (``home``)"

#: ../../tutorials/wiki2/basiclayout.rst:162
msgid ""
"a ``renderer``, which is a template from the ``templates`` subdirectory "
"of the package."
msgstr "「renderer」はパッケージの 「templates」サブディレクトリからのテンプレートです。"

#: ../../tutorials/wiki2/basiclayout.rst:165
msgid ""
"When the pattern associated with the ``home`` view is matched during a "
"request, ``my_view()`` will be executed.  ``my_view()`` returns a "
"dictionary; the renderer will use the ``templates/mytemplate.jinja2`` "
"template to create a response based on the values in the dictionary."
msgstr ""
"「home」ビューに関連付けられたパターンがリクエスト中にマッチすると、 "
"「my_view()」が実行されます。 「my_view()」は辞書を返却します。"
"レンダラは 「templates/mytemplate.jinja2」テンプレートを使用し"
"て辞書の値に基づいてレスポンスを作成します。"

#: ../../tutorials/wiki2/basiclayout.rst:170
msgid ""
"Note that ``my_view()`` accepts a single argument named ``request``.  "
"This is the standard call signature for a Pyramid :term:`view callable`."
msgstr ""
"「my_view()」は 「request」とい引数のみを受け付けます。"
"これは、Pyramid :term:`view callable` の標準コールシグネチャです。"

#: ../../tutorials/wiki2/basiclayout.rst:173
msgid ""
"Remember in our ``__init__.py`` when we executed the "
":meth:`pyramid.config.Configurator.scan` method ``config.scan()``? The "
"purpose of calling the scan method was to find and process this "
"``@view_config`` decorator in order to create a view configuration within"
" our application. Without being processed by ``scan``, the decorator "
"effectively does nothing. ``@view_config`` is inert without being "
"detected via a :term:`scan`."
msgstr ""
":meth:`pyramid.config.Configurator.scan` メソッドの「config.scan（）」"
"を実行したときの私たちの「__init __.py」を覚えていますか？ scanメソッド"
"を呼び出す目的は、 「@view_config」デコレータを見つけて処理して、"
"アプリケーション内でビュー設定を作成することでした。 "
"「scan」で処理されないとデコレータは事実上何もしません。"
" 「@view_config」は :term:`scan` で検出されることなく不活性です。"

#: ../../tutorials/wiki2/basiclayout.rst:180
msgid ""
"The sample ``my_view()`` created by the cookiecutter uses a ``try:`` and "
"``except:`` clause to detect if there is a problem accessing the project "
"database and provide an alternate error response.  That response will "
"include the text shown at the end of the file, which will be displayed in"
" the browser to inform the user about possible actions to take to solve "
"the problem."
msgstr ""
"cookiecutterが作成したサンプルの「my_view（）」は 「try：」と 「except：」節で"
"、プロジェクトのデータベースへのアクセスに問題があるかどうかを検出して、"
"エラーレスポンスを提供します。レスポンスには、ファイルの最後に表示される"
"テキストが含まれます。このテキストはブラウザに表示され,問題を解決するた"
"めに取るべき可能なアクションについてユーザーに通知します。"

#: ../../tutorials/wiki2/basiclayout.rst:188
msgid "Content models with the ``models`` package"
msgstr "「models」パッケージによるコンテンツモデル(Content models with the ``models`` package)"

#: ../../tutorials/wiki2/basiclayout.rst:190
msgid ""
"In an SQLAlchemy-based application, a *model* object is an object "
"composed by querying the SQL database. The ``models`` package is where "
"the ``alchemy`` cookiecutter put the classes that implement our models."
msgstr ""
"SQLAlchemyベースのアプリケーションでは、 *model* オブジェクトは、SQLデータベース"
"を照会して作成されたオブジェクトです。 「model」パッケージは、 「alchemy] cookiecutter"
"がモデルを実装するクラスを置く場所です。"

#: ../../tutorials/wiki2/basiclayout.rst:194
msgid ""
"First, open ``tutorial/models/meta.py``, which should already contain the"
" following:"
msgstr "最初に「tutorial/models/meta.py」を開きます。これには以下がすでに含まれています："

#: ../../tutorials/wiki2/basiclayout.rst:201
msgid ""
"``meta.py`` contains imports and support code for defining the models. We"
" create a dictionary ``NAMING_CONVENTION`` as well for consistent naming "
"of support objects like indices and constraints."
msgstr ""
"「meta.py」には、モデルを定義するためのインポートとサポートコードが含まれています。"
"インデックスや制約のようなサポートオブジェクトの一貫した命名のために、ディクト型の「NAMING_CONVENTION」を作成します。"

#: ../../tutorials/wiki2/basiclayout.rst:210
msgid ""
"Next we create a ``metadata`` object from the class "
":class:`sqlalchemy.schema.MetaData`, using ``NAMING_CONVENTION`` as the "
"value for the ``naming_convention`` argument."
msgstr ""
"次に、:class:`sqlalchemy.schema.MetaData` クラスの引数「naming_convention」の"
"値を「NAMING_CONVENTION」として「metadata」オブジェクトを作成します。"

#: ../../tutorials/wiki2/basiclayout.rst:214
msgid ""
"A ``MetaData`` object represents the table and other schema definitions "
"for a single database. We also need to create a declarative ``Base`` "
"object to use as a base class for our models. Our models will inherit "
"from this ``Base``, which will attach the tables to the ``metadata`` we "
"created, and define our application's database schema."
msgstr ""
"「MetaData」オブジェクトは、単一のデータベースのためのテーブルと他のスキーマ定義を表します。"
"また、モデルの基底クラスとして使用する宣言型の 「Base」オブジェクトを作成する必要が"
"あります。モデルは、この「Base」から継承します。これは作成した「metadata」にテーブルを添付し"
"て、アプリケーションのデータベーススキーマを定義します。"

#: ../../tutorials/wiki2/basiclayout.rst:225
msgid ""
"Next open ``tutorial/models/mymodel.py``, which should already contain "
"the following:"
msgstr "次に「tutorial/models/mymodel.py」を開きます。これにはすでに以下が含まれています："

#: ../../tutorials/wiki2/basiclayout.rst:232
msgid ""
"Notice we've defined the ``models`` as a package to make it "
"straightforward for defining models in separate modules. To give a simple"
" example of a model class, we have defined one named ``MyModel`` in "
"``mymodel.py``:"
msgstr ""
"別々のモジュールでモデルを定義するのが簡単であるように、 「models」をパ"
"ッケージとして定義しました。モデルクラスの簡単な例のために、 「mymodel.py」"
"に 「MyModel」クラスを定義しました："

#: ../../tutorials/wiki2/basiclayout.rst:241
msgid ""
"Our example model does not require an ``__init__`` method because "
"SQLAlchemy supplies for us a default constructor, if one is not already "
"present, which accepts keyword arguments of the same name as that of the "
"mapped attributes."
msgstr ""
"サンプルモデルは「__init__」メソッドを必要としません。"
"理由はSQLAlchemyはデフォルトのコンストラクタが存在しない場合、"
"それがマッピングされた属性と同じ名前のキーワード引数を受け入れます。"

#: ../../tutorials/wiki2/basiclayout.rst:245
msgid "Example usage of MyModel:"
msgstr "MyModelの使用例 (Example usage of MyModel)："

#: ../../tutorials/wiki2/basiclayout.rst:251
msgid ""
"The ``MyModel`` class has a ``__tablename__`` attribute.  This informs "
"SQLAlchemy which table to use to store the data representing instances of"
" this class."
msgstr ""
"「MyModel」クラスは 「__tablename__」アトリビュートを持っています。"
"これはSQLAlchemyに、このクラスのインスタンスを表すデータの格納に使用するテーブルを通知します。"

#: ../../tutorials/wiki2/basiclayout.rst:255
msgid ""
"Finally, open ``tutorial/models/__init__.py``, which should already "
"contain the following:"
msgstr "最後に、「tutorial/models/__init__.py」を開きます。これにはすでに以下が含まれています："

#: ../../tutorials/wiki2/basiclayout.rst:262
msgid ""
"Our ``models/__init__.py`` module defines the primary API we will use for"
" configuring the database connections within our application, and it "
"contains several functions we will cover below."
msgstr ""
"「models/__init__.py」モジュールは、アプリケーション内のデータベース接続の設定"
"に使うプライマリAPIを定義しています。また以下で説明するいくつかの機能が含まれています。"

#: ../../tutorials/wiki2/basiclayout.rst:266
msgid ""
"As we mentioned above, the purpose of the ``models.meta.metadata`` object"
" is to describe the schema of the database. This is done by defining "
"models that inherit from the ``Base`` object attached to that "
"``metadata`` object. In Python, code is only executed if it is imported, "
"and so to attach the ``models`` table defined in ``mymodel.py`` to the "
"``metadata``, we must import it. If we skip this step, then later, when "
"we run :meth:`sqlalchemy.schema.MetaData.create_all`, the table will not "
"be created because the ``metadata`` object does not know about it!"
msgstr ""
"前述のように、 「models.meta.metadata」オブジェクトの目的は、データベースのス"
"キーマを記述することです。これは「metadata」オブジェクトに付随する「Base」オブ"
"ジェクトから継承するモデルを定義することによって行われます。"
" Pythonではコードがインポートされた場合のみコードが実行され、 "
"`` 「mymodel.py」で定義された「models」テーブルを「metadata」に添付するには、"
"インポートする必要があります。このステップをスキップすると、後で "
":meth:`sqlalchemy.schema.MetaData.create_all` を実行すると、「metadata」"
"オブジェクトは「models」テーブルについて知りませんのでテーブルは作成されません！"

#: ../../tutorials/wiki2/basiclayout.rst:275
msgid ""
"Another important reason to import all of the models is that, when "
"defining relationships between models, they must all exist in order for "
"SQLAlchemy to find and build those internal mappings. This is why, after "
"importing all the models, we explicitly execute the function "
":func:`sqlalchemy.orm.configure_mappers`, once we are sure all the models"
" have been defined and before we start creating connections."
msgstr ""
"すべてのモデルをインポートするもう1つの重要な理由はモデル間の関係を"
"定義するときに、SQLAlchemyがそれらの内部マッピングを見つけて構築す"
"るためには存在する必要があるためです。"
"すべてのモデルをインポートした後にすべてのモデルが定義されていること"
"を確認して接続を作成する前に、関数 :func:`sqlalchemy.orm.configure_mappers` "
"を明示的に実行するのはこのためです。"

#: ../../tutorials/wiki2/basiclayout.rst:282
msgid ""
"Next we define several functions for connecting to our database. The "
"first and lowest level is the ``get_engine`` function. This creates an "
":term:`SQLAlchemy` database engine using "
":func:`sqlalchemy.engine_from_config` from the ``sqlalchemy.``-prefixed "
"settings in the ``development.ini`` file's ``[app:main]`` section. This "
"setting is a URI (something like ``sqlite://``)."
msgstr ""
"次にデータベースに接続するための関数をいくつか定義します。"
"最初のレベルと最低レベルは 「get_engine」関数です。””これは「development.ini」"
"ファイルの [app：main] セクションのの 「sqlalchemy」接頭辞の設定から "
":func:`sqlalchemy.engine_from_config`  を使用して、 "
":term:`SQLAlchemy` データベースエンジンを生成します。"
"この設定はURIです（ 「sqlite://」と似ています）。"

#: ../../tutorials/wiki2/basiclayout.rst:293
msgid ""
"The function ``get_session_factory`` accepts an :term:`SQLAlchemy` "
"database engine, and creates a ``session_factory`` from the "
":term:`SQLAlchemy` class :class:`sqlalchemy.orm.session.sessionmaker`. "
"This ``session_factory`` is then used for creating sessions bound to the "
"database engine."
msgstr ""
"「get_session_factory」関数は :term:`SQLAlchemy` データベースエンジンを"
"受け取り、 :term:`SQLAlchemy` の class :class:`sqlalchemy.orm.session.sessionmaker` "
"クラスから「session_factory」を生成します。"
"この「session_factory」は、データベースエンジンにバインドされたセッションの作成に使用されます。"

#: ../../tutorials/wiki2/basiclayout.rst:303
msgid ""
"The function ``get_tm_session`` registers a database session with a "
"transaction manager, and returns a ``dbsession`` object. With the "
"transaction manager, our application will automatically issue a "
"transaction commit after every request, unless an exception is raised, in"
" which case the transaction will be aborted."
msgstr ""
"「get_tm_session」関数はデータベースセッションをトランザクションマネージャに登録して、"
"「dbsession」　オブジェクトを返します。トランザクションマネージャを使用すると、"
"例外が発生しない限りはアプリケーションはすべてのリクエストの後に自動的にト"
"ランザクションコミットを発行します。例外が発生した場合はトランザクションは中止されます。"

#: ../../tutorials/wiki2/basiclayout.rst:313
msgid ""
"Finally, we define an ``includeme`` function, which is a hook for use "
"with :meth:`pyramid.config.Configurator.include` to activate code in a "
"Pyramid application add-on. It is the code that is executed above when we"
" ran ``config.include('.models')`` in our application's ``main`` "
"function. This function will take the settings from the application, "
"create an engine, and define a ``request.dbsession`` property, which we "
"can use to do work on behalf of an incoming request to our application."
msgstr ""
"最後に、「includeme」関数を定義します。これは :meth:`pyramid.config.Configurator.include` "
"でPyramidアプリケーションアドオンでコードをアクティブにするためのフックです。"
"これは、アプリケーションの「main」関数で 「config.include（.models）」を実行"
"したときに実行されるコードです。"
"この関数はアプリケーションからの設定を受け取り、エンジンを作成してアプリケーションへの"
"リクエスト応答処理に代わって作業を行うために使用できる「request.dbsession」プロパティを定義します。"

#: ../../tutorials/wiki2/basiclayout.rst:326
msgid ""
"That's about all there is to it regarding models, views, and "
"initialization code in our stock application."
msgstr "これは、ストックアプリケーションのモデル、ビュー、および初期化コードに関して、ここにあるすべてです。"

#: ../../tutorials/wiki2/basiclayout.rst:329
msgid ""
"The ``Index`` import and the ``Index`` object creation in ``mymodel.py`` "
"is not required for this tutorial, and will be removed in the next step."
msgstr "このチュートリアルでは、 「Index」インポートと「Index」オブジェクトの作成は「mymodel.py」では必須ではなく、次のステップで削除されます。"


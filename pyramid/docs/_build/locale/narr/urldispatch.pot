# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008-2018, Agendaless Consulting
# This file is distributed under the same license as the The Pyramid Web Framework package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Pyramid Web Framework 1.9.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-28 18:07+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../narr/urldispatch.rst:7
msgid "URL Dispatch"
msgstr ""

#: ../../narr/urldispatch.rst:9
msgid ":term:`URL dispatch` provides a simple way to map URLs to :term:`view` code using a simple pattern matching language.  An ordered set of patterns is checked one by one.  If one of the patterns matches the path information associated with a request, a particular :term:`view callable` is invoked.  A view callable is a specific bit of code, defined in your application, that receives the :term:`request` and returns a :term:`response` object."
msgstr ""

#: ../../narr/urldispatch.rst:17
msgid "High-Level Operational Overview"
msgstr ""

#: ../../narr/urldispatch.rst:19
msgid "If any route configuration is present in an application, the :app:`Pyramid` :term:`Router` checks every incoming request against an ordered set of URL matching patterns present in a *route map*."
msgstr ""

#: ../../narr/urldispatch.rst:23
msgid "If any route pattern matches the information in the :term:`request`, :app:`Pyramid` will invoke the :term:`view lookup` process to find a matching view."
msgstr ""

#: ../../narr/urldispatch.rst:27
msgid "If no route pattern in the route map matches the information in the :term:`request` provided in your application, :app:`Pyramid` will fail over to using :term:`traversal` to perform resource location and view lookup."
msgstr ""

#: ../../narr/urldispatch.rst:35
msgid "Route Configuration"
msgstr ""

#: ../../narr/urldispatch.rst:37
msgid ":term:`Route configuration` is the act of adding a new :term:`route` to an application.  A route has a *name*, which acts as an identifier to be used for URL generation.  The name also allows developers to associate a view configuration with the route.  A route also has a *pattern*, meant to match against the ``PATH_INFO`` portion of a URL (the portion following the scheme and port, e.g., ``/foo/bar`` in the URL ``http://localhost:8080/foo/bar``). It also optionally has a ``factory`` and a set of :term:`route predicate` attributes."
msgstr ""

#: ../../narr/urldispatch.rst:52
msgid "Configuring a Route to Match a View"
msgstr ""

#: ../../narr/urldispatch.rst:54
msgid "The :meth:`pyramid.config.Configurator.add_route` method adds a single :term:`route configuration` to the :term:`application registry`.  Here's an example:"
msgstr ""

#: ../../narr/urldispatch.rst:67
msgid "When a :term:`view callable` added to the configuration by way of :meth:`~pyramid.config.Configurator.add_view` becomes associated with a route via its ``route_name`` predicate, that view callable will always be found and invoked when the associated route pattern matches during a request."
msgstr ""

#: ../../narr/urldispatch.rst:72
msgid "More commonly, you will not use any ``add_view`` statements in your project's \"setup\" code. You will instead use ``add_route`` statements, and use a :term:`scan` to associate view callables with routes.  For example, if this is a portion of your project's ``__init__.py``:"
msgstr ""

#: ../../narr/urldispatch.rst:82
msgid "Note that we don't call :meth:`~pyramid.config.Configurator.add_view` in this setup code.  However, the above :term:`scan` execution ``config.scan('mypackage')`` will pick up each :term:`configuration decoration`, including any objects decorated with the :class:`pyramid.view.view_config` decorator in the ``mypackage`` Python package.  For example, if you have a ``views.py`` in your package, a scan will pick up any of its configuration decorators, so we can add one there that references ``myroute`` as a ``route_name`` parameter:"
msgstr ""

#: ../../narr/urldispatch.rst:100
msgid "The above combination of ``add_route`` and ``scan`` is completely equivalent to using the previous combination of ``add_route`` and ``add_view``."
msgstr ""

#: ../../narr/urldispatch.rst:110
msgid "Route Pattern Syntax"
msgstr ""

#: ../../narr/urldispatch.rst:112
msgid "The syntax of the pattern matching language used by :app:`Pyramid` URL dispatch in the *pattern* argument is straightforward.  It is close to that of the :term:`Routes` system used by :term:`Pylons`."
msgstr ""

#: ../../narr/urldispatch.rst:116
msgid "The *pattern* used in route configuration may start with a slash character.  If the pattern does not start with a slash character, an implicit slash will be prepended to it at matching time.  For example, the following patterns are equivalent:"
msgstr ""

#: ../../narr/urldispatch.rst:125
msgid "and:"
msgstr ""

#: ../../narr/urldispatch.rst:131
msgid "If a pattern is a valid URL it won't be matched against an incoming request. Instead it can be useful for generating external URLs. See :ref:`External routes <external_route_narr>` for details."
msgstr ""

#: ../../narr/urldispatch.rst:135
msgid "A pattern segment (an individual item between ``/`` characters in the pattern) may either be a literal string (e.g., ``foo``) *or* it may be a replacement marker (e.g., ``{foo}``), or a certain combination of both. A replacement marker does not need to be preceded by a ``/`` character."
msgstr ""

#: ../../narr/urldispatch.rst:140
msgid "A replacement marker is in the format ``{name}``, where this means \"accept any characters up to the next slash character and use this as the ``name`` :term:`matchdict` value.\""
msgstr ""

#: ../../narr/urldispatch.rst:144
msgid "A replacement marker in a pattern must begin with an uppercase or lowercase ASCII letter or an underscore, and can be composed only of uppercase or lowercase ASCII letters, underscores, and numbers.  For example: ``a``, ``a_b``, ``_b``, and ``b9`` are all valid replacement marker names, but ``0a`` is not."
msgstr ""

#: ../../narr/urldispatch.rst:150
msgid "A replacement marker could not start with an underscore until Pyramid 1.2. Previous versions required that the replacement marker start with an uppercase or lowercase letter."
msgstr ""

#: ../../narr/urldispatch.rst:155
msgid "A matchdict is the dictionary representing the dynamic parts extracted from a URL based on the routing pattern.  It is available as ``request.matchdict``. For example, the following pattern defines one literal segment (``foo``) and two replacement markers (``baz``, and ``bar``):"
msgstr ""

#: ../../narr/urldispatch.rst:164
#: ../../narr/urldispatch.rst:301
#: ../../narr/urldispatch.rst:340
msgid "The above pattern will match these URLs, generating the following matchdicts:"
msgstr ""

#: ../../narr/urldispatch.rst:171
msgid "It will not match the following patterns however:"
msgstr ""

#: ../../narr/urldispatch.rst:178
msgid "The match for a segment replacement marker in a segment will be done only up to the first non-alphanumeric character in the segment in the pattern.  So, for instance, if this route pattern was used:"
msgstr ""

#: ../../narr/urldispatch.rst:186
msgid "The literal path ``/foo/biz.html`` will match the above route pattern, and the match result will be ``{'name':u'biz'}``.  However, the literal path ``/foo/biz`` will not match, because it does not contain a literal ``.html`` at the end of the segment represented by ``{name}.html`` (it only contains ``biz``, not ``biz.html``)."
msgstr ""

#: ../../narr/urldispatch.rst:192
msgid "To capture both segments, two replacement markers can be used:"
msgstr ""

#: ../../narr/urldispatch.rst:198
msgid "The literal path ``/foo/biz.html`` will match the above route pattern, and the match result will be ``{'name': 'biz', 'ext': 'html'}``. This occurs because there is a literal part of ``.`` (period) between the two replacement markers ``{name}`` and ``{ext}``."
msgstr ""

#: ../../narr/urldispatch.rst:203
msgid "Replacement markers can optionally specify a regular expression which will be used to decide whether a path segment should match the marker.  To specify that a replacement marker should match only a specific set of characters as defined by a regular expression, you must use a slightly extended form of replacement marker syntax.  Within braces, the replacement marker name must be followed by a colon, then directly thereafter, the regular expression. The *default* regular expression associated with a replacement marker ``[^/]+`` matches one or more characters which are not a slash.  For example, under the hood, the replacement marker ``{foo}`` can more verbosely be spelled as ``{foo:[^/]+}``. You can change this to be an arbitrary regular expression to match an arbitrary sequence of characters, such as ``{foo:\\d+}`` to match only digits."
msgstr ""

#: ../../narr/urldispatch.rst:215
msgid "It is possible to use two replacement markers without any literal characters between them, for instance ``/{foo}{bar}``. However, this would be a nonsensical pattern without specifying a custom regular expression to restrict what each marker captures."
msgstr ""

#: ../../narr/urldispatch.rst:220
msgid "Segments must contain at least one character in order to match a segment replacement marker.  For example, for the URL ``/abc/``:"
msgstr ""

#: ../../narr/urldispatch.rst:223
msgid "``/abc/{foo}`` will not match."
msgstr ""

#: ../../narr/urldispatch.rst:225
msgid "``/{foo}/`` will match."
msgstr ""

#: ../../narr/urldispatch.rst:227
msgid "Note that values representing matched path segments will be URL-unquoted and decoded from UTF-8 into Unicode within the matchdict.  So for instance, the following pattern:"
msgstr ""

#: ../../narr/urldispatch.rst:235
msgid "When matching the following URL:"
msgstr ""

#: ../../narr/urldispatch.rst:241
msgid "The matchdict will look like so (the value is URL-decoded / UTF-8 decoded):"
msgstr ""

#: ../../narr/urldispatch.rst:247
msgid "Literal strings in the path segment should represent the *decoded* value of the ``PATH_INFO`` provided to Pyramid.  You don't want to use a URL-encoded value or a bytestring representing the literal encoded as UTF-8 in the pattern. For example, rather than this:"
msgstr ""

#: ../../narr/urldispatch.rst:256
msgid "You'll want to use something like this:"
msgstr ""

#: ../../narr/urldispatch.rst:262
msgid "For patterns that contain \"high-order\" characters in its literals, you'll want to use a Unicode value as the pattern as opposed to any URL-encoded or UTF-8-encoded value.  For example, you might be tempted to use a bytestring pattern like this:"
msgstr ""

#: ../../narr/urldispatch.rst:271
msgid "But this will either cause an error at startup time or it won't match properly. You'll want to use a Unicode value as the pattern instead rather than raw bytestring escapes.  You can use a high-order Unicode value as the pattern by using `Python source file encoding <https://www.python.org/dev/peps/pep-0263/>`_ plus the \"real\" character in the Unicode pattern in the source, like so:"
msgstr ""

#: ../../narr/urldispatch.rst:282
msgid "Or you can ignore source file encoding and use equivalent Unicode escape characters in the pattern."
msgstr ""

#: ../../narr/urldispatch.rst:289
msgid "Dynamic segment names cannot contain high-order characters, so this applies only to literals in the pattern."
msgstr ""

#: ../../narr/urldispatch.rst:292
msgid "If the pattern has a ``*`` in it, the name which follows it is considered a \"remainder match\".  A remainder match *must* come at the end of the pattern. Unlike segment replacement markers, it does not need to be preceded by a slash. For example:"
msgstr ""

#: ../../narr/urldispatch.rst:311
msgid "Note that when a ``*stararg`` remainder match is matched, the value put into the matchdict is turned into a tuple of path segments representing the remainder of the path.  These path segments are URL-unquoted and decoded from UTF-8 into Unicode.  For example, for the following pattern:"
msgstr ""

#: ../../narr/urldispatch.rst:320
msgid "When matching the following path:"
msgstr ""

#: ../../narr/urldispatch.rst:326
msgid "Will generate the following matchdict:"
msgstr ""

#: ../../narr/urldispatch.rst:332
msgid "By default, the ``*stararg`` will parse the remainder sections into a tuple split by segment. Changing the regular expression used to match a marker can also capture the remainder of the URL, for example:"
msgstr ""

#: ../../narr/urldispatch.rst:347
msgid "This occurs because the default regular expression for a marker is ``[^/]+`` which will match everything up to the first ``/``, while ``{fizzle:.*}`` will result in a regular expression match of ``.*`` capturing the remainder into a single value."
msgstr ""

#: ../../narr/urldispatch.rst:356
msgid "Route Declaration Ordering"
msgstr ""

#: ../../narr/urldispatch.rst:358
msgid "Route configuration declarations are evaluated in a specific order when a request enters the system. As a result, the order of route configuration declarations is very important.  The order in which route declarations are evaluated is the order in which they are added to the application at startup time.  (This is unlike a different way of mapping URLs to code that :app:`Pyramid` provides, named :term:`traversal`, which does not depend on pattern ordering)."
msgstr ""

#: ../../narr/urldispatch.rst:366
msgid "For routes added via the :mod:`~pyramid.config.Configurator.add_route` method, the order that routes are evaluated is the order in which they are added to the configuration imperatively."
msgstr ""

#: ../../narr/urldispatch.rst:370
msgid "For example, route configuration statements with the following patterns might be added in the following order:"
msgstr ""

#: ../../narr/urldispatch.rst:378
msgid "In such a configuration, the ``members/abc`` pattern would *never* be matched. This is because the match ordering will always match ``members/{def}`` first; the route configuration with ``members/abc`` will never be evaluated."
msgstr ""

#: ../../narr/urldispatch.rst:386
msgid "Route Configuration Arguments"
msgstr ""

#: ../../narr/urldispatch.rst:388
msgid "Route configuration ``add_route`` statements may specify a large number of arguments.  They are documented as part of the API documentation at :meth:`pyramid.config.Configurator.add_route`."
msgstr ""

#: ../../narr/urldispatch.rst:392
msgid "Many of these arguments are :term:`route predicate` arguments.  A route predicate argument specifies that some aspect of the request must be true for the associated route to be considered a match during the route matching process.  Examples of route predicate arguments are ``pattern``, ``xhr``, and ``request_method``."
msgstr ""

#: ../../narr/urldispatch.rst:398
msgid "Other arguments are ``name`` and ``factory``.  These arguments represent neither predicates nor view configuration information."
msgstr ""

#: ../../narr/urldispatch.rst:405
msgid "Route Matching"
msgstr ""

#: ../../narr/urldispatch.rst:407
msgid "The main purpose of route configuration is to match (or not match) the ``PATH_INFO`` present in the WSGI environment provided during a request against a URL path pattern.  ``PATH_INFO`` represents the path portion of the URL that was requested."
msgstr ""

#: ../../narr/urldispatch.rst:412
msgid "The way that :app:`Pyramid` does this is very simple.  When a request enters the system, for each route configuration declaration present in the system, :app:`Pyramid` checks the request's ``PATH_INFO`` against the pattern declared.  This checking happens in the order that the routes were declared via :meth:`pyramid.config.Configurator.add_route`."
msgstr ""

#: ../../narr/urldispatch.rst:418
msgid "When a route configuration is declared, it may contain :term:`route predicate` arguments.  All route predicates associated with a route declaration must be ``True`` for the route configuration to be used for a given request during a check.  If any predicate in the set of :term:`route predicate` arguments provided to a route configuration returns ``False`` during a check, that route is skipped and route matching continues through the ordered set of routes."
msgstr ""

#: ../../narr/urldispatch.rst:425
msgid "If any route matches, the route matching process stops and the :term:`view lookup` subsystem takes over to find the most reasonable view callable for the matched route.  Most often, there's only one view that will match (a view configured with a ``route_name`` argument matching the matched route).  To gain a better understanding of how routes and views are associated in a real application, you can use the ``pviews`` command, as documented in :ref:`displaying_matching_views`."
msgstr ""

#: ../../narr/urldispatch.rst:433
msgid "If no route matches after all route patterns are exhausted, :app:`Pyramid` falls back to :term:`traversal` to do :term:`resource location` and :term:`view lookup`."
msgstr ""

#: ../../narr/urldispatch.rst:443
msgid "The Matchdict"
msgstr ""

#: ../../narr/urldispatch.rst:445
msgid "When the URL pattern associated with a particular route configuration is matched by a request, a dictionary named ``matchdict`` is added as an attribute of the :term:`request` object.  Thus, ``request.matchdict`` will contain the values that match replacement patterns in the ``pattern`` element.  The keys in a matchdict will be strings.  The values will be Unicode objects."
msgstr ""

#: ../../narr/urldispatch.rst:453
msgid "If no route URL pattern matches, the ``matchdict`` object attached to the request will be ``None``."
msgstr ""

#: ../../narr/urldispatch.rst:462
msgid "The Matched Route"
msgstr ""

#: ../../narr/urldispatch.rst:464
msgid "When the URL pattern associated with a particular route configuration is matched by a request, an object named ``matched_route`` is added as an attribute of the :term:`request` object.  Thus, ``request.matched_route`` will be an object implementing the :class:`~pyramid.interfaces.IRoute` interface which matched the request.  The most useful attribute of the route object is ``name``, which is the name of the route that matched."
msgstr ""

#: ../../narr/urldispatch.rst:473
msgid "If no route URL pattern matches, the ``matched_route`` object attached to the request will be ``None``."
msgstr ""

#: ../../narr/urldispatch.rst:477
msgid "Routing Examples"
msgstr ""

#: ../../narr/urldispatch.rst:479
msgid "Let's check out some examples of how route configuration statements might be commonly declared, and what will happen if they are matched by the information present in a request."
msgstr ""

#: ../../narr/urldispatch.rst:486
msgid "Example 1"
msgstr ""

#: ../../narr/urldispatch.rst:488
msgid "The simplest route declaration which configures a route match to *directly* result in a particular view callable being invoked:"
msgstr ""

#: ../../narr/urldispatch.rst:497
msgid "When a route configuration with a ``view`` attribute is added to the system, and an incoming request matches the *pattern* of the route configuration, the :term:`view callable` named as the ``view`` attribute of the route configuration will be invoked."
msgstr ""

#: ../../narr/urldispatch.rst:502
msgid "Recall that the ``@view_config`` is equivalent to calling ``config.add_view``, because the ``config.scan()`` call will import ``mypackage.views``, shown below, and execute ``config.add_view`` under the hood. Each view then maps the route name to the matching view callable. In the case of the above example, when the URL of a request matches ``/site/{id}``, the view callable at the Python dotted path name ``mypackage.views.site_view`` will be called with the request.  In other words, we've associated a view callable directly with a route pattern."
msgstr ""

#: ../../narr/urldispatch.rst:511
msgid "When the ``/site/{id}`` route pattern matches during a request, the ``site_view`` view callable is invoked with that request as its sole argument. When this route matches, a ``matchdict`` will be generated and attached to the request as ``request.matchdict``.  If the specific URL matched is ``/site/1``, the ``matchdict`` will be a dictionary with a single key, ``id``; the value will be the string ``'1'``, ex.: ``{'id':'1'}``."
msgstr ""

#: ../../narr/urldispatch.rst:518
msgid "The ``mypackage.views`` module referred to above might look like so:"
msgstr ""

#: ../../narr/urldispatch.rst:530
msgid "The view has access to the matchdict directly via the request, and can access variables within it that match keys present as a result of the route pattern."
msgstr ""

#: ../../narr/urldispatch.rst:533
msgid "See :ref:`views_chapter`, and :ref:`view_config_chapter` for more information about views."
msgstr ""

#: ../../narr/urldispatch.rst:537
msgid "Example 2"
msgstr ""

#: ../../narr/urldispatch.rst:539
msgid "Below is an example of a more complicated set of route statements you might add to your application:"
msgstr ""

#: ../../narr/urldispatch.rst:550
msgid "Here is an example of a corresponding ``mypackage.views`` module:"
msgstr ""

#: ../../narr/urldispatch.rst:572
msgid "The above configuration will allow :app:`Pyramid` to service URLs in these forms:"
msgstr ""

#: ../../narr/urldispatch.rst:581
msgid "When a URL matches the pattern ``/ideas/{idea}``, the view callable available at the dotted Python pathname ``mypackage.views.idea_view`` will be called.  For the specific URL ``/ideas/1``, the ``matchdict`` generated and attached to the :term:`request` will consist of ``{'idea':'1'}``."
msgstr ""

#: ../../narr/urldispatch.rst:586
msgid "When a URL matches the pattern ``/users/{user}``, the view callable available at the dotted Python pathname ``mypackage.views.user_view`` will be called.  For the specific URL ``/users/1``, the ``matchdict`` generated and attached to the :term:`request` will consist of ``{'user':'1'}``."
msgstr ""

#: ../../narr/urldispatch.rst:591
msgid "When a URL matches the pattern ``/tags/{tag}``, the view callable available at the dotted Python pathname ``mypackage.views.tag_view`` will be called. For the specific URL ``/tags/1``, the ``matchdict`` generated and attached to the :term:`request` will consist of ``{'tag':'1'}``."
msgstr ""

#: ../../narr/urldispatch.rst:596
msgid "In this example we've again associated each of our routes with a :term:`view callable` directly.  In all cases, the request, which will have a ``matchdict`` attribute detailing the information found in the URL by the process will be passed to the view callable."
msgstr ""

#: ../../narr/urldispatch.rst:602
msgid "Example 3"
msgstr ""

#: ../../narr/urldispatch.rst:604
msgid "The :term:`context` resource object passed in to a view found as the result of URL dispatch will, by default, be an instance of the object returned by the :term:`root factory` configured at startup time (the ``root_factory`` argument to the :term:`Configurator` used to configure the application)."
msgstr ""

#: ../../narr/urldispatch.rst:609
msgid "You can override this behavior by passing in a ``factory`` argument to the :meth:`~pyramid.config.Configurator.add_route` method for a particular route. The ``factory`` should be a callable that accepts a :term:`request` and returns an instance of a class that will be the context resource used by the view."
msgstr ""

#: ../../narr/urldispatch.rst:614
msgid "An example of using a route with a factory:"
msgstr ""

#: ../../narr/urldispatch.rst:622
msgid "The above route will manufacture an ``Idea`` resource as a :term:`context`, assuming that ``mypackage.resources.Idea`` resolves to a class that accepts a request in its ``__init__``.  For example:"
msgstr ""

#: ../../narr/urldispatch.rst:633
msgid "In a more complicated application, this root factory might be a class representing a :term:`SQLAlchemy` model. The view ``mypackage.views.idea_view`` might look like this:"
msgstr ""

#: ../../narr/urldispatch.rst:645
msgid "Here, ``request.context`` is an instance of ``Idea``. If indeed the resource object is a SQLAlchemy model, you do not even have to perform a query in the view callable, since you have access to the resource via ``request.context``."
msgstr ""

#: ../../narr/urldispatch.rst:649
msgid "See :ref:`route_factories` for more details about how to use route factories."
msgstr ""

#: ../../narr/urldispatch.rst:657
msgid "Matching the Root URL"
msgstr ""

#: ../../narr/urldispatch.rst:659
msgid "It's not entirely obvious how to use a route pattern to match the root URL (\"/\").  To do so, give the empty string as a pattern in a call to :meth:`~pyramid.config.Configurator.add_route`:"
msgstr ""

#: ../../narr/urldispatch.rst:668
msgid "Or provide the literal string ``/`` as the pattern:"
msgstr ""

#: ../../narr/urldispatch.rst:682
msgid "Generating Route URLs"
msgstr ""

#: ../../narr/urldispatch.rst:684
msgid "Use the :meth:`pyramid.request.Request.route_url` method to generate URLs based on route patterns.  For example, if you've configured a route with the ``name`` \"foo\" and the ``pattern`` \"{a}/{b}/{c}\", you might do this."
msgstr ""

#: ../../narr/urldispatch.rst:693
msgid "This would return something like the string ``http://example.com/1/2/3`` (at least if the current protocol and hostname implied ``http://example.com``)."
msgstr ""

#: ../../narr/urldispatch.rst:696
msgid "To generate only the *path* portion of a URL from a route, use the :meth:`pyramid.request.Request.route_path` API instead of :meth:`~pyramid.request.Request.route_url`."
msgstr ""

#: ../../narr/urldispatch.rst:704
msgid "This will return the string ``/1/2/3`` rather than a full URL."
msgstr ""

#: ../../narr/urldispatch.rst:706
msgid "Replacement values passed to ``route_url`` or ``route_path`` must be Unicode or bytestrings encoded in UTF-8.  One exception to this rule exists: if you're trying to replace a \"remainder\" match value (a ``*stararg`` replacement value), the value may be a tuple containing Unicode strings or UTF-8 strings."
msgstr ""

#: ../../narr/urldispatch.rst:711
msgid "Note that URLs and paths generated by ``route_url`` and ``route_path`` are always URL-quoted string types (they contain no non-ASCII characters). Therefore, if you've added a route like so:"
msgstr ""

#: ../../narr/urldispatch.rst:719
msgid "And you later generate a URL using ``route_path`` or ``route_url`` like so:"
msgstr ""

#: ../../narr/urldispatch.rst:725
msgid "You will wind up with the path encoded to UTF-8 and URL-quoted like so:"
msgstr ""

#: ../../narr/urldispatch.rst:731
msgid "If you have a ``*stararg`` remainder dynamic part of your route pattern:"
msgstr ""

#: ../../narr/urldispatch.rst:737
msgid "And you later generate a URL using ``route_path`` or ``route_url`` using a *string* as the replacement value:"
msgstr ""

#: ../../narr/urldispatch.rst:744
msgid "The value you pass will be URL-quoted except for embedded slashes in the result:"
msgstr ""

#: ../../narr/urldispatch.rst:751
msgid "You can get a similar result by passing a tuple composed of path elements:"
msgstr ""

#: ../../narr/urldispatch.rst:757
msgid "Each value in the tuple will be URL-quoted and joined by slashes in this case:"
msgstr ""

#: ../../narr/urldispatch.rst:769
msgid "Static Routes"
msgstr ""

#: ../../narr/urldispatch.rst:771
msgid "Routes may be added with a ``static`` keyword argument.  For example:"
msgstr ""

#: ../../narr/urldispatch.rst:779
msgid "Routes added with a ``True`` ``static`` keyword argument will never be considered for matching at request time.  Static routes are useful for URL generation purposes only.  As a result, it is usually nonsensical to provide other non-``name`` and non-``pattern`` arguments to :meth:`~pyramid.config.Configurator.add_route` when ``static`` is passed as ``True``, as none of the other arguments will ever be employed.  A single exception to this rule is use of the ``pregenerator`` argument, which is not ignored when ``static`` is ``True``."
msgstr ""

#: ../../narr/urldispatch.rst:788
msgid ":ref:`External routes <external_route_narr>` are implicitly static."
msgstr ""

#: ../../narr/urldispatch.rst:790
msgid "the ``static`` argument to :meth:`~pyramid.config.Configurator.add_route`."
msgstr ""

#: ../../narr/urldispatch.rst:797
msgid "External Routes"
msgstr ""

#: ../../narr/urldispatch.rst:801
msgid "Route patterns that are valid URLs, are treated as external routes. Like :ref:`static routes <static_route_narr>` they are useful for URL generation purposes only and are never considered for matching at request time."
msgstr ""

#: ../../narr/urldispatch.rst:814
msgid "Most pattern replacements and calls to :meth:`pyramid.request.Request.route_url` will work as expected. However, calls to :meth:`pyramid.request.Request.route_path` against external patterns will raise an exception, and passing ``_app_url`` to :meth:`~pyramid.request.Request.route_url` to generate a URL against a route that has an external pattern will also raise an exception."
msgstr ""

#: ../../narr/urldispatch.rst:827
msgid "Redirecting to Slash-Appended Routes"
msgstr ""

#: ../../narr/urldispatch.rst:829
msgid "For behavior like Django's ``APPEND_SLASH=True``, use the ``append_slash`` argument to :meth:`pyramid.config.Configurator.add_notfound_view` or the equivalent ``append_slash`` argument to the :class:`pyramid.view.notfound_view_config` decorator."
msgstr ""

#: ../../narr/urldispatch.rst:834
msgid "Adding ``append_slash=True`` is a way to automatically redirect requests where the URL lacks a trailing slash, but requires one to match the proper route. When configured, along with at least one other route in your application, this view will be invoked if the value of ``PATH_INFO`` does not already end in a slash, and if the value of ``PATH_INFO`` *plus* a slash matches any route's pattern.  In this case it does an HTTP redirect to the slash-appended ``PATH_INFO``. In addition you may pass anything that implements :class:`pyramid.interfaces.IResponse` which will then be used in place of the default class (:class:`pyramid.httpexceptions.HTTPFound`)."
msgstr ""

#: ../../narr/urldispatch.rst:844
msgid "Let's use an example.  If the following routes are configured in your application:"
msgstr ""

#: ../../narr/urldispatch.rst:869
msgid "If a request enters the application with the ``PATH_INFO`` value of ``/no_slash``, the first route will match and the browser will show \"No slash\". However, if a request enters the application with the ``PATH_INFO`` value of ``/no_slash/``, *no* route will match, and the slash-appending not found view will not find a matching route with an appended slash.  As a result, the ``notfound`` view will be called and it will return a \"Not found\" body."
msgstr ""

#: ../../narr/urldispatch.rst:876
msgid "If a request enters the application with the ``PATH_INFO`` value of ``/has_slash/``, the second route will match.  If a request enters the application with the ``PATH_INFO`` value of ``/has_slash``, a route *will* be found by the slash-appending :term:`Not Found View`.  An HTTP redirect to ``/has_slash/`` will be returned to the user's browser.  As a result, the ``notfound`` view will never actually be called."
msgstr ""

#: ../../narr/urldispatch.rst:883
msgid "The following application uses the :class:`pyramid.view.notfound_view_config` and :class:`pyramid.view.view_config` decorators and a :term:`scan` to do exactly the same job:"
msgstr ""

#: ../../narr/urldispatch.rst:913
msgid "You **should not** rely on this mechanism to redirect ``POST`` requests. The redirect  of the slash-appending :term:`Not Found View` will turn a ``POST`` request into a ``GET``, losing any ``POST`` data in the original request."
msgstr ""

#: ../../narr/urldispatch.rst:918
msgid "See :ref:`view_module` and :ref:`changing_the_notfound_view` for a more general description of how to configure a view and/or a :term:`Not Found View`."
msgstr ""

#: ../../narr/urldispatch.rst:927
msgid "Debugging Route Matching"
msgstr ""

#: ../../narr/urldispatch.rst:929
msgid "It's useful to be able to take a peek under the hood when requests that enter your application aren't matching your routes as you expect them to.  To debug route matching, use the ``PYRAMID_DEBUG_ROUTEMATCH`` environment variable or the ``pyramid.debug_routematch`` configuration file setting (set either to ``true``). Details of the route matching decision for a particular request to the :app:`Pyramid` application will be printed to the ``stderr`` of the console which you started the application from.  For example:"
msgstr ""

#: ../../narr/urldispatch.rst:951
msgid "See :ref:`environment_chapter` for more information about how and where to set these values."
msgstr ""

#: ../../narr/urldispatch.rst:954
msgid "You can also use the ``proutes`` command to see a display of all the routes configured in your application. For more information, see :ref:`displaying_application_routes`."
msgstr ""

#: ../../narr/urldispatch.rst:961
msgid "Using a Route Prefix to Compose Applications"
msgstr ""

#: ../../narr/urldispatch.rst:965
msgid "The :meth:`pyramid.config.Configurator.include` method allows configuration statements to be included from separate files.  See :ref:`building_an_extensible_app` for information about this method.  Using :meth:`pyramid.config.Configurator.include` allows you to build your application from small and potentially reusable components."
msgstr ""

#: ../../narr/urldispatch.rst:971
msgid "The :meth:`pyramid.config.Configurator.include` method accepts an argument named ``route_prefix`` which can be useful to authors of URL-dispatch-based applications.  If ``route_prefix`` is supplied to the include method, it must be a string.  This string represents a route prefix that will be prepended to all route patterns added by the *included* configuration.  Any calls to :meth:`pyramid.config.Configurator.add_route` within the included callable will have their pattern prefixed with the value of ``route_prefix``. This can be used to help mount a set of routes at a different location than the included callable's author intended while still maintaining the same route names.  For example:"
msgstr ""

#: ../../narr/urldispatch.rst:994
msgid "In the above configuration, the ``show_users`` route will have an effective route pattern of ``/users/show`` instead of ``/show`` because the ``route_prefix`` argument will be prepended to the pattern.  The route will then only match if the URL path is ``/users/show``, and when the :meth:`pyramid.request.Request.route_url` function is called with the route name ``show_users``, it will generate a URL with that same path."
msgstr ""

#: ../../narr/urldispatch.rst:1001
msgid "Route prefixes are recursive, so if a callable executed via an include itself turns around and includes another callable, the second-level route prefix will be prepended with the first:"
msgstr ""

#: ../../narr/urldispatch.rst:1021
msgid "In the above configuration, the ``show_users`` route will still have an effective route pattern of ``/users/show``.  The ``show_times`` route, however, will have an effective pattern of ``/users/timing/times``."
msgstr ""

#: ../../narr/urldispatch.rst:1025
msgid "Route prefixes have no impact on the requirement that the set of route *names* in any given Pyramid configuration must be entirely unique.  If you compose your URL dispatch application out of many small subapplications using :meth:`pyramid.config.Configurator.include`, it's wise to use a dotted name for your route names so they'll be unlikely to conflict with other packages that may be added in the future.  For example:"
msgstr ""

#: ../../narr/urldispatch.rst:1054
msgid "Custom Route Predicates"
msgstr ""

#: ../../narr/urldispatch.rst:1056
msgid "Each of the predicate callables fed to the ``custom_predicates`` argument of :meth:`~pyramid.config.Configurator.add_route` must be a callable accepting two arguments.  The first argument passed to a custom predicate is a dictionary conventionally named ``info``.  The second argument is the current :term:`request` object."
msgstr ""

#: ../../narr/urldispatch.rst:1062
msgid "The ``info`` dictionary has a number of contained values, including ``match`` and ``route``. ``match`` is a dictionary which represents the arguments matched in the URL by the route. ``route`` is an object representing the route which was matched (see :class:`pyramid.interfaces.IRoute` for the API of such a route object)."
msgstr ""

#: ../../narr/urldispatch.rst:1068
msgid "``info['match']`` is useful when predicates need access to the route match. For example:"
msgstr ""

#: ../../narr/urldispatch.rst:1085
msgid "The above ``any_of`` function generates a predicate which ensures that the match value named ``segment_name`` is in the set of allowable values represented by ``allowed``.  We use this ``any_of`` function to generate a predicate function named ``num_one_two_or_three``, which ensures that the ``num`` segment is one of the values ``one``, ``two``, or ``three`` , and use the result as a custom predicate by feeding it inside a tuple to the ``custom_predicates`` argument to :meth:`~pyramid.config.Configurator.add_route`."
msgstr ""

#: ../../narr/urldispatch.rst:1094
msgid "A custom route predicate may also *modify* the ``match`` dictionary.  For instance, a predicate might do some type conversion of values:"
msgstr ""

#: ../../narr/urldispatch.rst:1116
msgid "Note that a conversion predicate is still a predicate, so it must return ``True`` or ``False``. A predicate that does *only* conversion, such as the one we demonstrate above, should unconditionally return ``True``."
msgstr ""

#: ../../narr/urldispatch.rst:1120
msgid "To avoid the try/except uncertainty, the route pattern can contain regular expressions specifying requirements for that marker. For instance:"
msgstr ""

#: ../../narr/urldispatch.rst:1139
msgid "Now the try/except is no longer needed because the route will not match at all unless these markers match ``\\d+`` which requires them to be valid digits for an ``int`` type conversion."
msgstr ""

#: ../../narr/urldispatch.rst:1143
msgid "The ``match`` dictionary passed within ``info`` to each predicate attached to a route will be the same dictionary.  Therefore, when registering a custom predicate which modifies the ``match`` dict, the code registering the predicate should usually arrange for the predicate to be the *last* custom predicate in the custom predicate list.  Otherwise, custom predicates which fire subsequent to the predicate which performs the ``match`` modification will receive the *modified* match dictionary."
msgstr ""

#: ../../narr/urldispatch.rst:1153
msgid "It is a poor idea to rely on ordering of custom predicates to build a conversion pipeline, where one predicate depends on the side effect of another.  For instance, it's a poor idea to register two custom predicates, one which handles conversion of a value to an int, the next which handles conversion of that integer to some custom object.  Just do all that in a single custom predicate."
msgstr ""

#: ../../narr/urldispatch.rst:1160
msgid "The ``route`` object in the ``info`` dict is an object that has two useful attributes: ``name`` and ``pattern``.  The ``name`` attribute is the route name. The ``pattern`` attribute is the route pattern.  Here's an example of using the route in a set of route predicates:"
msgstr ""

#: ../../narr/urldispatch.rst:1177
msgid "The above predicate, when added to a number of route configurations ensures that the year match argument is '2010' if and only if the route name is 'ymd', 'ym', or 'y'."
msgstr ""

#: ../../narr/urldispatch.rst:1181
msgid "You can also caption the predicates by setting the ``__text__`` attribute. This will help you with the ``pviews`` command (see :ref:`displaying_application_routes`) and the ``pyramid_debugtoolbar``."
msgstr ""

#: ../../narr/urldispatch.rst:1185
msgid "If a predicate is a class, just add ``__text__`` property in a standard manner."
msgstr ""

#: ../../narr/urldispatch.rst:1197
msgid "If a predicate is a method, you'll need to assign it after method declaration (see `PEP 232 <https://www.python.org/dev/peps/pep-0232/>`_)."
msgstr ""

#: ../../narr/urldispatch.rst:1207
msgid "If a predicate is a classmethod, using ``@classmethod`` will not work, but you can still easily do it by wrapping it in a classmethod call."
msgstr ""

#: ../../narr/urldispatch.rst:1218
msgid "The same will work with ``staticmethod``, using ``staticmethod`` instead of ``classmethod``."
msgstr ""

#: ../../narr/urldispatch.rst:1223
msgid "See also :class:`pyramid.interfaces.IRoute` for more API documentation about route objects."
msgstr ""

#: ../../narr/urldispatch.rst:1232
msgid "Route Factories"
msgstr ""

#: ../../narr/urldispatch.rst:1234
msgid "Although it is not a particularly common need in basic applications, a \"route\" configuration declaration can mention a \"factory\".  When a route matches a request, and a factory is attached to the route, the :term:`root factory` passed at startup time to the :term:`Configurator` is ignored. Instead the factory associated with the route is used to generate a :term:`root` object. This object will usually be used as the :term:`context` resource of the view callable ultimately found via :term:`view lookup`."
msgstr ""

#: ../../narr/urldispatch.rst:1249
msgid "The factory can either be a Python object or a :term:`dotted Python name` (a string) which points to such a Python object, as it is above."
msgstr ""

#: ../../narr/urldispatch.rst:1252
msgid "In this way, each route can use a different factory, making it possible to supply a different :term:`context` resource object to the view related to each particular route."
msgstr ""

#: ../../narr/urldispatch.rst:1256
msgid "A factory must be a callable which accepts a request and returns an arbitrary Python object.  For example, the below class can be used as a factory:"
msgstr ""

#: ../../narr/urldispatch.rst:1266
msgid "A route factory is actually conceptually identical to the :term:`root factory` described at :ref:`the_resource_tree`."
msgstr ""

#: ../../narr/urldispatch.rst:1269
msgid "Supplying a different resource factory for each route is useful when you're trying to use a :app:`Pyramid` :term:`authorization policy` to provide declarative, \"context sensitive\" security checks. Each resource can maintain a separate :term:`ACL`, as documented in :ref:`using_security_with_urldispatch`. It is also useful when you wish to combine URL dispatch with :term:`traversal` as documented within :ref:`hybrid_chapter`."
msgstr ""

#: ../../narr/urldispatch.rst:1282
msgid "Using :app:`Pyramid` Security with URL Dispatch"
msgstr ""

#: ../../narr/urldispatch.rst:1284
msgid ":app:`Pyramid` provides its own security framework which consults an :term:`authorization policy` before allowing any application code to be called. This framework operates in terms of an access control list, which is stored as an ``__acl__`` attribute of a resource object.  A common thing to want to do is to attach an ``__acl__`` to the resource object dynamically for declarative security purposes.  You can use the ``factory`` argument that points at a factory which attaches a custom ``__acl__`` to an object at its creation time."
msgstr ""

#: ../../narr/urldispatch.rst:1292
msgid "Such a ``factory`` might look like so:"
msgstr ""

#: ../../narr/urldispatch.rst:1304
msgid "If the route ``archives/{article}`` is matched, and the article number is ``1``, :app:`Pyramid` will generate an ``Article`` :term:`context` resource with an ACL on it that allows the ``editor`` principal the ``view`` permission. Obviously you can do more generic things than inspect the route's match dict to see if the ``article`` argument matches a particular string. Our sample ``Article`` factory class is not very ambitious."
msgstr ""

#: ../../narr/urldispatch.rst:1313
msgid "See :ref:`security_chapter` for more information about :app:`Pyramid` security and ACLs."
msgstr ""

#: ../../narr/urldispatch.rst:1320
msgid "Route View Callable Registration and Lookup Details"
msgstr ""

#: ../../narr/urldispatch.rst:1322
msgid "When a request enters the system which matches the pattern of the route, the usual result is simple: the view callable associated with the route is invoked with the request that caused the invocation."
msgstr ""

#: ../../narr/urldispatch.rst:1326
msgid "For most usage, you needn't understand more than this. How it works is an implementation detail.  In the interest of completeness, however, we'll explain how it *does* work in this section.  You can skip it if you're uninterested."
msgstr ""

#: ../../narr/urldispatch.rst:1330
msgid "When a view is associated with a route configuration, :app:`Pyramid` ensures that a :term:`view configuration` is registered that will always be found when the route pattern is matched during a request.  To do so:"
msgstr ""

#: ../../narr/urldispatch.rst:1334
msgid "A special route-specific :term:`interface` is created at startup time for each route configuration declaration."
msgstr ""

#: ../../narr/urldispatch.rst:1337
msgid "When an ``add_view`` statement mentions a ``route name`` attribute, a :term:`view configuration` is registered at startup time.  This view configuration uses a route-specific interface as a :term:`request` type."
msgstr ""

#: ../../narr/urldispatch.rst:1341
msgid "At runtime, when a request causes any route to match, the :term:`request` object is decorated with the route-specific interface."
msgstr ""

#: ../../narr/urldispatch.rst:1344
msgid "The fact that the request is decorated with a route-specific interface causes the :term:`view lookup` machinery to always use the view callable registered using that interface by the route configuration to service requests that match the route pattern."
msgstr ""

#: ../../narr/urldispatch.rst:1349
msgid "As we can see from the above description, technically, URL dispatch doesn't actually map a URL pattern directly to a view callable.  Instead URL dispatch is a :term:`resource location` mechanism.  A :app:`Pyramid` :term:`resource location` subsystem (i.e., :term:`URL dispatch` or :term:`traversal`) finds a :term:`resource` object that is the :term:`context` of a :term:`request`. Once the :term:`context` is determined, a separate subsystem named :term:`view lookup` is then responsible for finding and invoking a :term:`view callable` based on information available in the context and the request.  When URL dispatch is used, the resource location and view lookup subsystems provided by :app:`Pyramid` are still being utilized, but in a way which does not require a developer to understand either of them in detail."
msgstr ""

#: ../../narr/urldispatch.rst:1361
msgid "If no route is matched using :term:`URL dispatch`, :app:`Pyramid` falls back to :term:`traversal` to handle the :term:`request`."
msgstr ""

#: ../../narr/urldispatch.rst:1365
msgid "References"
msgstr ""

#: ../../narr/urldispatch.rst:1367
msgid "A tutorial showing how :term:`URL dispatch` can be used to create a :app:`Pyramid` application exists in :ref:`bfg_sql_wiki_tutorial`."
msgstr ""


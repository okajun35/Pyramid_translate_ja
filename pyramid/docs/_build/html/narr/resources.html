
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>(機械翻訳) リソース &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="../_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="next" title="(機械翻訳) こんにちはトラバーサルワールド" href="hellotraversal.html" />
    <link rel="prev" title="(機械翻訳) ユニット、統合、機能テスト" href="testing.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="../_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="../index.html">
      		<img class="logo" src="../_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="hellotraversal.html" title="(機械翻訳) こんにちはトラバーサルワールド"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="testing.html" title="(機械翻訳) ユニット、統合、機能テスト"
             accesskey="P">前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="resources">
<span id="resources-chapter"></span><h1>(機械翻訳) リソース<a class="headerlink" href="#resources" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>A：term： <cite>resource`は、アプリケーションに関連するツリー内の&amp;quot;場所&amp;quot;を表すオブジェクトです。 Every：app： `Pyramid`アプリケーションは、少なくとも一つのリソースオブジェクトを持っています：：term：</cite> root`リソース。 rootリソースを手動で定義しなくても、デフォルトのものが作成されます。 rootリソースは：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>resource tree`のルートです。リソースツリーは、ネストされた辞書的なオブジェクトのセットで、これを使用してWebサイトの構造を表現できます。</p>
<p>：term： <cite>traversal`を使用してURLをコードにマッピングするアプリケーションでは、リソースツリー構造は各URLを：term：</cite> view callable`にマップするために非常に使用されます。 ：term： <cite>traversal`が使われるとき、：app：</cite> Pyramid`は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>context`リソースを見つけるために、ネストされた辞書構造をたどってリソースツリーを歩きます。コンテキストリソースが見つかると、要求の中のコンテキストリソースとデータを使用して：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>view callable`が検索されます。</p>
<p>term： <a href="#id1"><span class="problematic" id="id2">`</span></a>URL dispatch`を使用するアプリケーションでは、リソースツリーは間接的にのみ使用され、しばしば開発者にとっては「見えない」ものです。 URLディスパッチアプリケーションでは、リソース &amp;quot;ツリー&amp;quot;はしばしばルートリソースだけで構成されます。このルートリソースには、セキュリティ宣言が添付されていることがありますが、必須ではありません。一般に、リソースツリーは、トラバーサルを使用するアプリケーションよりもURLディスパッチを使用するアプリケーションで重要性が低くなります。</p>
<p>&amp;quot;Zope-like &amp;quot;：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションでは、リソースオブジェクトはしばしば永続的にデータを格納し、永続データの変更に関連するメソッドを提供します。この種のアプリケーションでは、リソースはWebサイトのサイト構造を表すだけでなく、アプリケーションの用語： <a href="#id3"><span class="problematic" id="id4">`</span></a>ドメインモデル &amp;#39;になります。</p>
<p>また、</p>
<ul class="simple">
<li>：meth： <cite>〜pyramid.config.Configurator.add_view`（またはa：func：</cite>〜pyramid.view.view_config`デコレータ）は、リソースクラスまたはリソースを参照します。 ：term： <cite>インタフェース</cite>。</li>
<li>A：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>root factory`はリソースを返します。</li>
<li>リソースは、ビューのterm： <cite>context</cite>：term：` view`コードに公開されます。</li>
<li>さまざまな有用な：app： <cite>Pyramid</cite> APIメソッドはリソースを引数として期待します（例：：meth：<a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.resource_url`など）。</li>
</ul>
<div class="section" id="defining-a-resource-tree">
<span id="index-0"></span><h2>リソースツリーの定義<a class="headerlink" href="#defining-a-resource-tree" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：term： <cite>traversal`が（純粋に：term：</cite> URLディスパッチ <cite>ベースのアプリケーションとは対照的に）使用されるとき、：app：</cite> Pyramid`は、リソースで構成される木をトラバースできることを期待していますツリー）。トラバーサルはルート・リソースから始まり、再帰的にツリーに下がり、各リソースの `` __getitem__``メソッドを試して、パス・セグメントを別のリソース・オブジェクトに解決します。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`はツリー内のリソースインスタンスに以下のポリシーを課します：</p>
<ul class="simple">
<li>コンテナリソース（他のリソースを含むリソース）は、ユニコード名をサブリソースに解決しようとする `` __getitem__``メソッドを提供しなければなりません。特定の名前のサブリソースがコンテナリソースに存在しない場合、コンテナリソースの `` __getitem__``メソッドは：exc： <cite>KeyError`を送出する必要があります。その名前のサブリソース*が存在する場合、コンテナの `</cite> __getitem__``はサブリソースを返すべきです。</li>
<li>他のリソースを持たないリーフリソースは、 `` __getitem__``を実装してはいけません。あるいは、 `` __getitem__``メソッドは常に：exc： <a href="#id1"><span class="problematic" id="id2">`</span></a>KeyError`を生成しなければなりません。</li>
</ul>
<p>トラバーサルがリソースインスタンスに対してどのように動作するかについては、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>traversal_chapter`を参照してください。</p>
<p>次に、 `` root``という名前の変数で表されるリソースツリーの例を示します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Resource</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">Resource</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="n">Resource</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="n">Resource</span><span class="p">({</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="n">Resource</span><span class="p">()})})})</span>
</pre></div>
</td></tr></table></div>
<p>上記で作成したリソースツリーは、 `` &amp;#39;a``という名前の単一の子を持つ辞書的なルートオブジェクトによって表されます。 `` a&amp;#39;``には `` b&amp;#39;``という名前の単一の子があり、 `` b&amp;#39;``には子を持たない `` c&amp;#39;``という名前の単一の子があります。したがって、 `` &amp;#39;c&amp;#39; <a href="#id1"><span class="problematic" id="id2">`</span></a>葉資源にアクセスすることは可能です：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">root</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
</pre></div>
</td></tr></table></div>
<p>上記の `` root``オブジェクトを：term： <cite>ルートファクトリ`から返すと、パス `</cite> / a / b / c``はリソースツリーの `` c&amp;#39;``オブジェクトをの結果：term： <cite>traversal</cite></p>
<p>この例では、ツリー内の各リソースは同じクラスです。これは要件ではありません。ツリー内のリソース要素は任意のタイプでよい。簡単にするために、ツリー内のすべてのリソースを表すために単一のクラスを使用しましたが、実際のアプリケーションでは、ツリー内のリソースは任意です。</p>
<p>上の例のツリーはトラバーサルを処理できますが、上の例のリソースインスタンスは：term： <cite>location`を認識していないので、&amp;quot;実&amp;quot;アプリケーションでのそれらのユーティリティは制限されています。組み込み：app： `Pyramid</cite> API機能を最大限に活用するには、リソースを「位置認識」する必要があります。次のセクションでは、リソースに位置を認識させる方法を詳しく説明します。</p>
</div>
<div class="section" id="location-aware-resources">
<span id="location-aware"></span><span id="index-1"></span><h2>位置認識リソース<a class="headerlink" href="#location-aware-resources" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>特定の：app： <cite>Pyramid`の場所、セキュリティ、URL生成、およびトラバーサルAPIがリソースツリー内のリソースに対して適切に動作するためには、ツリー内のすべてのリソースがterm：</cite> location`を意識していなければなりません。つまり、 `` __parent__``と `` __name__``という2つの属性を持たなければなりません。</p>
<p>ロケーション認識リソースの `` __parent__``属性は、ツリー内のリソースの親リソースインスタンスへの参照である必要があります。 `` __name__``属性は、リソースの親が `` __getitem__``を介してリソースを参照する名前でなければなりません。</p>
<p>ルートリソースの `` __parent__``は `` None``で、 `` __name__``は空の文字列でなければなりません。例えば：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyRootResource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">__parent__</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</td></tr></table></div>
<p>ルートリソースの `` __getitem__``メソッドから返されるリソースは、ルートリソースへの参照である `` __parent__``属性を持ち、 `` __name__``属性は、そのリソースを経由して到達可能な名前と一致する必要がありますrootリソースの `` __getitem__``です。ルートリソース内のコンテナリソースには、コンテナを指す `` __parent__``属性を持つリソースを返す `` __getitem__``が必要です。これらのサブオブジェクトには、名前に一致する `` __name__``属性が必要ですそれによって、コンテナから `` __getitem__``を介して取得されます。このパターンはルートからツリーを再帰的に&amp;quot;上に&amp;quot;続けます。</p>
<p>各リソースの `` __parent__``属性はルートに向かって&amp;quot;下向き&amp;quot;を指すリンクリストを形成します。これはファイルシステムディレクトリの `` ..``エントリに似ています。リソースツリー内の任意のリソースから `` __parent__``の値に従えば、 `` cd ..``ファイルシステムコマンドを実行し続けるのと同じように、最終的にはルートリソースに来るでしょう。ルートディレクトリ。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">あなたのルートリソースが `` None``や空文字列でない `` __name__``引数を持っている場合、：func： <cite>〜pyramid.request.Request.resource_url`関数によって返されたURLと： func： `〜pyramid.traversal.resource_path`と：func：</cite>〜pyramid.traversal.resource_path_tuple` APIが正しく生成されません。 `` __name__``の値は、すべてのパスと生成されたURLの前に付加されます（単一の先頭のスラッシュまたは空のタプル要素とは対照的に）。</p>
</div>
<div class="sidebar">
<p class="first sidebar-title">あなたの便宜のために</p>
<p>あなたのリソースの `` __name__``と `` __parent__``属性を手動で管理したくない場合は、mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid_traversalwrapper`というアドオンパッケージが役に立ちます。</p>
<p>このヘルパー機能を使用するには、まず：mod： <cite>pyramid_traversalwrapper`パッケージ（PyPI経由で入手可能）をインストールし、デフォルト：app：</cite> Pyramid`トラバーサではなくトラバーサルポリシーとして `` ModelGraphTraverser``を登録する必要があります。パッケージには、そうするための指示が含まれています。</p>
<p class="last">一度：app： <cite>Pyramid`がこの機能で設定されると、リソースオブジェクト&amp;quot;手で&amp;quot;で</cite> <cite>__parent__``と</cite> <cite>__name__``属性を管理する必要はなくなります。代わりに、必要に応じて、：app： `Pyramid`は、</cite> <cite>__name__``と</cite> <cite>__parent__``を動的に割り当てる</cite> <cite>LocationProxy``に各リソース（ルートリソースさえ）をラップします最後に走査されたリソースと `</cite> __getitem__``に与えられた名前に基づいています。ルートリソースは `` None``の `` __name__``属性と `` None``の `` __parent__``属性を持ちます。</p>
</div>
<p>tree-walking：app： <cite>Pyramid</cite> APIを使用するアプリケーションは、位置認識のリソースを必要とします。これらのAPIには、meth： <cite>〜pyramid.request.Request.resource_url</cite>、：func：<cite>〜pyramid.traversal.find_resource</cite>、：func： <cite>〜pyramid.traversal.find_root</cite>、：func（これらに限定されません） ：func： <cite>〜pyramid.traversal.find_interface</cite>、：func：<cite>〜pyramid.traversal.resource_path</cite>、：func： <cite>〜pyramid.traversal.resource_path_tuple</cite>、：func：<cite>〜pyramid.traversal.traverse</cite>、：func： ` 〜pyramid.traversal.virtual_root`、および（通常）：meth： <cite>〜pyramid.request.Request.has_permission`と：func：</cite>〜pyramid.security.principals_allowed_by_permission`のようになります。</p>
<p>一般的に、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`インフラストラクチャは位置認識リソースに依存するので、ツリー内の各リソースを位置認識できるようにすることをお勧めします。</p>
</div>
<div class="section" id="generating-the-url-of-a-resource">
<span id="index-2"></span><span id="id1"></span><h2>リソースのURLの生成<a class="headerlink" href="#generating-the-url-of-a-resource" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>あなたのリソースが：term： <cite>location`を意識しているなら、：meth：</cite> pyramid.request.Request.resource_url` APIを使ってリソースのURLを生成することができます。このURLは、親ツリー内のリソースの位置を使用してリソースパスを作成し、現在のアプリケーションURLをパスの先頭に付けて、スキーム、ホスト、ポート、およびパスで完全修飾URLを形成します。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.resource_url`に追加の引数を渡して、生成されたURLに影響を与えることもできます。</p>
<p>最も単純な：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.resource_url`の呼び出しは次のようになります：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">resource_url</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上の例の `` request``は、：app： <cite>Pyramid</cite>：term：` request`オブジェクトのインスタンスです。</p>
<p>上の例で `` resource``と呼ばれるリソースがルートリソースで、サーバとの接続に使用されたホストが `` example.com``だった場合、生成されるURLは `` http：// example.com / <a href="#id1"><span class="problematic" id="id2">``</span></a>しかし、リソースが `` a``という名前のルートリソースの子であった場合、生成されるURLは `` http：// example.com / a / <a href="#id3"><span class="problematic" id="id4">``</span></a>になります。</p>
<p>リソースが階層の&amp;quot;場所&amp;quot;であり、URLが意図されているので、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.resource_url`がこの単純な方法でそれらを生成するために使用されるとき、すべてのリソースURLにスラッシュが追加されますクリックして訪問する。リソースのデフォルトビューの結果としてレンダリングされるHTMLページに含める相対URLは、親に対する相対URLよりも相対的に相対的にリソースに関連しています。</p>
<p>余分な要素を渡すこともできます：meth： <cite>〜pyramid.request.Request.resource_url</cite>：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">resource_url</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上の例で `` resource``と呼ばれるリソースがルートリソースで、サーバとの接続に使用されたホストが `` example.com``だった場合、生成されるURLは `` http：// example.com / foo / bar``を実行します。特別な位置引数として、任意の数の余分な要素を：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.request.Request.resource_url`に渡すことができます。余分な要素が渡されると、リソースのURLに追加されます。要素が渡されると、最後のセグメントにスラッシュが追加されません。</p>
<p>クエリ文字列を渡すこともできます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">resource_url</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">})</span>
</pre></div>
</td></tr></table></div>
<p>上の例で `` resource``と呼ばれるリソースがルートリソースで、サーバとの接続に使用されたホストが `` example.com``だった場合、生成されるURLは `` http：// example.com/？a = 1``。</p>
<p>a：term： <cite>virtual root`がアクティブな場合、リソースの：meth：</cite>〜pyramid.request.Request.resource_url`で生成されたURLは、その物理的なツリーパスよりも &amp;quot;短く&amp;quot;なります。仮想的にリソースを根絶することについての詳細は、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>virtual_root_support`を参照してください。</p>
<p>リソースURLの生成の詳細については、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.request.Request.resource_url`のドキュメントを参照してください。</p>
<div class="section" id="overriding-resource-url-generation">
<span id="index-3"></span><span id="id2"></span><h3>リソースURL生成のオーバーライド<a class="headerlink" href="#overriding-resource-url-generation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リソースオブジェクトが `` __resource_url__``メソッドを実装している場合、このメソッドは：meth： <cite>〜pyramid.request.Request.resource_url`が呼び出され、リソースのURLを生成し、リソースに対して返されるデフォルトのURLをオーバーライドしますby：meth： `〜pyramid.request.Request.resource_url</cite>。</p>
<p>`` __resource_url__``フックには、 `` request``と `` info``という2つの引数が渡されます。 `` request``は：meth： <cite>〜pyramid.request.Request.resource_url`に渡される：term：</cite> request`オブジェクトです。 `` info``は以下のキーを持つ辞書です：</p>
<dl class="docutils">
<dt>`` physical_path``</dt>
<dd>`` pyramid.traversal.resource_path（resource） <a href="#id1"><span class="problematic" id="id2">``</span></a>で定義されている、リソースに対して計算された&amp;quot;物理パス&amp;quot;を表す文字列。それはスラッシュで始まり、スラッシュで終わります。</dd>
<dt>`` virtual_path``</dt>
<dd>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>virtual_root_support`で定義されているように、リソースに対して計算された&amp;quot;仮想パス&amp;quot;を表す文字列。仮想ルートが有効になっていない場合、これは物理パスと同じです。それはスラッシュで始まり、スラッシュで終わります。</dd>
<dt>`` app_url``</dt>
<dd>`` request.resource_url``の間に生成されたアプリケーションURLを表す文字列です。スラッシュで終わることはありません。これは潜在的にカスタマイズされたURLプレフィックスを表し、ユーザーが `` request.resource_url``に渡す可能性のあるカスタムスキーム、ホスト、ポート情報を含みます。 `` request.application_url``の使用よりも優先すべきです。</dd>
</dl>
<p>リソースの `` __resource_url__``メソッドは、URLを表す文字列を返さなければなりません。デフォルトを上書きできない場合は `` None``を返します。 `` None``を返すと、デフォルトのURLが返されます。</p>
<p>次に、 `` __resource_url__``メソッドの例を示します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Resource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__resource_url__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;app_url&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;virtual_path&#39;</span><span class="p">]</span>
</pre></div>
</td></tr></table></div>
<p>上の例は実際には、デフォルトの `` resource_url``機構によって生成されたデフォルトURLを生成して返しますが、コードは必要に応じて任意のロジックを実行できます。たとえば、コードで生成されたURLのホスト名またはポート番号を上書きすることができます。</p>
<p>`` __resource_url__``で生成されたURLは完全修飾でなければならず、スラッシュで終わっていて、クエリー文字列やアンカー要素（パス要素のみ）を含めてはいけません：meth： <cite>〜pyramid.request.Request .resource_url</cite>。</p>
</div>
</div>
<div class="section" id="generating-the-path-to-a-resource">
<span id="index-4"></span><h2>リソースへのパスの生成<a class="headerlink" href="#generating-the-path-to-a-resource" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.traversal.resource_path`は、リソースツリー内の位置に基づいて、リソースオブジェクトの絶対的な物理パスを表す文字列オブジェクトを返します。パスの各セグメントはスラッシュ文字で区切られています。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.traversal</span> <span class="kn">import</span> <span class="n">resource_path</span>
<span class="n">url</span> <span class="o">=</span> <span class="n">resource_path</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の例の `` resource``が `` root [&amp;#39;a&amp;#39;] [&amp;#39;b&amp;#39;] <a href="#id1"><span class="problematic" id="id2">``</span></a>としてツリーにアクセス可能であった場合、上の例は文字列 `` / a / b``を生成します。</p>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.traversal.resource_path`に渡された位置引数は、パスのセグメントとしてリソースパスの末尾に追加されます。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.traversal</span> <span class="kn">import</span> <span class="n">resource_path</span>
<span class="n">url</span> <span class="o">=</span> <span class="n">resource_path</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の例の `` resource``が `` root [&amp;#39;a&amp;#39;] [&amp;#39;b&amp;#39;] <a href="#id1"><span class="problematic" id="id2">``</span></a>としてツリー内でアクセス可能であった場合、上記の例では文字列 `` / a / b / foo / bar` <a href="#id3"><span class="problematic" id="id4">`</span></a>。</p>
<p>渡されるリソースは、term： <cite>location</cite>-awareでなければなりません。</p>
<p>a：term： <cite>virtual root`の有無は：func：</cite>〜pyramid.traversal.resource_path`の動作に影響しません。</p>
</div>
<div class="section" id="finding-a-resource-by-path">
<span id="index-5"></span><h2>パスによるリソースの検索<a class="headerlink" href="#finding-a-resource-by-path" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リソースへの文字列パスがある場合は、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.traversal.find_resource`を使用して、アプリケーションのリソースツリーのその場所からリソースを取得できます。</p>
<p>絶対パスを解決するには、 `` / <a href="#id1"><span class="problematic" id="id2">``</span></a>で始まる文字列を `` path``引数として渡します：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.traversal</span> <span class="kn">import</span> <span class="n">find_resource</span>
<span class="n">url</span> <span class="o">=</span> <span class="n">find_resource</span><span class="p">(</span><span class="n">anyresource</span><span class="p">,</span> <span class="s1">&#39;/path&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>あるいは、 `` / <a href="#id1"><span class="problematic" id="id2">``</span></a>を前置しない文字列を渡して：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>pyramid.traversal.find_resource`に渡すリソースに関連するパスを解決することができます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.traversal</span> <span class="kn">import</span> <span class="n">find_resource</span>
<span class="n">url</span> <span class="o">=</span> <span class="n">find_resource</span><span class="p">(</span><span class="n">anyresource</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>func： <cite>〜pyramid.traversal.find_resource`は、：func：</cite>〜pyramid.traversal.resource_path` APIによって生成されることがよくあります。これらのAPIはお互いの「ミラー」です。</p>
<p>：func： <cite>〜pyramid.traversal.find_resource`（ツリー内のそれぞれのリソースが存在しない場合）を呼び出すときにパスを解決できない場合、a：exc：</cite> KeyError`が送出されます。</p>
<p>リソースへのパスを解決する方法の詳細については、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.traversal.find_resource`のドキュメントを参照してください。</p>
</div>
<div class="section" id="obtaining-the-lineage-of-a-resource">
<span id="index-6"></span><h2>リソースの系統を取得する<a class="headerlink" href="#obtaining-the-lineage-of-a-resource" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>pyramid.location.lineage</cite>：term：` location`-aware：term： <cite>resource`オブジェクトの：term：</cite> lineage`を表すジェネレータを返します。</p>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.location.lineage`関数は、それに渡されたリソースを返し、次にリソースの各親を順番に返します。たとえば、リソースツリーが次のように構成されているとします。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">thing1</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">thing2</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">thing2</span><span class="o">.</span><span class="n">__parent__</span> <span class="o">=</span> <span class="n">thing1</span>
</pre></div>
</td></tr></table></div>
<p>`` lineage（thing2） <a href="#id1"><span class="problematic" id="id2">`</span></a>&amp;#39;を呼び出すとジェネレータが返されます。リストにすると、次のようになります：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="n">lineage</span><span class="p">(</span><span class="n">thing2</span><span class="p">))</span>
<span class="p">[</span> <span class="o">&lt;</span><span class="n">Thing</span> <span class="nb">object</span> <span class="n">at</span> <span class="n">thing2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Thing</span> <span class="nb">object</span> <span class="n">at</span> <span class="n">thing1</span><span class="o">&gt;</span> <span class="p">]</span>
</pre></div>
</td></tr></table></div>
<p>：func： <cite>〜pyramid.location.lineage`によって返されたジェネレータは、最初に渡されたリソースを無条件で返します。次に、リソースが `</cite> __parent__``属性を与えた場合、 `` resource .__ parent__``で表されるリソースを返します。 <a href="#id1"><span class="problematic" id="id2">*</span></a>そのリソースが `` __parent__``属性を持つ場合、検査対象リソースに `` __parent__``属性がないか、 `` __parent__``属性が `` __parent__``属性になるまで、そのリソースの親を返します。 「なし」。</p>
<p>詳細については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.location.lineage`のドキュメントを参照してください。</p>
</div>
<div class="section" id="determining-if-a-resource-is-in-the-lineage-of-another-resource">
<h2>リソースが別のリソースのリネージにあるかどうかの判断<a class="headerlink" href="#determining-if-a-resource-is-in-the-lineage-of-another-resource" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>pyramid.location.inside`関数を使用して、あるリソースが別のリソースの：term：</cite> lineage`にあるかどうかを判断します。</p>
<p>たとえば、リソースツリーが以下の場合：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">__parent__</span> <span class="o">=</span> <span class="n">a</span>
</pre></div>
</td></tr></table></div>
<p>`` inside（b、a） <cite>を呼び出すと</cite> <cite>True``が返されます。</cite> <cite>b``には</cite> <cite>a``を含む系統があるからです。しかし、 `</cite> inside（a、b） <cite>&amp;#39;を呼び出すと、</cite> <cite>a``に</cite> <cite>b``を含む系統がないので</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>False``を返します。</p>
<p>：func： <cite>〜pyramid.location.inside`の引数リストは</cite> <cite>（resource1、resource2）</cite> <cite>です。 `</cite> resource2``が `` resource1``の <cite>：term：</cite> lineage`の祖先である場合、 `` resource1``は&amp;quot;inside &amp;quot; `` resource2``です。親（または親の親など）が祖先である場合、それは系統の祖先です。</p>
<p>詳細は、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.location.inside`を参照してください。</p>
</div>
<div class="section" id="finding-the-root-resource">
<span id="index-7"></span><h2>ルートリソースの検索<a class="headerlink" href="#finding-the-root-resource" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>pyramid.traversal.find_root</cite> APIを使って：term：` root`リソースを見つけてください。ルートリソースは：term： <cite>リソースツリー &amp;#39;のルートにあるリソースです。 APIは単一の引数 `</cite> resource``を受け入れます。これは、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>location`を意識したリソースです。これは、ツリー内でルートを検索する任意のリソースにすることができます。</p>
<p>たとえば、リソースツリーが以下の場合：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Thing</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">__parent__</span> <span class="o">=</span> <span class="n">a</span>
</pre></div>
</td></tr></table></div>
<p>`` find_root（b） <a href="#id1"><span class="problematic" id="id2">``</span></a>を呼び出すと `` a``が返されます。</p>
<p>ルートリソースは：term： <cite>view callable`コード内で</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>request.root``として利用することもできます。</p>
<p>a：term： <cite>virtual root`の有無は：func：</cite>〜pyramid.traversal.find_root`の動作に影響を与えません。返されるルートオブジェクトは常に* physical <a href="#id1"><span class="problematic" id="id2">*</span></a>ルートオブジェクトです。</p>
</div>
<div class="section" id="resources-which-implement-interfaces">
<span id="index-8"></span><span id="id3"></span><h2>インタフェースを実装するリソース<a class="headerlink" href="#resources-which-implement-interfaces" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リソースは：term： <cite>interface`を実装するためにオプションで作ることができます。インタフェースは、後で：term： `view configuration`と：func：</cite> pyramid.traversal.find_interface`で参照できる&amp;quot;type &amp;quot;でリソースオブジェクトをタグ付けするために使用されます。</p>
<p>：term： <cite>view configuration`文内の</cite> <cite>context``または</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>containment``述語引数としてクラスの代わりにインタフェースを指定すると、複数のクラスのリソースオブジェクトに対して呼び出し可能な単一のビューを使用することができます。アプリケーションが単純なので、これをやりたい理由がない場合は、この章のこのセクションを読み飛ばしてください。</p>
<p>たとえば、ブログエントリが：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`を実装していることを宣言するブログエントリを記述するコードがあります。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">implementer</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IBlogEntry</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@implementer</span><span class="p">(</span><span class="n">IBlogEntry</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BlogEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">author</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">author</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>このリソースは、リソースコンストラクタを `` BlogEntry``クラスとして定義するクラスと、 `` IBlogEntry`を使用する `` implementer``クラスデコレータを介してクラスに付加される：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`の2つの要素から成ります。 <a href="#id3"><span class="problematic" id="id4">`</span></a>インターフェイスを唯一の引数として使用します。</p>
<p>使用されるインタフェースオブジェクトは、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>zope.interface.Interface`から継承するクラスのインスタンスでなければなりません。</p>
<p>リソースクラスは、0以上のインタフェースを実装することができる。 ：func： <cite>zope.interface.implementer`関数をクラスデコレータとして使用して、リソースがインタフェースを実装するように指定します。上記の `</cite> BlogEntry``リソースは `` IBlogEntry``インターフェースを実装しています。</p>
<p>特定のリソース*インスタンス*がそのクラスではなくインタフェースを提供するように指定することもできます。クラスがインタフェースを実装すると宣言すると、そのクラスのすべてのインスタンスもそのインタフェースを提供します。しかし、単一のオブジェクトがインタフェースを提供すると言うこともできます。これを行うには、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>zope.interface.directlyProvides`関数を使います：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">directlyProvides</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IBlogEntry</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">BlogEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">author</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">author</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

<span class="n">entry</span> <span class="o">=</span> <span class="n">BlogEntry</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="s1">&#39;author&#39;</span><span class="p">)</span>
<span class="n">directlyProvides</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">IBlogEntry</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>zope.interface.directlyProvides`は、以前にインスタンスによって提供された既存のインタフェースを置き換えます。リソースオブジェクトに、すでに置き換えたくないインスタンスレベルのインタフェース宣言がある場合は、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>zope.interface.alsoProvides`関数を使用してください：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">alsoProvides</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">directlyProvides</span>
<span class="kn">from</span> <span class="nn">zope.interface</span> <span class="kn">import</span> <span class="n">Interface</span>

<span class="k">class</span> <span class="nc">IBlogEntry1</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">IBlogEntry2</span><span class="p">(</span><span class="n">Interface</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">BlogEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">author</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">author</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

<span class="n">entry</span> <span class="o">=</span> <span class="n">BlogEntry</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="s1">&#39;author&#39;</span><span class="p">)</span>
<span class="n">directlyProvides</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">IBlogEntry1</span><span class="p">)</span>
<span class="n">alsoProvides</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">IBlogEntry2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>：func： <cite>zope.interface.alsoProvides`は、インスタンスによって直接提供されるインタフェースのセットを、func：</cite> zope.interface.directlyProvides`のように上書きするのではなく、追加します。</p>
<p>ビューの設定でリソースインタフェースを使用する方法の詳細については、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>using_resource_interfaces`を参照してください。</p>
</div>
<div class="section" id="finding-a-resource-with-a-class-or-interface-in-lineage">
<span id="index-9"></span><h2>リネージのクラスまたはインターフェイスを持つリソースの検索<a class="headerlink" href="#finding-a-resource-with-a-class-or-interface-in-lineage" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>〜pyramid.traversal.find_interface</cite> APIを使って特定のPythonクラスの親を見つけるか、あるいは：term：` interface`を実装します。</p>
<p>たとえば、リソースツリーが次のように構成されているとします。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thing1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">class</span> <span class="nc">Thing2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Thing1</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Thing2</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">__parent__</span> <span class="o">=</span> <span class="n">a</span>
</pre></div>
</td></tr></table></div>
<p>`` a``がクラス `` Thing1``であるため、 `` find_interface（a、Thing1） <a href="#id1"><span class="problematic" id="id2">``</span></a>を呼び出すと `` a``リソースが返されます（最初の引数として渡されるリソースは最初に考慮され、クラスまたはインターフェイスの仕様が一致します）。</p>
<p>「find_interface（b、Thing1）」を呼び出すと、 `` a``がクラス `` Thing1``で `` a``が `` b``の最初のリソースであるため、 `` a``リソースを返しますこのクラスの系譜。</p>
<p>`` find_interface（b、Thing2） <a href="#id1"><span class="problematic" id="id2">``</span></a>を呼び出すと、 `` b``リソースが返されます。</p>
<p>`` find_interface``の2番目の引数は、クラスではなくterm： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`でもかまいません。それがインタフェースである場合、系統内の各リソースは、そのリソースがクラスであるかどうかを見るのではなく、特定のインタフェースを実装しているかどうかを調べるためにチェックされます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>resources_which_implement_interfaces`も参照してください。</p>
</div>
</div>
<div class="section" id="pyramid-api-functions-that-act-against-resources">
<span id="index-10"></span><h2>：app：Pyramid API関数<a class="headerlink" href="#pyramid-api-functions-that-act-against-resources" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リソースオブジェクトは、ビューに提供される：term： <cite>context`として使用されます。リソースオブジェクトがどのようにコンテキストになるかについては、：ref： `traversal_chapter`と：ref：</cite> urldispatch_chapter`を参照してください。</p>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>traversal_module`によって提供されるAPIは、リソースオブジェクトに対して使用されます。これらの関数は、リソースの &amp;quot;パス&amp;quot;、リソースツリーのルートリソース、またはリソースのURLを生成するために使用できます。</p>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>location_module`によって提供されるAPIは、リソースに対して使用されます。これらは、リソースツリーを歩き回るか、別のリソースを別の場所に配置するのに便利です。</p>
<p>：class： <cite>pyramid.request.Request`上のいくつかのAPIは、リソースオブジェクトをパラメータとして受け入れます。たとえば、：meth： `〜pyramid.request.Request.has_permission</cite> APIは、引数の1つとしてリソースオブジェクトを受け入れます。 ACLはこのリソースまたはその祖先の1つから取得されます。 ：class： <cite>pyramid.request.Request`クラスの他のセキュリティ関連APIは引数としてterm：</cite> context`を受け入れ、コンテキストは常にリソースです。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">(機械翻訳) リソース</a><ul>
<li><a class="reference internal" href="#defining-a-resource-tree">リソースツリーの定義</a></li>
<li><a class="reference internal" href="#location-aware-resources">位置認識リソース</a></li>
<li><a class="reference internal" href="#generating-the-url-of-a-resource">リソースのURLの生成</a><ul>
<li><a class="reference internal" href="#overriding-resource-url-generation">リソースURL生成のオーバーライド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-the-path-to-a-resource">リソースへのパスの生成</a></li>
<li><a class="reference internal" href="#finding-a-resource-by-path">パスによるリソースの検索</a></li>
<li><a class="reference internal" href="#obtaining-the-lineage-of-a-resource">リソースの系統を取得する</a></li>
<li><a class="reference internal" href="#determining-if-a-resource-is-in-the-lineage-of-another-resource">リソースが別のリソースのリネージにあるかどうかの判断</a></li>
<li><a class="reference internal" href="#finding-the-root-resource">ルートリソースの検索</a></li>
<li><a class="reference internal" href="#resources-which-implement-interfaces">インタフェースを実装するリソース</a></li>
<li><a class="reference internal" href="#finding-a-resource-with-a-class-or-interface-in-lineage">リネージのクラスまたはインターフェイスを持つリソースの検索</a></li>
<li><a class="reference internal" href="#pyramid-api-functions-that-act-against-resources">：app：Pyramid API関数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="testing.html"
                        title="前の章へ">(機械翻訳) ユニット、統合、機能テスト</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="hellotraversal.html"
                        title="次の章へ">(機械翻訳) こんにちはトラバーサルワールド</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/narr/resources.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="hellotraversal.html" title="(機械翻訳) こんにちはトラバーサルワールド"
             >次へ</a> |</li>
        <li class="right" >
          <a href="testing.html" title="(機械翻訳) ユニット、統合、機能テスト"
             >前へ</a> |</li>
    	<li><a href="../index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 11月 13, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 で生成しました。
    </div>
  </body>
</html>
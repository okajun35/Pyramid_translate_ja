
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>(機械翻訳)守るピラミッドのデザイン &#8212; The Pyramid Web Framework v1.9.2</title>
    <link rel="stylesheet" href="_static/pylons.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="copyright" title="著作権" href="copyright.html" />
    <link rel="next" title="(機械翻訳)著作権、商標、帰属" href="copyright.html" />
    <link rel="prev" title="(機械翻訳) Pyramid 変更履歴" href="changes.html" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/nobile/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="//static.pylonsproject.org/fonts/neuton/stylesheet.css" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<link rel="shortcut icon" href="_static/pyramid.ico"/>

  </head><body>







<div class="header-small">
	
	<div class="logo-small">
		<a href="index.html">
      		<img class="logo" src="_static/pyramid-small.png" alt="Logo"/>
		</a>
  	</div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="copyright.html" title="(機械翻訳)著作権、商標、帰属"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="changes.html" title="(機械翻訳) Pyramid 変更履歴"
             accesskey="P">前へ</a> |</li>
    	<li><a href="index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="defending-pyramid-s-design">
<span id="design-defense"></span><h1>(機械翻訳)守るピラミッドのデザイン<a class="headerlink" href="#defending-pyramid-s-design" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>時には、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`デザインのさまざまな面での課題が提起されています。ここでの議論に文脈を与えるために、ここではいくつかの設計上の決定とトレードオフについて詳しく説明します。場合によっては、フレームワークが改善され、改善するための今後の手順について説明します。他の人たちは、気づいたとおりに挑戦します。明らかに、みんなをいつも楽しませることはできません。</p>
<div class="section" id="pyramid-provides-more-than-one-way-to-do-it">
<h2>ピラミッドは、それを行う方法の一つ以上を提供します<a class="headerlink" href="#pyramid-provides-more-than-one-way-to-do-it" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Pythonの普及した文化のキヤノンは、&amp;quot;TIOOWTDI &amp;quot;（&amp;quot;それを行う唯一の方法があります&amp;quot;、Perlの&amp;quot;TIMTOWTDI &amp;quot;への少し舌の頬の参照、&amp;quot;それを行うには複数の方法があります」）。</p>
<p>：app： <cite>Pyramid`は、「TIMTOWTDI」システムです。たとえば、URLを：term： `view callable</cite>：via：term：` url dispatch`または：term： <cite>traversal`に解決する方法は複数あります。 ：term： `必須設定</cite>、：term： <cite>コンフィギュレーションデコレーション</cite>、：term： <cite>ZCML`（オプション：term：</cite> pyramid_zcml`）。これは、複数の異なる種類のパーシスタンスおよびテンプレートシステムで動作します。等々。しかし、これらの重複する方法の大半は理由と目的がないわけではありません。私たちは多数の聴衆を抱えており、WebフレームワークレベルのTIMTOWTDIは実際にはもっと潜在的で危険なセットPython Webコミュニティの上位レベルで重複しています。</p>
<p>：app： <cite>Pyramid`は長年の人々のチームによって書かれたmod：</cite> repoze.bfg`のように人生を始めました。 「term： <cite>traversal`とterm：</cite> view lookup`の考え方はZopeから完全に盗まれました。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`によって提供される承認サブシステムは、Zopeの派生物です。アプリケーションをフォークすることなく*拡張することができるという考えは、Zopeの派生物でもあります。</p>
<p>：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`の作者が、彼らが慣れ親しんだやり方で、顧客のためにパンとバターのCMS型システムを構築できるようにするには、これらの機能の実装が必要でした。 Zope自身のために保存されている他のシステムは、そのような機能を持っていませんでした.Zope自体は、時代の兆しを見せ始めていました。私たちは、初期の設計ミスの結果によって妨げられていました。 Zopeの文書化の欠如もまた回避するのが難しかった。 Zopeアプリケーションで作業するために賢い人材を雇うことは難しかった。なぜなら、1つの消耗品の場所で&amp;quot;すべて&amp;quot;を説明する包括的な文書セットがなく、大きすぎて正しく文書化するために自己矛盾していたからです。 mod： <a href="#id3"><span class="problematic" id="id4">`</span></a>repoze.bfg`が開発される前は、著者たちは明らかに法案に適合する他のフレームワークについて検討しました。しかし、Zope以外のフレームワークはありませんでした。そこで我々はmod： <a href="#id5"><span class="problematic" id="id6">`</span></a>repoze.bfg`のビルドに着手しました。</p>
<p>しかし、私たちの研究の結果、* 1つの*フレームワークに必要な機能がすべて含まれていなかったにもかかわらず、既存のフレームワークは多く、優れたアイデアを持ち、時には非常に魅力的なアイデアを持っていたことが明らかになりました。特に、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>URL dispatch`はURLをコードにマッピングするためのより直接的なメカニズムです。</p>
<p>だから、私たちのニーズに合ったZopeを除いて、フレームワークを見つけることはできませんでしたが、ZopeのアイデアをBFGに取り込んでいる間に、他のフレームワークで魅力的だった機能も模倣しました。 url dispatch`）。 BFGの最初の一般公開後、時間がたつにつれて、システム内の様々なZope-ismsにアレルギーのある人々をサポートする機能が追加されました。たとえば、term： <cite>必須の設定`と：term： ：term： `ZCML`のみを使用するのではなく、：term：</cite> interface`オブジェクトの必要な使用を排除することです。すぐにわれわれは非常に汎用的なシステムを持っていて、Zope以外のユーザーや元のZopeユーザーにアピールするようになっていたことが明らかになりました。</p>
<p>この一般化の結果、BFGはPylons 1のフィーチャセットでそのフィーチャセットの90％を共有したことが明らかになり、ターゲット市場は非常に似ていました。彼らはとても似ていたので、2つのシステムの選択は、そうでなければ党派ではない開発者の不満の練習であった。また、PylonsとBFGの開発コミュニティが、2つのフレームワークがどれほど似ているかを考慮して、同じユーザーセットに対して競争することは奇妙でした。そこで、PylonsチームとBFGチームが協力して合併計画を立てました。 BFGには欠けている機能（特に、用語： <a href="#id1"><span class="problematic" id="id2">`</span></a>view handler`クラス、フラッシュメッセージング、その他のマイナーな欠落ビット）が追加され、Pylonsユーザーに親しみを与えました。結果はapp： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`です。</p>
<p>PythonのWebフレームワークのスペースは、現在、有名なバルカン化されています。 app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`のコンポーネントが合併すれば、PylonsとBFGユーザーの少なくとも二つの現在非常に異なるユーザーにアピールすることを本当に望んでいます。 PylonsとBFGの最高のコンセプトを単一のコードベースに統合し、先祖からの悪いコンセプトを残しておくことで、無駄に競合することなく、より良い取り組みを強化し、より多くのコードを共有し、 。私たちは、競合他社と互換性のない特定の低レベルのスタック上に構築された、競合しているが信じられないほど類似しているアプリケーションやライブラリに代表される、<a href="#id3"><span class="problematic" id="id4">*</span></a>はるかに大きな*重複の努力をもたらすパック・メンタリティをショートカットすることを望んでいます。また、信頼できるPython Webフレームワークの選択を少なくとも1つ減らします。また、ZopeやTurboGearsのような他のコミュニティから必要な機能を提供することでユーザーを引きつけ、親しみやすい方法で柔軟に対応できるようにしたいと考えています。少なくとも、より高いレベルで無意味な複製を防ぐことを目指すならば、これらの目標を達成するための機能のオーバーラップが予想され、避けられません。私たちが十分に仕事をしていれば、さまざまな観客が、仮想WebフレームワークDMZのいくつかの間でお互いに発砲するのではなく、共存し協力することができます。</p>
</div>
<div class="section" id="pyramid-uses-a-zope-component-architecture-zca-registry">
<h2>ピラミッドはZopeコンポーネントアーキテクチャ（&amp;quot;ZCA &amp;quot;）レジストリを使用します<a class="headerlink" href="#pyramid-uses-a-zope-component-architecture-zca-registry" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：app： <cite>Pyramid`は：term：</cite> Zope Component Architecture`（ZCA）&amp;quot;コンポーネントレジストリ&amp;quot;を：term： <cite>アプリケーションレジストリ`として使用します。これはいくつかの論争のポイントです。 ：app： `Pyramid`は：term：</cite> Zope`系統であるため、開発者がZCAレジストリを使用するのは当然です。しかし、ZCAレジストリの使用には問題と結果があります。私たちができる限り最善の方法で対応しようとしています。ここでは、app：PyramidのZCAレジストリの使用と、その使用法のトレードオフについてのイントロスペクションです。</p>
<div class="section" id="problems">
<h3>問題<a class="headerlink" href="#problems" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ZCAコンポーネントレジストリ内のデータにアクセスするために使用される可能性のあるグローバルAPIは、あまり直感的ではありません。同様に、ZCAグローバルAPIを使用するコードの偶然のソースコードリーダーに対する概念的な負荷はいくぶん高いです。 ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>zope.component.getUtility`グローバルAPIを使って典型的な&amp;quot;無名ユーティリティ&amp;quot;ルックアップを実行するコードを読んでいるZCA初心者を考えてみましょう：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">ISettings</span>
<span class="kn">from</span> <span class="nn">zope.component</span> <span class="kn">import</span> <span class="n">getUtility</span>
<span class="n">settings</span> <span class="o">=</span> <span class="n">getUtility</span><span class="p">(</span><span class="n">ISettings</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>このコードが実行されると、 `` settings``はPython辞書になります。しかし、民間人はコードを読むだけでそれを知ることはまずありません。上記のコードには明らかな問題がいくつかあります。</p>
<p>まず、&amp;quot;ユーティリティ&amp;quot;とは何ですか？さて、この議論の目的のために、そして上記のコードの目的のために、あまり重要ではない。あなたが本当に知りたいのであれば、 <a href="#id1"><span class="problematic" id="id2">`</span></a>this &lt;<a class="reference external" href="http://muthukadan.net/docs/zca.html#utility">http://muthukadan.net/docs/zca.html#utility</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_。しかし、そのようなコードの読者は、それを解析するためには概念を理解する必要があります。これは問題番号1です。</p>
<p>次に、「ISETTINGS」のことは何ですか？それは：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`です。それはここで重要ですか？実際には、マーカーとしてのIDに基づいたルックアップのキーとして単に使用しています。これは辞書APIを持つオブジェクトを表しますが、これはあまり重要ではありません。それは2番の問題です。</p>
<p>第三に、 `` getUtility``関数は何をしますか？これは、 &amp;quot;ISettings&amp;quot; &amp;quot;utility &amp;quot;の検索を実行しています。これは、ユーティリティでもあります。この質問に答えるために：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`と&amp;quot; utility &amp;quot;という概念の理解に依存していることに注意してください。また、答えは循環的で、実際には*悪い兆候であることにも注意してください。</p>
<p>四番目に、 `` getUtility``はデータを取得するためにどこにありますか？まあ、&amp;quot;コンポーネントレジストリ&amp;quot;もちろん。コンポーネントレジストリとは何ですか？問題番号4。</p>
<p>第五に、あなたが購入したと仮定すると、いくつかの魔法のレジストリがぶら下がっています。 * Homina homina * ... &amp;quot;around &amp;quot;？これは、この文脈で最良の答えのようなものです（より具体的な答えは、内部の知識を必要とします）。複数のレジストリがありますか？はい。したがって、レジストリで登録が見つかりますか？まあ、もちろん&amp;quot;現在の&amp;quot;レジストリ。 app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`に関して、現在のレジストリはスレッドローカル変数です。ローカルのスレッドに問い合わせるAPIを使用すると、非ローカルで動作する方法を理解できます。</p>
<p>あなたは今、ちょうどぶらぶらしているレジストリがあるという事実を買いました。しかし、どのようにレジストリにデータが取り込まれますか？なぜ、 `` config.add_view``のような指令を呼び出すコードを介して。しかし、この特別なケースでは、 `` ISettings``の登録はフレームワーク自体によって行われます。これは、どのユーザ設定でも存在しません。これは非常に理解しにくいです。 6番の問題</p>
<p>Pythonプログラマーの熟練者であるにもかかわらず、ZCAの使用のために：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`フレームワークを拡張したコードの読者が負担しなければならない認知負荷があることは明らかですWebアプリケーションのドメインこれは準最適です。</p>
</div>
<div class="section" id="ameliorations">
<h3>改善<a class="headerlink" href="#ameliorations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最初に、：app： <cite>Pyramid</cite> <a href="#id1"><span class="problematic" id="id2">*</span></a>は、アプリケーション開発者がZCAの概念やそのAPIを理解することを期待していません。 * app：Pyramidアプリケーションの作成中に*アプリケーション*開発者がZCAの概念やAPIを理解する必要がある場合、いくつかの軸で失敗しました。</p>
<p>その代わりに、フレームワークは、ZCA APIを使用する専用API関数の背後にZCAレジストリの存在を隠します。たとえば、現在のリクエストに存在するuseridを返す `` pyramid.security.authenticated_userid``関数や、現在のリクエストにuseridが存在しない場合は `` None``を返します。アプリケーション開発者は次のように呼び出します。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.security</span> <span class="kn">import</span> <span class="n">authenticated_userid</span>
<span class="n">userid</span> <span class="o">=</span> <span class="n">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>彼らは現在、現在のユーザーIDを持っています。</p>
<p>しかし、そのフードの下では、 `` authenticated_userid``の実装はこれです：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the userid of the currently authenticated user or</span>
<span class="sd">    ``None`` if there is no authentication policy in effect or there</span>
<span class="sd">    is no currently authenticated user. &quot;&quot;&quot;</span>

    <span class="n">registry</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">registry</span> <span class="c1"># the ZCA component registry</span>
    <span class="n">policy</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">queryUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">policy</span><span class="o">.</span><span class="n">authenticated_userid</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>このようなラッパーを使用して、我々はアプリケーション開発者からZCA APIを常に隠すように努めています。アプリケーション開発者はZCA APIについて知る必要はありません。彼らは引数としてドメインにいくつかのオブジェクトを混ぜたPython関数を呼び出す必要があり、結果を返さなければなりません。以下の結論は、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`を使って書かれたアプリケーションの読者は、ZCA APIを理解する必要はないということです。</p>
<p>アプリケーション開発者やコードリーダーからZCA APIを隠すことは、ドメイン特化を強化する一形態です。アプリケーション開発者は、Webフレームワークがどのように機能するかについての細かく詳細なメカニズムを理解する必要はありません。人々は彼らが働いているドメインに近い概念を扱いたいと思っています。例えば、Web開発者は*ユーティリティ*ではなく*ユーザー*について知りたいと思っています。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`は、エンドユーザに公開されている機能ではなく、実装の詳細としてZCAを使用します。</p>
<p>しかし、アプリケーション開発者とは異なり、トラバーサルやビュールックアップのようなあらかじめ定義されたフレームワークプラグインを使ってapp： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`機能をオーバーライドしたい人を含め、<a href="#id3"><span class="problematic" id="id4">*</span></a>フレームワーク開発者*はZCAレジストリAPIを理解しなければなりません。</p>
<p>：app： <cite>Pyramid`フレームワークの開発者は、ZCAレジストリAPIの概念的な負荷の問題を心配していました。 &lt;https://github.com/repoze/repoze.component&gt; `_ named：mod：</cite> repoze.component`が実際に開発されました。このパッケージには完全に機能し、十分にテストされたレジストリ実装がありますが、そのAPIはZCAレジストリAPIよりもはるかに優れていますが、その作業はほとんど放棄されています：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`では使用されていません。私たちは、最終的により良い適合が証明されたため、app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`内でZCAレジストリを使い続けました。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ZCAのレジストリを使用することは、インターフェイスのZCAの概念が多くのシナリオで有用なインターフェイス階層の使用を提供しているため、mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>repoze.component &amp;#39;でレジストリ実装を使用することに賛成ですコンテキストタイプの継承として）。この機能を可能にするインターフェイスのようなものだったマーカータイプが登場したのは、ホイールを再開発したようなものでした。</p>
</div>
<p>フレームワークの開発者とエクステンダーにZCAレジストリAPIを理解させることはトレードオフです。我々（the：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`開発者）は、ZCAレジストリが私たちに与えてくれた機能を好きです。私たちは、これが何をし、どのように機能するのかを理解する重要性を昔から持っています。 app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`の著者は、ZCAを深く理解し、他のコードと同じように簡単に使用するコードを読むことができます。</p>
<p>しかし、我々は、フレームワークを拡張したいかもしれない開発者は、元の開発者と同じようにZCAレジストリAPIに慣れていないことを認識しています。ですから、第三者に親切であることを目的に、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`フレームワーク開発者たちは、砂の中にいくつかの線を引いています。</p>
<p>すべてのコアコードでは、 &amp;quot;zope.component.getUtility&amp;quot;や &amp;quot;zope.component.getAdapter&amp;quot;などのZCAグローバルAPI関数を使用しました。これはルールの代わりに例外です。だから代わりに：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IAuthenticationPolicy</span>
<span class="kn">from</span> <span class="nn">zope.component</span> <span class="kn">import</span> <span class="n">getUtility</span>
<span class="n">policy</span> <span class="o">=</span> <span class="n">getUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`コードは通常次のようになります：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.interfaces</span> <span class="kn">import</span> <span class="n">IAuthenticationPolicy</span>
<span class="kn">from</span> <span class="nn">pyramid.threadlocal</span> <span class="kn">import</span> <span class="n">get_current_registry</span>
<span class="n">registry</span> <span class="o">=</span> <span class="n">get_current_registry</span><span class="p">()</span>
<span class="n">policy</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">getUtility</span><span class="p">(</span><span class="n">IAuthenticationPolicy</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>後者はより冗長ですが、それは間違いなく何が起こっているかをより明白にします。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`コアコードは、ZCAのグローバルAPIではなく、このパターンを使用します。</p>
</div>
<div class="section" id="rationale">
<h3>根拠<a class="headerlink" href="#rationale" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ZCAレジストリを使用するapp： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`の決定：</p>
<ul class="simple">
<li>歴史。この質問に対する答えの重要な部分は「歴史」です。 app： <cite>Pyramid`のデザインの多くは：term：</cite> Zope`から直接盗まれました。 Zopeは、ZCAレジストリを使用して多くのトリックを行います。 ：app： <cite>Pyramid`はこれらのトリックを模倣しています.ZCAレジストリはそのトリックセットでうまくいくので、：app：</cite> Pyramid`は同じ目的でそれを使います。例えば：app： <cite>Pyramid`はa：term：</cite> request`をa：term： <cite>view callable`にマップします：term：</cite> traversal`はZopeからほぼ完全に取り除かれます。 ZCAレジストリは、マッピングを表示するこの要求がどのように行われているかという点で重要な役割を果たします。</li>
<li>特徴。 ZCAコンポーネントレジストリは、基本的にスーパーディクショナリのようなものとみなされるものを提供します。これにより、単一のキーに基づいて値を取得するよりも複雑なルックアップが可能になります。このルックアップ機能の中には、コンテキストがオブジェクトのクラスである場合にのみ見られるビューを登録することや、コンテキストがいくつか：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>interface`を実装している場合など、エンドユーザにとって非常に便利です。</li>
<li>特異性。 &amp;quot;アプリケーション構成&amp;quot;がコンポーネントのレジストリにある：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションに存在する場所は1つだけです。コンポーネントレジストリは、アプリケーション*の設定に基づいて、実行時にフレームワークによって作成された質問に答えます。注：&amp;quot;アプリケーション&amp;quot;は&amp;quot;プロセス&amp;quot;と同じではありません。同じ：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`アプリケーションの複数の独立して設定されたコピーは、同じプロセス空間で実行することができます。</li>
<li>合成性。 ZCAコンポーネントのレジストリには必須のものがあります。あるいは、設定ファイル（ZCML、オプション：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid_zcml`パッケージを使用）を使用してレジストリを読み込むための既存のメカニズムがあります。私たちは設定ファイル駆動のレジストリの人口を利用するために、フロントエンドを最初から書く必要はありませんでした。</li>
<li>プラガブル性。 ZCAレジストリを使用することで、広く定義され広く理解されているプラ​​グインアーキテクチャによるフレームワーク拡張が可能になります。フレームワークの開発者とエクステンダーがZCAレジストリを理解している限り、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`をほぼ任意に拡張することができます。たとえば、複数のビューを一度に登録するディレクティブを作成するのは比較的簡単で、アプリケーション開発者はそのディレクティブを、自分が記述し​​たコードで&amp;quot;マクロ&amp;quot;として使うことができます。これは、他の（Zope以外の）フレームワークとは多少異なる点です。</li>
<li>テスト容易性。フレームワークコードでZCAレジストリを慎重に使用することで、コードを少し簡単にテストできます。テストのためにモックオブジェクトを登録するためにMonkeypatchingや他の機能を使用する代わりに、ZCA登録を介して依存関係を注入し、モックオブジェクトを見つけるためにコード内のルックアップを使用します。</li>
<li>速度。 ZCAレジストリは、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`が使用する複合ルックアップシナリオの特定のセットに対して非常に高速です。これらの目的のために何年もの間最適化されています。 ZCAレジストリには、この目的のためのオプションのCコードが含まれています。このコードでは、明らかにバグはありません（またはごくわずかです）。</li>
<li>生態系。多くの既存のZopeパッケージは、ZCAレジストリを使用しているため、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`でほとんど変更を加えずに使用できます。</li>
</ul>
</div>
<div class="section" id="conclusion">
<h3>結論<a class="headerlink" href="#conclusion" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：app： <cite>Pyramid`を使って*アプリケーションを開発するだけの場合は、ここで不平を言うことはあまりありません。 ZCAレジストリAPIを理解する必要はありません。 documented：app： `Pyramid</cite> APIを代わりに使用してください。しかし、APIのドキュメントを読まないアプリケーション開発者がいるかもしれません。代わりに未加工のソースコードを読んだり、APIドキュメントを読まなかったので、関数、クラス、メソッドが*：* form：the：app： <cite>Pyramid</cite> APIであっても分かりません。その結果、内部を使用するコードを作成し、概念のコーナーに自分自身を描き、実装の詳細を使用したZCAに取り組む必要がありました。これがあなたなら、あなたのために多くの同情を持つことは非常に難しいです。 ZCAレジストリをどのように使用しているかに精通している必要があるか、またはドキュメント化されたAPIのみを使用する必要があります。そのため、APIとして文書化しています。</p>
<p>：ref： <cite>hooks_chapter`で説明されているように、より曖昧なフックのいくつかを使用するか、：app：</cite> Pyramid`コアコードで作業します）あなたは、少なくともいくつかのZCAの概念を理解する必要があることに直面するでしょう。いくつかの場所でそれは恥ずかしがりに使用され、永遠になります。奇妙なことはわかっていますが、それについての読書をする時間があれば、それは有用で基本的に理解できます。</p>
</div>
</div>
<div class="section" id="pyramid-encourages-use-of-zcml">
<span id="zcml-encouragement"></span><h2>Pyramid &amp;quot;ZCMLの使用を奨励<a class="headerlink" href="#pyramid-encourages-use-of-zcml" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：term： <cite>ZCML`は：term：</cite> Zope Component Architecture`レジストリを設定するために使用できる設定言語です：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`がアプリケーション設定に使用します。ピラミッドには &amp;quot;ZCMLが必要&amp;quot;と主張する人が多いです。</p>
<p>それはしません。 In：app： <cite>Pyramid</cite> 1.0、ZCMLはコアの一部としては出荷されません。代わりに：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid_zcml`アドオンパッケージに含まれています。これは完全にオプションです。 app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`やその他のフレームワークの宣言的なフロントエンドからアプリケーションを構成するために、ZCMLは必要ありません。</p>
</div>
<div class="section" id="pyramid-does-traversal-and-i-don-t-like-traversal">
<h2>ピラミッドはトラバーサルを行い、トラバースを好まない<a class="headerlink" href="#pyramid-does-traversal-and-i-don-t-like-traversal" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In：app： <cite>Pyramid</cite>、：term：` traversal`は、リソースツリーの：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>resource`オブジェクトへのURLパスを解決する行為です。一部の人々はこの概念に不快であり、間違っていると信じています。ありがたいことに：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`を使用していて、リソースツリーの観点からアプリケーションをモデル化したくない場合は、まったく使用する必要はありません。代わりに：term： <a href="#id5"><span class="problematic" id="id6">`</span></a>URL dispatch`を使用して、URLパスをビューにマップします。</p>
<p>一部の人々がトラバーサルが一方的に間違っていると考える考えは理解できる。間違っていると信じている人々は、ほとんどすべてのデータをリレーショナルデータベースに入れています。リレーショナルデータベースは当然階層的ではないので、ツリーのようなものを横断することはできません。</p>
<p>しかし、トラバーサルを一方的に間違っているとみなす人々は、多くのパーシステンスメカニズム*が階層的であることを考慮に入れていません。例には、ファイルシステム、LDAPデータベース、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>ZODB`（または他のタイプのグラフ）データベース、XMLドキュメント、Pythonモジュールの名前空間などがあります。フロントエンドを階層的なデータストアにモデル化してグラフとしてモデル化すると便利です。トラバーサルを使用して、ツリー内のリソース（たとえばZODBの場合）や、 （ファイルシステムからのファイルのためのラッパーの場合のように）それらのために立ち入ってください。</p>
<p>また、多くのウェブサイト構造は、それらを駆動するデータがそうでなくても、自然に階層的です。例えば、新聞のウェブサイトは、しばしば非常に階層的である：セクション内のセクション内のセクション、無限にある。 URLがこの構造を示し、構造が不定である場合（ネストされたセクションの数は固定数ではなく&amp;quot;N &amp;quot;となります）、リソースツリーはバックエンドリレーショナルデータベースです。この状況では、リソースツリーは単なるサイト構造に過ぎません。</p>
<p>トラバーサルは、URLマッチングの固定された順序付けに依存しないため、URLディスパッチよりもアプリケーションの合成性が優れています。 URLパターンマッチングの正しい順序付けをしようとするよりも、予想以上にリソースへのビューのマッピングを中心に、異種の機能を組み立てることができます（後で追加します）。</p>
<p>しかし、そのポイントは最終的には間違いです。トラバースを使用したくない場合は、そうする必要はありません。代わりにURLディスパッチを使用してください。</p>
</div>
<div class="section" id="pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch">
<h2>ピラミッドはURLディスパッチを行いますが、私はURLディスパッチが嫌いです<a class="headerlink" href="#pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>in：app： <cite>Pyramid</cite>、：term：` url dispatch`は、URLパスを：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>view`に解決する行為です。ルート定義は順番に調べられます。一致する最初のパターンは、URLをビュー呼び出し可能に関連付けるために使用されます。</p>
<p>一部の人々はこの概念に不快であり、間違っていると信じています。これらは通常、「Zope」という言葉に深く浸透している人々です。 Zopeは、term：コードをURLにマップする <cite>traversal`以外のメカニズムを提供していません。これは主に、Zopeが階層オブジェクトストアである：term： `ZODB`の使用を事実上必要とするためです。 Zopeはリレーショナルデータベースもサポートしていますが、通常、データベースに呼び出されるコードはZODBオブジェクトグラフのどこかに存在します（少なくとも、オブジェクトグラフのノードに関連する：term： `view</cite>）、到達するためにはトラバーサルが必要ですこのコード。</p>
<p>私は、たとえあなたがトラバーサルを使用したいとしても、URLディスパッチが最終的には有用であると主張します。実際には、app： <cite>Pyramid`（参照：ref：</cite> hybrid_chapter`）に* URLディスパッチとトラバースを組み合わせることができます。そのような使い方の一例：オブジェクトグラフ（または任意の管理インターフェース）の上にZope 2の&amp;quot;Zope Management Interface &amp;quot; UIのようなものをエミュレートしたい場合は、 `` config.add_route（ &amp;#39; `` manage`、 `` / manage / * traverse &amp;#39;``） `` `` view``の設定に `` route_name``引数を使ってコード内の&amp;quot;管理&amp;quot;ビューを関連づけます。例えば `` config.add_view （ &amp;#39;.some.callable&amp;#39;、context = &amp;quot;。some.Resource &amp;quot;、route_name = &amp;#39;manage&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>です。このように物事を結ぶと、誰かが `` / manage / ob1 / ob2` &amp;#39;のように歩いていくと、管理インターフェースが表示されるかもしれませんが、 `` / ob1 / ob2``まで歩いていくとデフォルトのオブジェクトビューを表示します。あなたが賢い（そして恐らくmasochisticな）場合でも、これらのハイブリッド構成で引き出すことができる他のトリックがあります。</p>
<p>また、URLディスパッチ機能を備えている場合、従来のリレーショナルデータベース構造を使用する必要があるアプリケーションを作成する必要がある場合は、URLディスパッチを使用すると、ビューとURLパスの間の1回限りの関連付けが便利になることがあります。場合によっては、オブジェクトグラフにノードを追加するだけで、コードの一部のエントリポイントを効果的に表現することができます。あなたは単にルートを使用して、それを使って完了することができます。ルートが一致すると、そのルートに関連付けられたビューが呼び出されます。一致するルートがない場合、：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`はトラバーサルを使用します。</p>
<p>しかし、そのポイントは最終的には間違いです。 ：app： <cite>Pyramid`を使用していて、本当にURLディスパッチを使用したくない場合は、まったく使用する必要はありません。代わりに：term： `traversal`を使用して：term：</cite> Zope`のようにURLパスをビューにマップするだけです。</p>
</div>
<div class="section" id="pyramid-views-do-not-accept-arbitrary-keyword-arguments">
<h2>ピラミッドビューは任意のキーワード引数を受け入れない<a class="headerlink" href="#pyramid-views-do-not-accept-arbitrary-keyword-arguments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>多くのWebフレームワーク（Zope、TurboGears、Pylons 1.X、Django）は：term： <cite>view callable`のバリエーションが任意のキーワードや位置引数を受け入れることを許します。これらの引数は</cite> <cite>request.POST `</cite>、 `` request.GET``、またはルートマッチ辞書を使用します。例えば、Djangoのビューは `` rl ^ polls /（？P）のような関連する &amp;quot;urlconf&amp;quot;内の情報と一致する位置引数を受け取ります。 &lt;poll_id&gt; d +）/ $ <a href="#id1"><span class="problematic" id="id2">``</span></a>：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">poll_id</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">HttpResponse</span><span class="p">(</span><span class="n">poll_id</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Zopeは同様に、トラバーサルによって見つかったリソースオブジェクトのメソッドに任意のキーワードと位置引数を追加することができます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">persistent</span> <span class="kn">import</span> <span class="n">Persistent</span>

<span class="k">class</span> <span class="nc">MyZopeObject</span><span class="p">(</span><span class="n">Persistent</span><span class="p">):</span>
     <span class="k">def</span> <span class="nf">aview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%c</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>公開された呼び出し可能オブジェクトの結果としてこのメ​​ソッドが呼び出されると、要求内の位置引数とキーワード引数の名前と一致するキーがZope要求オブジェクトのGETとPOSTの名前空間で検索され、メソッドは（可能であれば）呼び出されます引数リストには、そこに記載されている値が入っています。 TurboGearsとPylons 1.Xも同様に動作します。</p>
<p>すぐに：app： <cite>Pyramid`はこれらの機能を持たないように設定されています。デフォルトでは、app： `Pyramid`ビューのcallablesは常に</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>request``だけを受け取り、他の引数は受け付けません。その根拠は、積極的に行われた場合、この引数指定はコストがかかる可能性があり、app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`はその主要な目的の1つとしてパフォーマンスを持ちます。したがって、デフォルトでは、view引数リストに展開するための魔法を提供するのではなく、ビューの呼び出し可能な本体内のリクエストオブジェクトを調べることで情報を取得することにしました。</p>
<p>しかし、：app： <cite>Pyramid</cite> 1.0a9のように、ユーザコードは、ビュー呼び出し可能関数が呼び出されると予想される方法に影響を与え、任意の引数で呼び出される呼び出し外のシステムを構成することができます。参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>using_a_view_mapper`を参照してください。</p>
</div>
<div class="section" id="pyramid-provides-too-few-rails">
<h2>Pyramidはあまりにも少ない &amp;quot;Rails <a class="headerlink" href="#pyramid-provides-too-few-rails" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>設計上、：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`は、特に有名なWebフレームワークではありません。これは、比較的簡潔な機能セットを持っています。 ORMや特定のデータベースバインディングは組み込まれていません。フォーム生成フレームワークは含まれていません。管理Webユーザーインターフェイスはありません。テキスト索引作成機能は組み込まれていません。コードの整理方法は決まっていません。</p>
<p>このような批判的な機能は、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`の上に*作られたアプリケーションとフレームワークに存在します。上位のシステムは、：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`をベースに構築されています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>apps_are_extensible`も参照してください。</p>
</div>
</div>
<div class="section" id="pyramid-provides-too-many-rails">
<h2>Pyramidは多すぎる&amp;quot;Rails <a class="headerlink" href="#pyramid-provides-too-many-rails" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`は、他のWebフレームワークが提供していない機能を提供します。これらは、単純な注文Webアプリケーションを構築している場合には意味をなさない可能性のあるユースケース向けの機能です。</p>
<ul class="simple">
<li><cite>term：</cite> traversal`を使ってURLをコードにマップするオプションの方法です。これはa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>resource tree`の散歩を意味します。</li>
<li>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.config.Configurator.include`を使用して複数のソースからPyramidアプリケーション設定を集める機能。</li>
<li>クラスオブジェクトの代わりに：term： <cite>interface`オブジェクトを使用して作成されたビューとサブスクライバ登録（例：：ref：</cite> use_resource_interfaces`）</li>
<li>宣言的な：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>authorization`システムです。</li>
<li>複数の独立したI18N：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>translation string`ファクトリ。それぞれが独自のドメインを指定できます。</li>
</ul>
<p>これらの機能は、app： <cite>Pyramid`の作成者にとって重要です。 ：app： `Pyramid`の著者は、しばしばCMSスタイルのアプリケーションを構築するよう依頼されます。そのようなアプリケーションは、複数のデプロイメントを持つため、しばしば枠組み的です。各デプロイメントでは、サブアプリケーションの構成が若干異なりますが、フレームワークとサブアプリケーションはしばしば拡張可能である必要があります*。アプリケーションには複数のデプロイメントが存在するため、アプリケーションごとに1つずつ複数のフォークを維持することは非常に望ましくないため、プラグインと拡張性は重要です。 ：term： `traversal`を使用するシステムを、term：</cite> URL dispatch`を使用するシステムで同じことをするよりも簡単に拡張できるので、各デプロイメントは：term： <cite>resource tree`を使用しますドメインモデルオブジェクトの永続的なツリーのうちの1つを使用し、term： `traversal`を使用してツリー内のリソースにmap：term：</cite> call callable`コードをマッピングします。リソースツリーには、リソースがさまざまなユーザーセットによって所有され、アクセス可能なため、非常にきめ細かなセキュリティ宣言が含まれています。インタフェースはユニットテストと実装の代用性を容易にするために使用されます。</p>
<p>カスタムWebアプリケーションでは、通常、単一の標準的なデプロイメントが存在するため、複数のコードフォークの可能性はありません。拡張性は必要ありません。コードはちょうどその場所で変更されます。セキュリティ要件は、しばしばそれほど細かくはありません。上記の機能を使用すると、そのようなアプリケーションでは過度の負荷となることがよくあります。</p>
<p>これらの機能が気に入らなければ、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`を使うことはできません。彼らはすべてオプションで、多くの時間があなたの前で彼らについて知る必要がないことを確認するのに費やされてきました。上記の機能を無視することによって純粋に別注されている：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`を使って&amp;quot; Pylons 1.X style &amp;quot;アプリケーションをビルドすることができます。これらの機能は、後で普及し、複数の場所に展開する必要があるため、拡張性が必要な別注のWebアプリケーションを作成した後に便利です。</p>
</div>
<div class="section" id="pyramid-is-too-big">
<h2>ピラミッドが大きすぎます<a class="headerlink" href="#pyramid-is-too-big" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>&amp;quot;The：app：` Pyramid`圧縮されたtarballは2MB以上です。</p>
<p>いいえ、ドキュメント、テストコード、スキャフォールディングで出荷します。パッケージツリーのサブディレクトリに含まれるものの内訳を次に示します。</p>
<p>docs /</p>
<blockquote>
<div>3.6MB</div></blockquote>
<p>ピラミッド/テスト/</p>
<blockquote>
<div>1.3MB</div></blockquote>
<p>ピラミッド/足場/</p>
<blockquote>
<div>133KB</div></blockquote>
<p>ピラミッド/（「ピラミッド/テスト」と「ピラミッド/スキャフォールド」を除く）</p>
<blockquote>
<div>812KB</div></blockquote>
<p>パッケージ内の約34K行のPythonコードのうち、テストやPythonファイルの足場を除いて、通常の動作中に実際に実行する可能性のあるコードは、約10K行を占めます。</p>
</div>
<div class="section" id="pyramid-has-too-many-dependencies">
<h2>ピラミッドに依存性が多すぎる<a class="headerlink" href="#pyramid-has-too-many-dependencies" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>時間の経過とともに、ピラミッドが持っていたパッケージ依存性の数を減らすことについて、多くの進歩を遂げました。ピラミッド1.2には15種類ありました。ピラミッド1.3と1.4には12個のピラミッドがありました。この執筆時点での現在のリリース、Pyramid 1.5にはわずか7しかありません。この数字はそれほど小さくなる可能性は低いです。</p>
<p>Pyramid 1.3で完成したPython 3への移植は、より良いパッケージングの決定を下すことによって、多くの依存関係を解消するのに役立ちました。 1.5のPyramidコアにおけるChameleonとMakoのテンプレートシステムの依存関係を削除することで、残りの部分の大半が解放されました。</p>
</div>
<div class="section" id="pyramid-cheats-to-obtain-speed">
<h2>Pyramid &amp;quot;Cheats &amp;quot;で速度を得る<a class="headerlink" href="#pyramid-cheats-to-obtain-speed" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>苦情はさまざまな時に他のWebフレームワークの著者によって提出されました：app： <cite>Pyramid</cite> &amp;quot; cheats &amp;quot;がパフォーマンスを得る1つの主張されている不正行為のメカニズムは、mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>zope.interface`によって提供されるCの拡張機能を（高速で）使用する（推移的に）ものです。別の主張されている不正行為のメカニズムは、無関係の機能呼び出しの宗教的回避です。</p>
<p>より良いパフォーマンスを得るために不正行為があるようなことがあれば、私たちは可能な限りチートしたい。我々は：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`を積極的に最適化します。これはコストがかかります。コアコードには、読みやすくするためのセクションがあります。改善として、我々はこれらのセクションを自由にコメントした。</p>
</div>
<div class="section" id="pyramid-gets-its-terminology-wrong-mvc">
<h2>ピラミッドの用語が間違っている（&amp;quot;MVC &amp;quot;）<a class="headerlink" href="#pyramid-gets-its-terminology-wrong-mvc" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>&amp;quot;私はMVCのWebフレームワークのユーザーで、混乱しています：app：` Pyramid`はコントローラをビューと呼びます！コントローラはありません。</p>
<p>このキャンプにいるなら、既存のMVCフレームワークがその用語をどのように使用しているかを期待するかもしれません。たとえば、モデルはORMモデルであり、コントローラはURLにマップするメソッドを持つクラスであり、ビューはテンプレートです。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`にはこれらの概念があり、既存のMVCフレームワークとほぼ同じように機能します。私たちはMVC用語を使用しません。ウェブフレームワークでの使用を歴史的な現実に合わせることができないからです。</p>
<p>人々は、似たような用語を使用してWebアプリケーションに共通のデスクトップGUIプラットフォームと同じプロパティを与え、共通のWebフレームワーク内のさまざまなコンポーネントがどういった方法でハングアップしているかを示すフレームを提供したいと思っています。しかし、作者の意見では、&amp;quot;MVC はウェブとよくよくマッチしません。モデルビューコントローラーWikipediaのエントリー&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_：</p>
<blockquote>
<div><p>MVCはさまざまな種類がありますが、制御フローは一般的に次のとおりです。</p>
<blockquote>
<div><p>ユーザーは何らかの方法でユーザーインターフェイスとやり取りします（たとえば、マウスボタンを押します）。</p>
<p>コントローラは、多くの場合、登録されたハンドラまたはコールバックを介してユーザインタフェースからの入力イベントを処理し、そのイベントを適切なユーザアクションに変換します。</p>
<p>コントローラは、モデルにユーザアクションを通知します。その結果、モデルの状態が変更される可能性があります。 （たとえば、コントローラがユーザのショッピングカートを更新する）[5]</p>
<p>ビューは、適切なユーザーインターフェイスを生成するためにモデルをクエリします（たとえば、ビューにはショッピングカートのコンテンツが一覧表示されます）。ビューはモデルから独自のデータを取得することに注意してください。</p>
<p>コントローラは、（いくつかの実装では）それ自体をレンダリングするための一般的な命令をビューに発行することができる。他のものでは、画面の更新を必要とする状態の変化のモデル（Observer）によって自動的に通知が通知されます。</p>
<p>ユーザーインターフェイスは、さらにユーザーの操作を待って、サイクルを再開します。</p>
</div></blockquote>
</div></blockquote>
<p>作者にとっては、このウィキペディアの定義を編集した人が、現在のWebフレームワークで「MVC」という用語の使用を説明するために可能な最も一般的な用語でコンセプトを酷使しているかのように思えます。このような幅広い定義が、MVCパターンの原作者がこれまでに同意するとは思っていません。しかし、* MVCのWebフレームワークのほとんどは、この誤ったジェネリック定義でさえも満たされていないようです。</p>
<p>たとえば、テンプレート（ビュー）は、「ビューがモデルから独自のデータを取得することに注意してください」と主張されているように、モデルを直接クエリしますか？おそらくそうではありません。私の &amp;quot;制御部&amp;quot;はこれを行う傾向があり、データを &amp;quot;ビュー&amp;quot;（テンプレート）で使いやすくするためにマッサージします。 &amp;quot;コントローラ&amp;quot;がJSONを返すときはどうしますか？あなたのコントローラはJSONを生成するためにテンプレートを使用していますか？もしそうでなければ、&amp;quot;view &amp;quot;は何ですか？ほとんどのMVCスタイルのGUI Webフレームワークには、モデルの変更時にビューが検出できるようにする何らかの種類のイベントシステムがあります。ウェブには、そのような機能は現在の形ではありません。効果的にプルのみです。</p>
<p>したがって、現実と欲望を誤解しないようにするために、「MVC」の丸穴にウェブであるスクエアペグを詰め込もうとするのではなく、リソースと見解という2つのことがあります。リソースツリーはサイト構造を表し、ビューはリソースを表します。テンプレートは実際には任意のビューの実装の詳細です。ビューは応答を返すためのテンプレートを必要としません。 &amp;quot;コントローラ&amp;quot;はありません。それだけでは存在しません。 &amp;quot;model &amp;quot;は、リソースツリーまたは（ &amp;quot;SQLAlchemy&amp;quot;モデルのように）フレームワークとは別の&amp;quot;ドメインモデル&amp;quot;によって表現されます。これはウェブの現在の制約を考えると、より合理的な用語が好きなようです。</p>
</div>
<div class="section" id="pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility">
<span id="apps-are-extensible"></span><h2>ピラミッドアプリケーションは拡張可能です。私はアプリケーションの拡張性を信じていない<a class="headerlink" href="#pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Any：app： <cite>Pyramid`アプリケーションは特定の制約に従って書かれています*拡張可能です*。この機能については、：app： `Pyramid`のドキュメンテーションのchapter：ref：</cite> extend_chapter`と：ref： <cite>advconfig_narr`で説明します。 app： `Pyramid`の中で、：term：</cite> Zope Component Architecture`を使うことで可能になりました。</p>
<p>この文脈では、「拡張可能」とは、</p>
<ul class="simple">
<li>デプロイヤーが元のアプリケーションのソースを変更することなく、アプリケーションの動作をアプリケーションの特定のデプロイメント*でオーバーライドまたは拡張することができます。</li>
<li>元の開発者は、基本的なアプリケーションの動作を上書きまたは拡張できるように、アプリケーション作成時に拡張プラグインポイントを予測する必要はありません。</li>
<li>元の開発者は、アプリケーション固有のプラグポイントのセットを予期することを任意に選択することができます。プラグポイントは、デプロイヤによってフックされることがあります。 ZCAが提供する機能を使用することを選択した場合、元の開発者は、このようなプラグポイントを導入する仕組みについて深刻に考える必要はありません。</li>
</ul>
<p>多くの開発者は、拡張可能なアプリケーションを作成する価値がないと信じているようです。代わりに、それぞれの展開で特定のアプリケーションのソースを変更して、動作を上書きする方がより合理的であることを示唆しています。バージョン管理の分岐とマージに関する多くの議論が一般的に続いています。</p>
<p>すべてのアプリケーションを拡張可能にする必要はないことは明らかです。 Webアプリケーションの大部分は単一の配備しか持たないため、拡張する必要は全くありません。しかし、いくつかのWebアプリケーションには複数のデプロイメントがあり、他のものには*多くのデプロイメントがあります。例えば、一般的なコンテンツ管理システム（CMS）は、特定の展開のために拡張される必要がある基本機能を有することができる。そのCMSは、多くの組織で多くの場所に展開できます。このCMSのいくつかの展開は、サードパーティによって集中的に展開され、グループとして管理されます。システムの各ソフトウェアブランチを上流のソースと同期させ続けるよりも、あらかじめ定義されたプラグポイントを使用して、展開ごとにそのようなシステムを拡張する方が簡単です。上流の開発者は、同じコードベースへの変更が邪魔にならないようにコードを変更する可能性があります。このような変更を展開のライフサイクル全体にわたって繰り返していることは困難で時間がかかることがありますが、侵入の少ない方法で特定の展開のアプリケーションを変更できるようにすることはしばしば役に立ちます。</p>
<p>app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションの拡張性について全く考えたくなければ、あなたはそうする必要はありません。あなたは完全に拡張性を無視することができます。しかし、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>extends_chapter`で定義された一連の規則に従えば、アプリケーションを拡張可能にする必要はありません。 <em>あなたがフレームワークで書くアプリケーションは、基本レベルで自動的に拡張可能です</em>。デプロイヤーがそれを拡張するために使用するメカニズムは必然的に粗いでしょう。通常、ビュー、ルート、およびリソースはオーバーライドすることができます。しかし、ほとんどのマイナーな（そしていくつかの主要な）カスタマイズでは、必要なオーバーライドプラグポイントが必要な場合があります。アプリケーションがデプロイメントが必要とするものを正確に実行できない場合は、デプロイヤーがビュー、ルート、またはリソースをオーバーライドして、元の開発者が必ずしも予期しない方法ですばやく実行できるようにすることがよくあります*。このような機能の利点を示すいくつかのシナリオの例を以下に示します。</p>
<ul class="simple">
<li>デプロイメントに異なるスタイルが必要な場合、デプロイヤーはメインテンプレートとCSSを、オーバーライドを定義する別のPythonパッケージでオーバーライドすることができます。</li>
<li>デプロイメントが何か別のことをするためにアプリケーションページを必要とする場合や、より多くの情報や異なる情報を公開する必要がある場合、デプロイヤーはページを別のPythonパッケージにレンダリングするビューをオーバーライドする可能性があります。</li>
<li>デプロイメントに追加機能が必要な場合、デプロイヤーはオーバーライドパッケージにビューを追加できます。</li>
</ul>
<p>上流パッケージの基本設計が変更されない限り、これらのタイプの変更は、上流パッケージの多くのリリースにわたって再訪する必要なくしばしば生き残ります。</p>
<p>アプリケーションを外部に拡張することは万能薬ではなく、分岐やマージに似た一連のリスクを伴います。アップストリームの大きな変更により、いくつかの変更を再訪して更新することがあります。しかし、アプリケーションを外部に拡張すると、テキストマージが行われないため、アップストリームパッケージを更新するときに、しばしばアップストリームパッケージの些細な変更が伴う無意味なテキストマージの競合に対処する必要はありません。あなたの修正は、それが価値があるものであっても、正式な、明確に定義された1つの場所に含まれます。</p>
<p>新しい機能やバグ修正を得るために、アプリケーションを分岐して継続的にマージすることは、明らかに便利です。 ：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`アプリケーションを使って、アプリケーションと同じように便利に行うことができます。しかし、app：Pyramidで書かれたアプリケーションをデプロイすると、アプリケーションが先にプラグポイントを定義しなくても、この必要性を避けることができます。競合するWebフレームワークのプロモーターは、選択したフレームワークで書かれたアプリケーションが比較的基本的な方法で拡張できないため、ブランチングやマージのためにこの機能を却下する可能性があります。</p>
<p>while：app： <cite>Pyramid`アプリケーションは、あなたが特定の拡張性を念頭に置いていなくても基本的に拡張可能ですが、あなたが中程度の冒険をしているならば、さらに進歩を遂げることができます。 ：term： `Zope Component Architecture`についてもっと学ぶならば、オプションでそれを使って、アプリケーション開発中に他のドメイン固有の設定プラグポイントを公開することができます。公開するプラグポイントは、app： `Pyramid`自身によって自動的に提供されるプラグポイントほど粗くする必要はありません。例えば、事前に焼いた目的（例えば `</cite> restview``など）のために一連のビューを設定する独自の指示文を作成し、 `` includeme &amp;#39;&amp;#39;で宣言するときに他の人がその指示文を参照できるようにすることができます``のカスタマイズパッケージに含まれています。これにはコストがかかります。デプロイヤのカスタムプラグポイントを定義するアプリケーションの開発者は、ZCAを理解する必要があります。あるいは、独自の同様の拡張性システムを開発する必要があります。</p>
<p>最終的に、app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`によってアプリケーションに貸し出される拡張性機能が良いか悪いかについての議論は、ほとんど無意味です。特定の：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`アプリケーションが提供する拡張機能を利用する必要はありません。特定の配備セットの変更に影響を与えるためです。アプリケーションの拡張性のプラグポイントを完全に無視し、他のWebフレームワークを使用して作成されたアプリケーションを展開する場合と同様に、バージョンコントロールの分岐とマージを使用してアプリケーションの展開の変更を管理できます。</p>
</div>
<div class="section" id="zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not">
<h2>Zope 3は&amp;quot;TTW &amp;quot;認証チェックをデフォルトで強制します。ピラミッドはしません<a class="headerlink" href="#zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="challenge">
<h3>チャレンジ<a class="headerlink" href="#challenge" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：app： <cite>Pyramid`はterm：</cite> view`の実行時間でのみ自動権限チェックを行います。 Zope 3はコンテキストオブジェクトをセキュリティプロキシで囲みます。これにより、Zope 3は属性アクセス中にセキュリティチェックを行います。私はこれが好きなのです。</p>
<ol class="arabic simple">
<li>セキュリティプロキシマシンを使用すると、特定のHTML要素（フォームフィールドなど）を条件付きで表示するビューを持つことができます。また、アクセスするユーザーがコンテキストオブジェクトに対して所有するアクセス許可に応じて特定の属性が変更されないようにできます。</li>
<li>また、Twisted Webを使用してREST APIを介してリソースを公開したいと考えています。 PyramidがZope3のセキュリティプロキシを介して属性アクセスに基づいて権限を実行した場合、私はapp：PyramidとTwistedベースのシステムの両方で認証ポリシーを適用することができます。</li>
</ol>
</div>
<div class="section" id="defense">
<h3>防衛<a class="headerlink" href="#defense" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：app： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pyramid`はZope 2に慣れ親しんでいる人たちが開発しました.Zope 2には、Web経由のセキュリティモデルがあります。このTTWセキュリティモデルは、Zope 3のセキュリティプロキシの前身でした。時間の経過とともに、：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`開発者（Zope 2で働いている）がこのようなサイトを作ったので、コード解釈中の権限チェックが少数のプロジェクトで非常に有用であることがわかりました。しかし、多くの場合、TTW認可チェックは通常、委任要件がないプロジェクトの開発速度を遅くしました。特に、信頼できないユーザーがアプリケーションで実行される任意のPythonコードを書くことを許可していない場合、Webセキュリティチェックによる負担はあまりにもコストがかかり、正当化することができませんでした。私たちは（総称して）信頼できない開発者が長年に渡ってコードを書くことを許可されたアプリケーションを作成していないので、このモデルをデフォルトで新しいWebフレームワークにドロップするのが理にかなっていたようです。</p>
<p>また、すべてのWebアプリケーションに同じツールキットを使用する傾向があるため、2つの異なるWebフレームワークで同一の制限付き実行コードセットを使用できるようになることは決して懸念されていません。</p>
<p>Zope 3のセキュリティー・プロキシがウイルス性であることを考慮すると、デフォルトでセキュリティー・プロキシーを無効にすることの妥当性については、セキュリティー・プロキシー内に単一のオブジェクトをラップして、プロキシのセキュリティチェックが行われます。特定のアプリケーションの：app： <cite>Pyramid`トラバーサをオーバーライドすることができます（ref：</cite> changing_the_traverser`を参照）。 Zope3のような振る舞いをするには、トラバーサルされた各オブジェクト（：term： <cite>context`と：term：</cite> root`を含む）に対してZope3-security-proxy-wrappedオブジェクトを返す別のトラバーサーを接続することができます。これは、Zope3のような環境を多くの努力なしに作り出す効果があります。</p>
</div>
</div>
<div class="section" id="pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc">
<span id="http-exception-hierarchy"></span><h2>Pyramidは、mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>webob.exc`ではなく、独自のHTTP例外クラス階層を使用します。<a class="headerlink" href="#pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<p>：mod： <cite>pyramid.httpexceptions`で定義されているHTTP例外クラスは：mod：</cite> webob.exc`で定義されたものと非常によく似ています（例：：class： <cite>〜pyramid.httpexceptions.HTTPNotFound`または：class：</cite> 〜pyramid.httpexceptions.HTTPForbidden`）。それらは同じ名前でほぼ同じ動作をしており、すべて同じような実装ですが、同一のアイデンティティではありません。ここに彼らは別のアイデンティティを持っている理由です。</p>
<ul class="simple">
<li>それらを別々にすることで、HTTP例外クラスがclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>pyramid.response.Response`のサブクラス化を行うことができます。これは、ピラミッドルータの仕組みのせいで、応答の生成をわずかに高速化します。 monkeypatching：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>webob.response.Response`でも同じスピードアップが得られるかもしれませんが、通常は、monkeypatchingが悪いと間違っていることが判明します。</li>
<li>それらを別々にすることで、代替の `` __call__``ロジックを提供することができます。これによりレスポンスの生成も高速化されます。</li>
<li>それらを分離することで、例外クラスは `` RequestClass``（：class： <cite>pyramid.request.Request</cite>）の適切な値を提供することができます。</li>
<li>それらを別々にすると、Pyramid 1.1以降ではサポートしていないPython 2.4に関連するmod： <a href="#id1"><span class="problematic" id="id2">`</span></a>webob.exc`という下位互換性コードについて考えることができなくなりました。</li>
<li>モジュール内の2つのクラス（：class： <cite>〜pyramid.httpexceptions.HTTPNotFound`と：class：</cite>〜pyramid.httpexceptions.HTTPForbidden`）を `` notfound``のために内部的にPyramidで使用できるように変更します「禁じられた」例外を含む。</li>
<li>それらを別々にすることで、Pyramid固有のドキュメントを提供するために例外クラスのドキュメントストリングに影響を与えることができます。</li>
<li>それらを別々にすることで、応答オブジェクトが（ `` self.message``に関連して）例外として使われるとき、Python 2.6の下で愚かな非推奨警告を静かにすることができます。</li>
</ul>
</div>
<div class="section" id="pyramid-has-simpler-traversal-machinery-than-does-zope">
<span id="simpler-traversal-model"></span><h2>ピラミッドはZopeよりも単純なトラバーサル機構を持っています<a class="headerlink" href="#pyramid-has-simpler-traversal-machinery-than-does-zope" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Zopeのデフォルトトラバース：</p>
<ul class="simple">
<li>開発者がトラバース中にトラバーサル名のスタックを変更することを許可します（パス要素の追加と削除が可能です）。</li>
<li>現在トラバースされているオブジェクトからパス内の次の要素を取得し、 `` __bobo_traverse__``、 `` __getitem__``、そして最終的に `` __getattr__``にフォールバックするためにアダプテーションを使用しようとします。</li>
</ul>
<p>Zopeのデフォルトのトラバーサでは、開発者は <cite>&amp;#39;REQUEST [&amp;#39;TraversalNameStack&amp;#39;]</cite> <cite>を変更することによって、トラバース中にトラバース名のスタックを変更することができます。 Pyramidのデフォルトのトラバーサ（ `</cite> pyramid.traversal.ResourceTreeTraverser``）はこれを行う方法を提供していません。要求属性としてスタックを保持せず、それが実行されても、移動中のリソースオブジェクトに要求を渡しません。この機能は時に便利でしたが、Zope（CMFやPloneのような）の上に構築されたフレームワークでは悪用され、しばしばトラバーサルがビューに一致しなかったときに何が起こったのかを正確に伝えることが難しくなりました。私はそれがデフォルトトラバーサーに特定の蜂蜜の鍋を構築するよりもむしろtraverserを置き換えるように機能を望んでいる人々の方が良いと感じました。</p>
<p>Zopeは、複数のメカニズムを使用して、名前に基づいてリソースツリー内の次の要素を取得しようとします。現在のリソースを `` ITraversable``に適合させようと試みます。失敗した場合は、リソース（ `` __bobo_traverse__``、 `` __getitem__``、 `` __getattr__``）。 Zopeを使って、 `` repoze.zope2``で出版社を再実装しようとしている私の経験は、私が次のように信じてくれました。</p>
<ul class="simple">
<li><a href="#id1"><span class="problematic" id="id2">*</span></a>デフォルトのトラバーサーはできるだけシンプルでなければなりません。 Zopeのパブリッシャーは、1つのトラバーサルメソッドが失敗したときに試みたフォールバックのために、追跡して複製することは多少困難です。それはまた遅いです。</li>
<li>トラバーサルマシンの要素だけでなく、トラバーサ全体*も置き換え可能でなければなりません。ピラミッドには小さなものがたくさんあるのではなく、いくつかの大きな要素があります。トラバーサ全体が交換可能な場合は、デフォルトのトラバーサの一部を交換可能にする反パターンです。そうすることは&amp;quot;ノブのつまみ&amp;quot;パターンであり、残念なことにZopeでは風土病です。ノブのノブのパターンでは、大きなコンポーネントの交換可能なサブコンポーネントは、大きなコンポーネントを置き換えるのに使用できるのと同じ構成メカニズムを使用して構成可能になります。たとえば、Zopeでは、アダプターを登録することによってデフォルトのトラバーサーを置き換えることができます。しかし、1つまたは複数のアダプタを登録することによって、デフォルトのトラバーサがどのようにトラバースするかを制御することもできます（または代わりに）。より大きなコンポーネントを完全に置き換えたり、大きなコンポーネントのデフォルトの実装でノブを回すことができた結果、大きなコンポーネントをいつでも上書きする必要があるかどうかは誰も理解できません。これは時間が経つにつれて、より大きな「交換可能な」コンポーネントとフレームワーク自体の錆びた状態になります。なぜなら、人々はノブを回すだけでデフォルトコンポーネントの可用性に依存するからです。デフォルトのコンポーネントは事実上フレームワークの一部になり、フレームワークは交換可能にするという目標を完全に打ち消します。ピラミッドでは、通常、コンポーネントが置換可能な場合、それ自体にはノブはありません（ソリッドステートになります）。そのコンポーネントによって制御される振る舞いに影響を与えたい場合は、そのコンポーネントに接続されたノブを回すのではなく、そのコンポーネントを置き換えます。</li>
</ul>
</div>
<div class="section" id="microframeworks-have-smaller-hello-world-programs">
<span id="microframeworks-smaller-hello-world"></span><h2>マイクロフレームワークでは、より小さなHello Worldプログラム<a class="headerlink" href="#microframeworks-have-smaller-hello-world-programs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>自己記述された&amp;quot;microframeworks &amp;quot;が存在する。 <cite>ボトル&lt;http://bottlepy.org/docs/dev/index.html&gt; `_と</cite> Flask &lt;<a class="reference external" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_は人気が高まっている2つです。ボボ&lt;<a class="reference external" href="https://bobo.readthedocs.io/en/latest/">https://bobo.readthedocs.io/en/latest/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_はマイクロフレームワークとは言いませんが、その意図するユーザー基盤はほとんど同じです。他にも多くのものが存在する。我々は（公式のプロジェクトのようなものではなく、教えのツールとしてのみであっても） <a href="#id5"><span class="problematic" id="id6">`</span></a>Pyramid &lt;<a class="reference external" href="http://static.repoze.org/casts/videotags.html">http://static.repoze.org/casts/videotags.html</a>&gt; <a href="#id7"><span class="problematic" id="id8">`</span></a>_。このビデオはPyramidの前身であるBFGを使用していますが、結果のコードはPyramidでも利用可能です&lt;<a class="reference external" href="https://github.com/Pylons/groundhog">https://github.com/Pylons/groundhog</a>&gt; <a href="#id9"><span class="problematic" id="id10">`</span></a>_）。 Microframeworksは小さなフレームワークで、共​​通の機能を1つ備えています。それぞれの機能を使用すると、1つのPythonファイルに完全に機能するアプリケーションを作成できます。</p>
<p>いくつかの開発者とマイクロフレームワークの著者は、ピラミッドの ​​&amp;quot;hello world&amp;quot;単一ファイルプログラムは、好きなマイクロフレームワークの同等のプログラムより長い（約5行で）ことを指摘しています。帯電したとして有罪。</p>
<p>この損失は試行の欠如のためではありません。ピラミッドは、マイクロファイルワークが優位性を主張しているのと同じ状況、すなわちシングルファイルアプリケーションでも役に立ちます。しかし、ピラミッドは、現在のマイクロフレームワークとのコード・パリティの &amp;quot;hello world&amp;quot;ラインを達成するために、より大きなアプリケーションを信頼できる形でサポートする能力を犠牲にすることはありません。代わりにPyramidの設計は、素朴な宣言的構成スキームに関連するいくつかの一般的な落とし穴を回避しようとしています。以下のサブセクションでその根拠を説明します。</p>
<div class="section" id="application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil">
<span id="you-dont-own-modulescope"></span><h3>アプリケーションプログラマはモジュールスコープコードパスを制御しません（インポート時の副作用は悪です）<a class="headerlink" href="#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一連のPythonファイルを含むディレクトリ構造を想像してみてください。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>.
|-- app.py
|-- app2.py
`-- config.py
</pre></div>
</div>
<p>`` app.py``の内容：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">decorator</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">L</span>
<span class="kn">import</span> <span class="nn">pprint</span>

<span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">app2</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>`` app2.py``の内容：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">app</span>

<span class="nd">@app.decorator</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
<p>`` config.py``の内容：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>
</pre></div>
</td></tr></table></div>
<p>これらのファイルを保持しているディレクトリに対して `` cd``を実行し、上記のディレクトリ構造とコードで `` python app.py``を実行すると、どうなりますか？おそらく、私たちの `` decorator``デコレータは `` app.py``内の `` foo``関数と `` app2.py``内の装飾関数 `` bar``の二回使用されるでしょう``。デコレータが使用されるたびに、 `` config.py``の `` L``が追加されているので、2つの要素を持つリストが印刷されると思いますよね？悲しいことに、</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[chrism@thinko]$ python app.py
[&lt;function foo at 0x7f4ea41ab1b8&gt;,
 &lt;function foo at 0x7f4ea41ab230&gt;,
 &lt;function bar at 0x7f4ea41ab2a8&gt;]
</pre></div>
</div>
<p>視覚的検査によって、その結果（リストの3つの異なる機能）は不可能と思われる。 2つの関数しか定義しなかったので、それらの関数をそれぞれ1回だけ飾ったので、 `` decorator``デコレータは2回しか実行されないと考えています。しかし、私たちが信じることは、実際には間違っています。なぜなら、私たちの `` app.py``モジュールのモジュールスコープのコードが* 2回*実行されたからです。このコードは、スクリプトが `` __main__``（ `` python app.py``を介して）で実行されると一度実行され、 `` app2.py``が `` app &amp;#39;&amp;#39;と同じファイルをインポートすると再び実行されます``。</p>
<p>これは、マイクロフレームワークとの比較とどう関係していますか？現在の作物の多くのマイクロフレームワーク（BottleやFlaskなど）では、モジュールスコープで定義されたオブジェクトにコンフィギュレーションデコレータをアタッチすることが推奨されています。これらのデコレータは、任意の複雑な登録コードを実行します。これは、外部Pythonモジュールで定義されたグローバルであるシングルトンレジストリにデータを読み込みます。これは上記の例に似ています：上の例の&amp;quot;グローバルレジストリ&amp;quot;はリスト &amp;quot;L&amp;quot;です。</p>
<p>同じパターンを <cite>Groundhog &amp;#39;で使うとどうなるか見てみましょう&lt;https://github.com/Pylons/groundhog&gt; `_マイクロフレームワーク。上記の `</cite> app.py``の内容を以下のように置き換えてください：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">gh</span>

<span class="nd">@gh.route</span><span class="p">(</span><span class="s1">&#39;/foo/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;foo&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">app2</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>上記の `` app2.py``の内容を以下のように置き換えてください：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">app</span>

<span class="nd">@app.gh.route</span><span class="p">(</span><span class="s1">&#39;/bar/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="s1">&#39;return bar&#39;</span>
</pre></div>
</td></tr></table></div>
<p>上記の `` config.py``の内容を以下のように置き換えてください：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;seekrit&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>&amp;quot;gh Groundhogアプリケーションのルーティングテーブルに登録されるルートはいくつですか？あなたが3つ答えた場合、あなたは正しいですか？カジュアルリーダー（および正常な開発者）は何人登録する予定ですか？あなたは正しいですか？ダブル登録は問題になりますか？Groundhogフレームワークの `` route``メソッドは、このアプリケーションをサポートしています。実際にはアプリケーションを遅くするでしょう。それは他のフレームワーク、別のアプリケーション、または別のデコレータで問題になるのでしょうか？誰が知っていますか？アプリケーション全体を理解し、フレームワーク全体と実行時間を予測できる必要があります。意図しないコードの二重実行の影響はどのようなものになりますか。</p>
<p>外部レジストリの配置を行うデコレータの使用を奨励すると、意図しない結果になります。アプリケーション開発者は、Pythonモジュールスコープコードを実行するすべてのコードパスの所有権をアサートする必要があります。モジュールスコープコードは、デコレータベースのマイクロフレームワークの現在の作物によって1回だけ実行されると推定されます。複数回実行すると、奇妙なことが起こり始めるでしょう。この不変量を維持するのはアプリケーション開発者次第です。残念ながら、実際には、これは不可能な作業です。なぜなら、Pythonプログラマ*はモジュールスコープのコードパスを所有していないからです。あなたがそうするという考えにあなたを売ろうとする者は、間違っているだけです。あなたのコードのテストを実行するために使用したいと思うかもしれないテストランナーは、上記のようなバグを明らかにする不思議な命令で任意のコードをインポートすることがよくあります。 APIドキュメント生成ツールも同じです。 Pythonの `` reload``コマンドを使うことや、 `` sys.modules``からオブジェクトを削除する方が安全だと思う人もいます。それぞれのオブジェクトは、インポート時に副作用があるコードに対して使用すると面白い効果があります。</p>
<p>したがって、グローバルレジストリを変更するマイクロフレームワークプログラマーは、前の段落のように、モジュールスコープコードが複数回実行された場合に発生する可能性のあることについて、お茶リーフを読んでいく必要があります。 Pythonプログラマがモジュールスコープのコードパスを使用して任意のコード（特に外部レジストリを埋め込むコード）を実行できると仮定すると、この仮定は現実に挑戦され、アプリケーション開発者はしばしば厄介なデバッグプロセスを踏まなければなりません。必然的にあいまいな症状の根本的な原因を突き止める。解決方法は、アプリケーションのインポート順序を並べ替えるか、モジュールスコープから関数本体にインポートステートメントを移動することがよくあります。これを行うための根拠は、修正に伴うコミットメッセージで決して適切に表現されることはありません。また、開発チームの残りの利益のために十分に簡潔に文書化することはできません。特に、 `` pdb``を使ってモジュールスコープコードを実行している間に学んだレッスンをまだ内部化していない他の人たちと一緒にプロジェクトに取り組んでいるなら、もう一度やり直してください。デコレータベースのマイクロフレームワークで提供されているドキュメントでは、あなたに警告していないため、あなたやあなたのチームが登録したことさえ知りませんでした。</p>
<p>外部データ構造（マイクロフレームワークの作成者など）を占有する熱心なデコレータベースの構成に多額の投資をしている人は、上記で概説した一連の状況は異常であり、人工的であると主張するかもしれません。彼らはそれが決して起こらないと主張するでしょう。アプリケーションが1つまたは2つまたは3つのモジュールを超えて成長することを決して意図していない場合は、おそらくそれが当てはまります。しかし、コードベースが拡大し、より多くのモジュールに分散されるにつれて、モジュールスコープコードが複数回実行される状況がますます起こりやすくなり、予期しにくくなります。モジュールスコープコードの二重実行が決して起こらないと主張する責任はありません。そうなる;運と時間とアプリケーションの複雑さの問題です。</p>
<p>マイクロフレーム作成者がその状況が考案されていないと認める場合、モジュールスコープコードの二重実行（または三重実行など）の結果として実際の損害は決して起こらないと主張するかもしれない。あなたはこの主張を信じないことが賢明でしょう。複数の実行の潜在的な結果は、アプリケーションとフレームワークコードの間の微妙な関係やコード実行の時系列が関係しているため、予期するには多すぎます。フレームワークの作者があらゆる状況で何が起こるかを知ることは、文字通り不可能です。しかし、いくつかの限られた状況に対して全知の贈り物が与えられたとしても、フレームワークの作者は、新機能をコーディングする際に、二重実行異常を念頭に置いていることはほとんどありません。彼らは機能を追加することを考えており、1％の多重実行の場合に起こりうる問題に対して保護しません。しかし、1％の症例では、プロジェクトの痛みの50％が発生する可能性があるため、発生していないといいでしょう。</p>
<p>責任あるマイクロフレームワークは、実際には問題の背後にある道を提供します。デコレータベースの設定を完全に廃止することができます。あなたに次のことを要求する代わりに：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="nd">@gh.route</span><span class="p">(</span><span class="s1">&#39;/foo/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;foo&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>デコレータの構文を廃止し、ほとんどすべての命令を実行することができます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;foo&#39;</span>

<span class="n">gh</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;/foo/&#39;</span><span class="p">)</span>
    <span class="n">gh</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>これはPyramidのドキュメントで推奨されている一般的な操作モードです。いくつかの既存のマイクロフレームワーク（特にフラスコ）はそれを可能にします。なし（ピラミッド以外）*それを奨励する*。アプリケーションが2〜3または4〜10のモジュールを超えて成長することを決して期待しない場合は、どのモードを使用するかはあまり関係ありません。ただし、アプリケーションが大きくなる場合は、必須の構成によって予測性が向上します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">鋭い読者は、Pyramidにも構成デコレータがあることに気付くかもしれません。ああ！これらのデコレータに同じ問題はありませんか？いいえ。これらのデコレータは、実行時に外部のPythonモジュールを生成しません。彼らは、それらが接続されている関数（およびクラスとメソッド）のみを変更します。これらの突然変異は、予測可能かつ構造化されたインポートフェーズを有するスキャンプロセス中に後に見つけ出さなければならない。モジュールローカライズされた突然変異は、実際には二重輸入の最良の状況です。モジュールがインポート時に自分自身とその内容を変更するだけであれば、それが2回インポートされてもOKです。なぜなら、各デコレータ呼び出しは、レジストリのような共有リソースではなく、添付されたオブジェクトの独立したコピーをモジュール。これは、二重登録が決して実行されないという効果を有する。</p>
</div>
</div>
<div class="section" id="routes-need-relative-ordering">
<span id="routes-need-ordering"></span><h3>経路には相対的な順序が必要<a class="headerlink" href="#routes-need-relative-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の単純な「Groundhog &lt;<a class="reference external" href="https://github.com/Pylons/groundhog">https://github.com/Pylons/groundhog</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_アプリケーション：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/admin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;admin page&lt;/html&gt;&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/:action&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_action</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;add&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;add&lt;/html&gt;&#39;</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;delete&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;delete&lt;/html&gt;&#39;</span>
    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>このアプリケーションを実行し、 `` / admin``のURLにアクセスすると、&amp;quot;admin &amp;quot;ページが表示されます。これが意図した結果です。ただし、ファイル内の関数定義の順序を並べ替えるとどうなりますか？</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">groundhog</span> <span class="kn">import</span> <span class="n">Groundhog</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Groundhog</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;seekrit&#39;</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/:action&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_action</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;add&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;add&lt;/html&gt;&#39;</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;delete&#39;</span><span class="p">:</span>
       <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;delete&lt;/html&gt;&#39;</span>
    <span class="k">return</span> <span class="n">app</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/admin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;html&gt;admin page&lt;/html&gt;&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>このアプリケーションを実行し、 `` / admin``というURLにアクセスすると、アプリケーションは404エラーを返します。これはおそらくあなたが意図したものではありません。関数定義の順序を並べ替えるときに404エラーが表示される理由は、マイクロフレームワークのルーティングデコレータを介して表現されたルーティング宣言に* ordering <a href="#id1"><span class="problematic" id="id2">*</span></a>があり、その順序付けが重要であるということです。</p>
<p>我々が期待した結果を得た最初のケ​​ースでは、最初にパターン `` / admin`を追加した後、デコレータを介してルーティングパターンを追加することでパターン `` /：action``を追加しましたモジュールスコープで`` / admin``の `` PATH_INFO``を持つリクエストがアプリケーションに入ると、Webフレームワークは私たちのモジュールで定義された順番で、それぞれのアプリケーションのルートパターンをループします。その結果、 `` / admin``ルーティングパターンに関連付けられたビューが最初に一致するため、呼び出されます。すべてが世界と正しかった。</p>
<p>2番目のケースでは、期待した結果が得られなかったので、最初にパターン `` /：action``を追加した後、パターン `` / admin``を追加しました。 `` / admin``の `` PATH_INFO``を持つリクエストがアプリケーションに入ると、Webフレームワークは私たちのモジュールで定義された順番で、それぞれのアプリケーションのルートパターンをループします。結果として、 `` /：action``ルーティングパターンに関連付けられたビューは最初に一致するため呼び出されます。 404エラーが発生します。これは私たちが望むものではありません。私たちがビュー機能を定義した順序のために起こったばかりです。</p>
<p>これは、Groundhogルートがインポート順にルーティングマップに追加され、リクエストが入ったときに同じ順序で一致するためです。この記事の時点で、GroundhogのようなBottleは、Pythonで定義されている順序でルートを照合します実行時間。一方、フラスコは輸入注文に基づいてルートマッチングを注文しません。代わりに、アプリケーションに追加するルートを&amp;quot;complexity &amp;quot;に基づいて並べ替えます。他のマイクロフレームワークでは、経路の順序付けを行うさまざまな戦略があります。</p>
<p>あなたのアプリケーションは、ルートの順序が問題を引き起こさないほど十分に小さいかもしれません。しかし、アプリケーションが十分に大きくなると、アプリケーションが大きくなるにつれて順序を指定したり予測したりすることが難しくなります。ある時点で、特に拡張性を必要とするアプリケーションでは、より明示的に経路順序を制御し始める必要があります。</p>
<p>あなたのマイクロフレームワークが複雑さに基づいてルートマッチングを注文する場合、&amp;quot;複雑さ&amp;quot;が意味するものを理解する必要があります。そして、 &amp;quot;より複雑ではない&amp;quot;ルートを注入して、それが最初に試されることを保証するために &amp;quot;より複雑な&amp;quot;ものを選択します。</p>
<p>あなたのマイクロフレームワークが、関数デコレータ定義の相対的なインポート/実行に基づいてルートマッチングを注文する場合は、これらのステートメントをすべて「右」の順序で実行する必要があります。このインポートを認識する必要がありますアプリケーションを拡張したり、拡張しようとすると、実行順序が変わることがあります。これは、最小のアプリケーション以外のすべてを維持するのは難しい不変量です。</p>
<p>どちらの場合でも、アプリケーションは、構成の飾りを含む <a href="#id1"><span class="problematic" id="id2">``</span></a>__main__``以外のモジュールを、何らかの形でそれらの構成が実行されるようにインポートする必要があります。それはあなたを少し不快にさせますか？これは、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>you_dont_own_modulescope`のためです。</p>
<p>Pyramidは、デコレータのインポート時間の順序付けも、経路の順序付けを定義する手段として、ある経路の相対的な複雑さを別の経路に割り当てることもしません。 Pyramidでは、：meth： <cite>pyramid.config.Configurator.add_route`メソッドを複数回実行することによって、相対的なルートの順序付けを命令的に維持する必要があります。 `</cite> add_route``を繰り返し呼び出す順序は、ルートマッチングの順番になります。</p>
<p>この必須命令を本当にバグのままにする必要がある場合、ルートマッチングの代わりに：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>traversal`を使うことができます。これはコードをURLにマップするための完全に宣言的な（完全に予測可能な）メカニズムです。小さな非拡張可能アプリケーションではURLディスパッチが理解しやすくなりますが、トラバーサルは、非常に大きなアプリケーションや任意に拡張可能なアプリケーションに最適です。</p>
</div>
<div class="section" id="stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance">
<span id="thread-local-nuisance"></span><h3>&amp;quot;スタックされたオブジェクトのプロキシ&amp;quot;があまりにも賢い/スレッドの地元の人は迷惑です<a class="headerlink" href="#stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかのマイクロフレームワークは、 `` import``ステートメントを使って、<em>論理的にグローバルではないオブジェクトへのハンドルを取得します</em>：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s1">&#39;Invalid username/password&#39;</span>
    <span class="c1"># this is executed if the request method was GET or the</span>
    <span class="c1"># credentials were invalid</span>
</pre></div>
</td></tr></table></div>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>Pylons 1.X &lt;<a class="reference external" href="https://docs.pylonsproject.org/projects/pylons-webframework/en/latest/">https://docs.pylonsproject.org/projects/pylons-webframework/en/latest/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_ web frameworkも同様の戦略を使用します。これは、これらのものを「スタックオブジェクトプロキシ」と呼びます。この議論の目的のために、私はそうするでしょう。</p>
<p>Pythonのimport文（ `` import foo``、 `` from bar import baz``）は、外部Pythonモジュール内でグローバルに定義されたオブジェクトへの参照を取得するために最も頻繁に実行されます。しかし、通常のプログラムでは、関数の本体のスコープで測定された有効期間を持つオブジェクトへの参照を取得することはありません。たとえば、関数の本体で定義されたループカウンタを表す `` i``という名前の変数をインポートしようとするのは不合理です。例えば、以下のコードから `` i``をインポートしようとはしません。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">afunc</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>その性質上、WSGIサーバーの長期間Webフレームワークへの呼び出しの結果として生成される* request <a href="#id1"><span class="problematic" id="id2">*</span></a>オブジェクトは、グローバルにすることはできません。単一の要求の存続期間は、実行中のプロセスの存続期間フレームワーク。 Webフレームワークによって作成されたリクエストオブジェクトは、Python標準ライブラリまたは通常のライブラリコードで定義されている同等のインポート可能なオブジェクトよりも、上記の例の `` i``ループカウンタと実際に類似しています。</p>
<p>しかし、スタックされたオブジェクトプロキシを使用するシステムでは、 <a href="#id1"><span class="problematic" id="id2">``</span></a>要求 &amp;#39;&amp;#39;のようなローカルスコープのオブジェクトをモジュールスコープに送り出して、 `` import``を含む素晴らしいスペルをユーザに提供することを目的としています。彼らは私が疑わしい理由を考えると、myframework.threadlocals import get_requestからsanerを使うのではなく、 <a href="#id3"><span class="problematic" id="id4">``</span></a>フレームワークインポート要求から <a href="#id5"><span class="problematic" id="id6">``</span></a>要求 &amp;#39;&amp;#39;を得る標準的な方法をユーザに提示するだろう。 request = get_request（） <a href="#id7"><span class="problematic" id="id8">``</span></a>のようになります。</p>
<p>マイクロフレームワークがスレッドローカル変数をまったく使用していない場合は、* most * explicitになります。ピラミッドビュー関数はリクエストオブジェクトに渡されます。 PyramidのAPIの多くは、明示的な要求オブジェクトを渡す必要があります。現在のピラミッド要求をスレッドローカル変数として取り出すことは可能ですが、緊急の場合には &amp;quot;ブレークグラス&amp;quot;タイプのアクティビティです。この設定では、テストセットアップ中に適切な&amp;quot;ダミー&amp;quot;要求（および同様のスコープを持つ）オブジェクトを作成するためにフレームワークに頼る必要がないため、ピラミッドビュー機能をより簡単にユニットテスト可能にしています。また、非同期サーバなどの、モノスケッチをしない任意のシステムで動作する可能性が高くなります。</p>
</div>
<div class="section" id="explicitly-wsgi">
<span id="id2"></span><h3>明示的にWSGI<a class="headerlink" href="#explicitly-wsgi" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかのマイクロフレームワークは、簡単な実行のためにデフォルトのサーバ設定を実行するアプリケーションオブジェクトの `` run（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドを提供します。</p>
<p>Pyramidは現在、ルータが便利な `` run（） `` APIの後ろにあるWSGIアプリケーションであるという事実を隠そうとしていません。これは、WSGIサーバーをインポートし、そのWSGIサーバーのドキュメントに従ってPyramidアプリケーションを提供するために、WSGIサーバーをインポートするように指示します。</p>
<p>`` run（） <cite>の後ろで提供ステップを抽象化することで節約された余分な行は、いくつかのマイクロフレームワークでそのAPIに関連する疑わしい2次的決定を引き起こしたようです。たとえば、Bottleには、 `</cite> app.run（） <code class="docutils literal notranslate"><span class="pre">メカニズムを介してサポートされているWSGIサーバのタイプごとに、</span> <span class="pre">``</span> <span class="pre">ServerAdapter``サブクラスが含まれています。これは</span> <span class="pre">``</span> <span class="pre">wsgiref</span></code>、 `` flup``、 `` paste``、 `` cherrypy``、 `` fapws``モジュールに依存する `` bottle.py``にコードが存在することを意味します。 `` google.appengine``、 `` twisted.web``、 `` diesel``、 `` gevent``、 `` gunicorn``、 `` eventlet``、 <a href="#id1"><span class="problematic" id="id2">``</span></a>ロケット。 `` run``メソッドに名前を渡すことで、実行したいサーバの種類を選択します。理論的には、これはすばらしいことです：私は `` gunicorn``のボトルを名前を渡すだけで試すことができます！ただし、ボトルを完全にテストするには、これらのサードパーティシステムをすべてインストールして機能させる必要があります。ボトルの開発者は、これらのパッケージのそれぞれに対する変更を監視し、コードが依然としてそれらと適切にインターフェースしていることを確認する必要があります。これにより、テストに必要なパッケージの数が大幅に増えます。これは要件の*ロット*です。要件の競合やビルドの問題により、これらのテストを完全に自動化することは難しいでしょう。</p>
<p>その結果、単一ファイルのアプリケーションの場合、現在 `` run（） <a href="#id1"><span class="problematic" id="id2">``</span></a>ショートカットを提供することに煩わされることはありません。私たちは、選択したWSGIサーバーをインポートし、手動で実行するように指示します。サーバー抽象化レイヤーが必要な人にとっては、PasteDeployを使用することをお勧めします。 PasteDeployベースのシステムでは、サーバーがWSGIアプリケーションとインターフェイスできることを確認するための責任は、Webフレームワークの開発者ではなく、サーバーの開発者に配置されるため、タイムリーかつ正確になる可能性が高くなります。</p>
</div>
<div class="section" id="wrapping-up">
<h3>ラッピング<a class="headerlink" href="#wrapping-up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ここでは、最も単純なピラミッドアプリケーションのダイアグラムを示します。ここでは、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>microframeworks_smaller_hello_world`セクションで説明したインラインコメントが考慮されています。</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>  <span class="c1"># explicitly WSGI</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>  <span class="c1"># to configure app registry</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>  <span class="c1"># explicit response, no threadlocal</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>  <span class="c1"># accept a request; no request threadlocal reqd</span>
    <span class="c1"># explicit response object means no response threadlocal</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Configurator</span><span class="p">()</span> <span class="k">as</span> <span class="n">config</span><span class="p">:</span>    <span class="c1"># no global application object</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">)</span>  <span class="c1"># explicit non-decorator registration</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>  <span class="c1"># explicitly WSGI</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>            <span class="c1"># explicitly WSGI</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="pyramid-doesn-t-offer-pluggable-apps">
<h2>Pyramidはプラグイン可能なアプリケーションを提供していません<a class="headerlink" href="#pyramid-doesn-t-offer-pluggable-apps" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>複数の外部ソースを：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜pyramid.config.Configurator.include`を使って同じ設定に組み立てるのは&amp;quot; Pyramidic &amp;quot;です。アプリケーションの作成には、任意の数のインクルードを行うことができます。包含は他の包含の中からでも行うことができます。 1つのディレクティブはインクルード内で使用できます（：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜pyramid.config.Configurator.add_view`など）。</p>
<p>ピラミッドには競合検出システムがあり、含まれている2つの外部が同じ構成を競合する方法で追加しようとするとエラーが発生します（同じ名前を使用してルートを追加しようとしている外部もあれば、同じ述語セット）。このセットの機能を&amp;quot;プラグイン可能なアプリケーション&amp;quot;からシステムを構成するために使うことができるものと呼ぶのはひどく魅力的です。しかし実際には、これを主張することにはいくつかの問題があります。</p>
<ul class="simple">
<li>用語は緊張している。 Pyramidには複数の &amp;quot;アプリケーション&amp;quot;という概念はありません。単一のWSGIアプリケーションを作成するために複数のソースから構成を作成する方法です。そのWSGIアプリケーションは、構成を含めるか否かによって動作を得ることができますが、一度構成すると、ピラミッドは実際には、アプリケーションの境界を区切るために使用できる機械を提供しません外部からルート、ビューなどを追加する外部）。</li>
<li>Pyramidは真に正直な、神からの、無作為な場所からのダウンロード、プラグインの作成を可能にするのに十分な &amp;quot;レール&amp;quot;を提供していません。 -system &amp;quot;pluggable &amp;quot;アプリケーション。 Pyramid自体は（特定の種類のデータベースを要求するものではなく、URLをコードなどにマップするための複数の方法を提供します）、アプリケーションに似たものを作成する人は、 J. Random Pyramid Userであり、パッケージの機能をconfig.includeに依頼するだけで動作します。これは、ブログ、ウィキ、ツイッタークローン、コメントシステムなどの非常に高いレベルのコンポーネントに特に当てはまります。インテグレータ（&amp;quot;プラグ可能なアプリケーション&amp;quot;として宣伝されたパッケージをダウンロードしたPyramid開発者）は、彼がどのようなタイプの永続システムを使用しているかについての選択、および「プラグ可能なアプリケーション」の要件を緩和するためのインテグレータのために、彼は別のデータベースを設定し、プラグイン可能なアプリケーションのシャドウイング（またはその逆）、その他任意の数の変更が含まれます。</li>
</ul>
<p>このため、Pyramidにはプラグイン可能なアプリケーションではなく、 &amp;quot;拡張可能な&amp;quot;アプリケーションがあると主張しています。すべてのPyramidアプリケーションは、設定文が `` config.include``を介して取り込めるものに構成されていれば、それをフォークせずに拡張することができます。</p>
<p>単一の開発者やチームが、config.includeを使用して有効または無効にできる相互運用コンポーネントのセットを作成することも、まったく合理的です。その開発者またはチームは、プロジェクトを作成するために使用される技術について高いレベルの選択を行うことによって、&amp;quot;rails &amp;quot;を提供することができるので、すべてのコンポーネントを一緒に接続することに問題はありません。 Djangoは&amp;quot;プラグ可能なアプリケーション&amp;quot;と同様の問題を抱えていますが、これは多くの、より多くのレールを提供していますが、任意のサードパーティで動作する必要があることに注意してくださいn &amp;quot;プラグ可能なアプリケーション&amp;quot;の話を実際にローカルで修正することなく動作させるのに十分ではありません。</p>
<p>本当にプラグイン可能なアプリケーションは、Webフレームワークよりはるかに高いレベルで作成する必要があります。実際には、アプリケーションにプラグインする必要があります。これらの制約を提供し、アプリケーションをプラグインする方法を提供するPyramidを使ってアプリケーションを構築することは、貴重な目標です（Joomla、Plone、Drupalが思い浮かびます）。</p>
</div>
<div class="section" id="pyramid-has-zope-things-in-it-so-it-s-too-complex">
<h2>ピラミッドにはゾープが入っているので、複雑すぎる<a class="headerlink" href="#pyramid-has-zope-things-in-it-so-it-s-too-complex" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>場合によっては、誰かが次のようなメーリングリストのメッセージを投稿しなければならないと感じるでしょう：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>had a quick look at pyramid ... too complex to me and not really
understand for which benefits.. I feel should consider whether it&#39;s time
for me to step back to django .. I always hated zope (useless ?)
complexity and I love simple way of thinking
</pre></div>
</div>
<p>（実際の電子メールから言い換えると、実際には。）</p>
<p>この批判をポイントごとに見てみましょう。</p>
<div class="section" id="too-complex">
<h3>複雑すぎる<a class="headerlink" href="#too-complex" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この &amp;quot;hello world&amp;quot;プログラムを理解できれば、Pyramidを使うことができます：</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>
<span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s1">&#39;Hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Configurator</span><span class="p">()</span> <span class="k">as</span> <span class="n">config</span><span class="p">:</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">)</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>ピラミッドには、基本的なものから最も高度なものまで、1200ページ以上のドキュメンテーション（印刷物）があります。 <em>文字通り、文書化されていないものは何もありません。それはまた素晴らしい</em>、非常に有用なコミュニティを持っています。 freenode.netの <a href="#id1"><span class="problematic" id="id2">`</span></a>#pyramid IRCチャンネルをご覧ください&lt;<a class="reference external" href="https://webchat.freenode.net/?channels=pyramid">https://webchat.freenode.net/?channels=pyramid</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_そして参照してください。</p>
</div>
<div class="section" id="hate-zope">
<h3>憎むゾープ<a class="headerlink" href="#hate-zope" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>私はあなたがそのように感じごめんなさい。 Zopeブランドは、長年に渡って確かに塊を占めており、孤独で神秘的であるという評判を持っています。しかし、&amp;quot;ゾープ&amp;quot;という言葉は、文字通り、無意味で無意味です。 Zopeの何があなたのことを憎んでいるのですか？ &amp;quot;Zope &amp;quot;は技術ではなくブランドです。</p>
<p>Zope2-the-web-frameworkの場合、Pyramidはそうではありません。ピラミッドの主なデザイナーと開発者は誰でも知っておくべきです。 Zope 2にユーザビリティの問題や制限があることを知っていたため、Pyramidの前身（：mod： <cite>repoze.bfg</cite>）を書きました。 ：mod： <cite>repoze.bfg`（そして今は：app：</cite> Pyramid`）がこれらの問題に対処するために書かれました。</p>
<p>Zope3-the-web-frameworkの場合、ピラミッドは絶対にそうではありません。多くのZope 3技術を利用することは、既に：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>Grok`プロジェクトによって賭けられています。両方ともWebフレームワークであるという明白な事実のために保存してください：app： <a href="#id3"><span class="problematic" id="id4">`</span></a>Pyramid`はGrokと非常に大きく異なっています。 Grokは多くのZopeテクノロジをエンドユーザーに公開しています。一方、Pyramidを使用してZopeのみのコンセプトを理解する必要がある場合は、いくつかの非常に基本的な軸で失敗しました。</p>
<p>Zopeという単語だけの場合、これは関連性によってのみ罪を犯すことができます。ソフトウェアの一部は内部的に `` zope.foo``という名前のパッケージを使用しているので、それを使用するソフトウェアを&amp;quot;Zope &amp;quot;にすることはありません。その名前にZopeという言葉が書かれた*素晴らしいソフトウェアがたくさんあります。 Zopeはモノリシックなものではなく、多くのソフトウェアが外部で使用可能です。そして、それを守ることは実際にこの文書の仕事ではありませんが、Zopeは10年以上にわたって存在し、信じられないほど大きく、活発なコミュニティを持っています。あなたがこれを信じていないなら、<a class="reference external" href="http://pypi-ranking.info">http://pypi-ranking.info</a>/authorは目を開く現実のチェックです。</p>
</div>
<div class="section" id="love-simplicity">
<h3>愛シンプリシティ<a class="headerlink" href="#love-simplicity" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このパッケージとそのドキュメントは、開発者が使用できるように人間工学的に可能な限りシンプルにするために努力してきました。もちろん、すべてはトレードオフですが、人々は&amp;quot;シンプル&amp;quot;について何か自分の考えを持っています。ピラミッドが複雑だと思えば、スタイルの違いがあるかもしれません。その開発者は明らかに同意しない。</p>
</div>
</div>
<div class="section" id="other-challenges">
<h2>その他の課題<a class="headerlink" href="#other-challenges" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>他の挑戦は <a href="#id1"><span class="problematic" id="id2">`</span></a>Pylons-devel &lt;<a class="reference external" href="https://groups.google.com/forum/#!forum/pylons-devel">https://groups.google.com/forum/#!forum/pylons-devel</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_ maillist。私たちはデザインの変更を考慮して、またはここでは少なくとも展覧会を経てそれらに取り組もうとします。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">(機械翻訳)守るピラミッドのデザイン</a><ul>
<li><a class="reference internal" href="#pyramid-provides-more-than-one-way-to-do-it">ピラミッドは、それを行う方法の一つ以上を提供します</a></li>
<li><a class="reference internal" href="#pyramid-uses-a-zope-component-architecture-zca-registry">ピラミッドはZopeコンポーネントアーキテクチャ（&amp;quot;ZCA &amp;quot;）レジストリを使用します</a><ul>
<li><a class="reference internal" href="#problems">問題</a></li>
<li><a class="reference internal" href="#ameliorations">改善</a></li>
<li><a class="reference internal" href="#rationale">根拠</a></li>
<li><a class="reference internal" href="#conclusion">結論</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-encourages-use-of-zcml">Pyramid &amp;quot;ZCMLの使用を奨励</a></li>
<li><a class="reference internal" href="#pyramid-does-traversal-and-i-don-t-like-traversal">ピラミッドはトラバーサルを行い、トラバースを好まない</a></li>
<li><a class="reference internal" href="#pyramid-does-url-dispatch-and-i-don-t-like-url-dispatch">ピラミッドはURLディスパッチを行いますが、私はURLディスパッチが嫌いです</a></li>
<li><a class="reference internal" href="#pyramid-views-do-not-accept-arbitrary-keyword-arguments">ピラミッドビューは任意のキーワード引数を受け入れない</a></li>
<li><a class="reference internal" href="#pyramid-provides-too-few-rails">Pyramidはあまりにも少ない &amp;quot;Rails </a></li>
<li><a class="reference internal" href="#pyramid-provides-too-many-rails">Pyramidは多すぎる&amp;quot;Rails </a></li>
<li><a class="reference internal" href="#pyramid-is-too-big">ピラミッドが大きすぎます</a></li>
<li><a class="reference internal" href="#pyramid-has-too-many-dependencies">ピラミッドに依存性が多すぎる</a></li>
<li><a class="reference internal" href="#pyramid-cheats-to-obtain-speed">Pyramid &amp;quot;Cheats &amp;quot;で速度を得る</a></li>
<li><a class="reference internal" href="#pyramid-gets-its-terminology-wrong-mvc">ピラミッドの用語が間違っている（&amp;quot;MVC &amp;quot;）</a></li>
<li><a class="reference internal" href="#pyramid-applications-are-extensible-i-don-t-believe-in-application-extensibility">ピラミッドアプリケーションは拡張可能です。私はアプリケーションの拡張性を信じていない</a></li>
<li><a class="reference internal" href="#zope-3-enforces-ttw-authorization-checks-by-default-pyramid-does-not">Zope 3は&amp;quot;TTW &amp;quot;認証チェックをデフォルトで強制します。ピラミッドはしません</a><ul>
<li><a class="reference internal" href="#challenge">チャレンジ</a></li>
<li><a class="reference internal" href="#defense">防衛</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-uses-its-own-http-exception-class-hierarchy-rather-than-webob-exc">Pyramidは、mod： `webob.exc`ではなく、独自のHTTP例外クラス階層を使用します。</a></li>
<li><a class="reference internal" href="#pyramid-has-simpler-traversal-machinery-than-does-zope">ピラミッドはZopeよりも単純なトラバーサル機構を持っています</a></li>
<li><a class="reference internal" href="#microframeworks-have-smaller-hello-world-programs">マイクロフレームワークでは、より小さなHello Worldプログラム</a><ul>
<li><a class="reference internal" href="#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil">アプリケーションプログラマはモジュールスコープコードパスを制御しません（インポート時の副作用は悪です）</a></li>
<li><a class="reference internal" href="#routes-need-relative-ordering">経路には相対的な順序が必要</a></li>
<li><a class="reference internal" href="#stacked-object-proxies-are-too-clever-thread-locals-are-a-nuisance">&amp;quot;スタックされたオブジェクトのプロキシ&amp;quot;があまりにも賢い/スレッドの地元の人は迷惑です</a></li>
<li><a class="reference internal" href="#explicitly-wsgi">明示的にWSGI</a></li>
<li><a class="reference internal" href="#wrapping-up">ラッピング</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-doesn-t-offer-pluggable-apps">Pyramidはプラグイン可能なアプリケーションを提供していません</a></li>
<li><a class="reference internal" href="#pyramid-has-zope-things-in-it-so-it-s-too-complex">ピラミッドにはゾープが入っているので、複雑すぎる</a><ul>
<li><a class="reference internal" href="#too-complex">複雑すぎる</a></li>
<li><a class="reference internal" href="#hate-zope">憎むゾープ</a></li>
<li><a class="reference internal" href="#love-simplicity">愛シンプリシティ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-challenges">その他の課題</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="changes.html"
                        title="前の章へ">(機械翻訳) <span>Pyramid</span> 変更履歴</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="copyright.html"
                        title="次の章へ">(機械翻訳)著作権、商標、帰属</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/designdefense.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="copyright.html" title="(機械翻訳)著作権、商標、帰属"
             >次へ</a> |</li>
        <li class="right" >
          <a href="changes.html" title="(機械翻訳) Pyramid 変更履歴"
             >前へ</a> |</li>
    	<li><a href="index.html">The Pyramid Web Framework v1.9.2</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="copyright.html">Copyright</a> 2008-2018, Agendaless Consulting.
      最終更新: 11月 13, 2018
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 で生成しました。
    </div>
  </body>
</html>